/*
 * ttp_codes.cpp
 *
 *  Created on: Oct 9, 2022
 *      Author: betten
 */






#include "foundations.h"

using namespace std;



namespace orbiter {
namespace layer1_foundations {
namespace coding_theory {




ttp_codes::ttp_codes()
{

}

ttp_codes::~ttp_codes()
{

}


void ttp_codes::twisted_tensor_product_codes(
	field_theory::finite_field *FQ,
	field_theory::finite_field *Fq,
	int f_construction_A, int f_hyperoval,
	int f_construction_B,
	int *&H_subfield, int &m, int &n,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int index;
	int exponents[9];
	int *M;
	//int *H_subfield;
	int *C;
	int *C_inv;

	if (f_v) {
		cout << "ttp_codes::twisted_tensor_product_codes" << endl;
	}

	int q = Fq->q;
	int q2;
	int Q;
	//int m, n;
	int r;
	int beta, beta_q;
	int f_elements_exponential = TRUE;
	string symbol_for_print;
	string symbol_for_print_subfield;


	symbol_for_print.assign("\\alpha");
	symbol_for_print_subfield.assign("\\omega");


	if (f_v) {
		cout << "ttp_codes::twisted_tensor_product_codes" << endl;
		cout << "f_construction_A=" << f_construction_A << endl;
		cout << "f_hyperoval=" << f_hyperoval << endl;
		cout << "f_construction_B=" << f_construction_B << endl;
	}


	q2 = q * q;
	Q = 0;
	if (f_construction_A) {
		Q = q2;
	}
	else if (f_construction_B) {
		Q = q2 * q;
	}
	index = (Q - 1) / (q - 1);

	if (Q != FQ->q) {
		cout << "ttp_codes::twisted_tensor_product_codes "
				"Q != FQ->q" << endl;
		exit(1);
	}


	if (f_vv) {
		cout << "q = " << q << endl;
		cout << "Q = " << Q << endl;
		cout << "index = " << index << endl;
	}

#if 0
	F.init_override_polynomial(Q, override_poly_Q, verbose_level - 2);

	if (f_vv) {
		cout << "field of order " << Q << " initialized" << endl;
		}

	f.init_override_polynomial(q, override_poly_q, verbose_level - 2);

	if (f_vv) {
		cout << "field of order " << q << " initialized" << endl;
		cout << "index = " << index << endl;
		}
#endif

	FQ->compute_subfields(verbose_level - 2);


	if (f_v) {
		cout << "ttp_codes::twisted_tensor_product_codes "
				"before create_matrix_M" << endl;
	}
	create_matrix_M(
			M,
			FQ, Fq,
			m, n, beta, r, exponents,
			f_construction_A, f_hyperoval, f_construction_B,
			f_elements_exponential, symbol_for_print,
			verbose_level - 2);
	if (f_v) {
		cout << "ttp_codes::twisted_tensor_product_codes "
				"after create_matrix_M" << endl;
	}

	beta_q = FQ->power(beta, q);

	if (f_vv) {
		cout << "ttp_codes::twisted_tensor_product_codes "
				"after create_matrix_M" << endl;
		cout << "m = " << m << endl;
		cout << "n = " << n << endl;
		cout << "Q = " << Q << endl;
		cout << "q2 = " << q2 << endl;
		cout << "beta = " << beta << endl;
		cout << "beta_q = " << beta_q << endl;
		cout << "Exponents: ";
		Int_vec_print(cout, exponents, m);
		cout << endl;
	}

	if (f_vv) {
		cout << "ttp_codes::twisted_tensor_product_codes: M:" << endl;
		Int_vec_print_integer_matrix_width(cout, M, m, n, n, 2);

		FQ->Io->latex_matrix(cout,
				f_elements_exponential, symbol_for_print, M, m, n);
	}




#if 0
	for (j = 0; j < n; j++) {
		PG_element_normalize(F, M + j, n, m);
		}
	cout << "column normalized M:" << endl;
	print_integer_matrix_width(cout, M, m, n, n, 2);
#endif




	C = NEW_int(m * m);
	C_inv = NEW_int(m * m);
	H_subfield = NEW_int(m * n);


	if (f_v) {
		cout << "ttp_codes::twisted_tensor_product_codes "
				"before create_matrix_H_subfield" << endl;
	}
	create_matrix_H_subfield(
			FQ, Fq,
		H_subfield, C, C_inv, M, m, n, beta, beta_q,
		f_elements_exponential,
		symbol_for_print, symbol_for_print_subfield,
		f_construction_A, f_construction_B,
		verbose_level - 2);
	if (f_v) {
		cout << "ttp_codes::twisted_tensor_product_codes "
				"after create_matrix_H_subfield" << endl;
	}

	if (f_v) {
		cout << "ttp_codes::twisted_tensor_product_codes "
				"H_subfield:" << endl;
		Int_vec_print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
		Fq->Io->latex_matrix(cout,
				f_elements_exponential,
				symbol_for_print_subfield,
				H_subfield, m, n);
	}

	FREE_int(M);
	FREE_int(C);
	FREE_int(C_inv);

	if (f_v) {
		cout << "ttp_codes::twisted_tensor_product_codes done" << endl;
	}

}


void ttp_codes::create_matrix_M(
	int *&M,
	field_theory::finite_field *FQ,
	field_theory::finite_field *Fq,
	int &m, int &n, int &beta, int &r, int *exponents,
	int f_construction_A, int f_hyperoval, int f_construction_B,
	int f_elements_exponential, std::string &symbol_for_print,
	int verbose_level)
// int exponents[9]
{
	int f_v = (verbose_level >= 1);
	//int f_vv = (verbose_level >= 2);
	int i, j, t, q, Q, q2;

	q = Fq->q;
	q2 = q * q;

	if (f_v) {
		cout << "ttp_codes::create_matrix_M" << endl;
	}


	if (f_construction_A) {

#if 0
		//q = 2; override_poly_Q = ""; override_poly = "";
		//q = 3; override_poly_Q = ""; override_poly = "";
		q = 4; override_poly_Q = "19"; override_poly = "7";
			// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
			// F_16 generated by X^4+X+1 = 19
			// F_4 generated by X^2+X+1 = 7
		//q = 5; override_poly_Q = "47"; override_poly = "";
			// F_625  generated by X^4 + X^3 + 3X + 2
			// F_25  generated by X^2 + 4X + 2  = 47
		//q = 7; override_poly_Q = ""; override_poly = "";
		//q = 8; override_poly_Q = "97"; override_poly = "11";
			// F_4096 generated by x^12+x^6+x^4+x+1
			// F_64 generated by X^6+X^5+1 = 97
			// F_8 generated by X^3+X+1 = 11
		//q = 9; override_poly_Q = ""; override_poly = "17";
#endif
		Q = q2;
		beta = q;
		m = 9;
		if (f_hyperoval) {
			n = Q + 2;
		}
		else {
			n = Q + 1;
		}
		r = 5;
		if (q == 4) {
			r = 7;
		}
		if (q == 3) {
			r = 9;
		}
		// 3 orbits of length 1: 0, q+1, 2q+2
		exponents[0] = 0;
		exponents[1] = q + 1;
		exponents[2] = 2 * q + 2;
		//orbit (q,1)
		exponents[3] = q;
		exponents[4] = 1;
		// orbit (2q, 2)
		exponents[5] = 2 * q;
		exponents[6] = 2;
		// orbit (2q+1, q+2)
		exponents[7] = 2 * q + 1;
		exponents[8] = q + 2;
		//exponents[0] = 0;
		//exponents[1] = q;
		//exponents[2] = 2 * q;
		//exponents[3] = 1;
		//exponents[4] = q + 1;
		//exponents[5] = 2 * q + 1;
		//exponents[6] = 2;
		//exponents[7] = q + 2;
		//exponents[8] = 2 * q + 2;
	}
	else if (f_construction_B) {

#if 0
		//q = 2; override_poly_Q = ""; override_poly = ""; r = 9;
		//q = 3; override_poly_Q = ""; override_poly = ""; r = 5;
		q = 4; override_poly_Q = ""; override_poly = "7"; r = 4;
			// F_4096  generated by X^8 + X^4 + X^3 + X^2 + 1 = 4096
		//q = 5; override_poly_Q = ""; override_poly = ""; r = 4;
		//q = 7; override_poly_Q = ""; override_poly = ""; r = 4;
#endif

		beta = q;
		Q = q2 * q;
		m = 8;
		n = Q + 1;

		exponents[0] = 0;
		exponents[1] = q2 + q + 1;
		exponents[2] = 1;
		exponents[3] = q;
		exponents[4] = q2;
		exponents[5] = q + 1;
		exponents[6] = q2 + q;
		exponents[7] = q2 + 1;
		//exponents[0] = 0;
		//exponents[1] = q;
		//exponents[2] = 1;
		//exponents[3] = q + 1;
		//exponents[4] = q2;
		//exponents[5] = q2 + q;
		//exponents[6] = q2 + 1;
		//exponents[7] = q2 + q + 1;
	}
	else {
		cout << "ttp_codes::create_matrix_M please specify the construction using option -A or -B" << endl;
		exit(1);
	}


	// create matrix M:
	M = NEW_int(m * n);
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			M[i * n + j] = 0;
		}
	}
	for (t = 0; t < Q; t++) {
		for (i = 0; i < m; i++) {
			M[i * n + t] = FQ->power(t, exponents[i]);
		}
	}
	if (f_construction_A) {
		M[2 * n + Q] = 1;
		if (f_hyperoval) {
			M[1 * n + Q + 1] = 1;
		}
	}
	else if (f_construction_B) {
		M[1 * n + Q] = 1;
	}

	if (f_v) {
		cout << "ttp_codes::create_matrix_M M:" << endl;
		Int_vec_print_integer_matrix_width(cout, M, m, n, n, 2);

		cout << "ttp_codes::create_matrix_M M:" << endl;
		FQ->Io->latex_matrix(cout, f_elements_exponential,
				symbol_for_print, M, m, n);
	}


	if (f_v) {
		int *all_one, *col_sum;

		all_one = NEW_int(n);
		col_sum = NEW_int(m);
		for (i = 0; i < n; i++) {
			all_one[i] = 1;
		}
		FQ->Linear_algebra->mult_matrix_matrix(M, all_one, col_sum, m, n, 1,
				0 /* verbose_level */);
		cout << "overall col_sum:" << endl;
		Int_vec_print_integer_matrix_width(cout, col_sum, m, 1, 1, 2);
		FREE_int(all_one);
		FREE_int(col_sum);
	}

	if (f_v) {
		cout << "ttp_codes::create_matrix_M done" << endl;
	}

}



void ttp_codes::create_matrix_H_subfield(
		field_theory::finite_field *FQ,
		field_theory::finite_field *Fq,
	int *H_subfield, int *C, int *C_inv, int *M,
	int m, int n, int beta, int beta_q,
	int f_elements_exponential,
	std::string &symbol_for_print,
	std::string &symbol_for_print_subfield,
	int f_construction_A, /*int f_hyperoval,*/ int f_construction_B,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int i, j;
	int q;
	//int *C;
	//int *C_inv;
	int *H;
	int *AA;
	linear_algebra::representation_theory_domain Rep;

	if (f_v) {
		cout << "ttp_codes::create_matrix_H_subfield" << endl;
	}

	q = Fq->q;


	Rep.init(FQ, verbose_level);
	// matrix C is zero:
	H = NEW_int(m * n);
	AA = NEW_int(m * m);
	for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++) {
			C[i * m + j] = 0;
		}
	}


	if (f_construction_A) {
		int nb_C_coeffs = 15;
		int k, aa;
		int C_coeffs[] = {
			0, 0, 1,
			1, 1, 1,
			2, 2, 1,
			3, 3, 1,
			3, 4, 1,
			4, 3, beta_q,
			4, 4, beta,
			5, 5, 1,
			5, 6, 1,
			6, 5, beta_q,
			6, 6, beta,
			7, 7, 1,
			7, 8, 1,
			8, 7, beta_q,
			8, 8, beta,
		};
		for (k = 0; k < nb_C_coeffs; k++) {
			i = C_coeffs[k * 3 + 0];
			j = C_coeffs[k * 3 + 1];
			aa = C_coeffs[k * 3 + 2];
			C[i * m + j] = aa;
		}
	}
	else if (f_construction_B) {
		int nb_C_coeffs = 20;
		int k, aa;
		int C_coeffs[] = {
			0, 0, 1,
			1, 1, 1,
			2, 2, 1,
			2, 3, 1,
			2, 4, 1,
			3, 2, beta,
			3, 3, beta_q,
			3, 4, Rep.beta_trinomial(q, beta, 1, 0, 0),
			4, 2, Rep.beta_trinomial(q, beta, 0, 0, 2),
			4, 3, Rep.beta_trinomial(q, beta, 0, 2, 0),
			4, 4, Rep.beta_trinomial(q, beta, 2, 0, 0),
			5, 5, 1,
			5, 6, 1,
			5, 7, 1,
			6, 5, Rep.beta_trinomial(q, beta, 0, 1, 1),
			6, 6, Rep.beta_trinomial(q, beta, 1, 1, 0),
			6, 7, Rep.beta_trinomial(q, beta, 1, 0, 1),
			7, 5, Rep.beta_trinomial(q, beta, 0, 2, 2),
			7, 6, Rep.beta_trinomial(q, beta, 2, 2, 0),
			7, 7, Rep.beta_trinomial(q, beta, 2, 0, 2),
		};
		for (k = 0; k < nb_C_coeffs; k++) {
			i = C_coeffs[k * 3 + 0];
			j = C_coeffs[k * 3 + 1];
			aa = C_coeffs[k * 3 + 2];
			C[i * m + j] = aa;
		}
	}


	if (f_v) {
		cout << "ttp_codes::create_matrix_H_subfield matrix C:" << endl;
		Int_vec_print_integer_matrix_width(cout, C, m, m, m, 2);
		FQ->Io->latex_matrix(cout, f_elements_exponential,
				symbol_for_print, C, m, m);
	}


	FQ->Linear_algebra->invert_matrix(C, C_inv, m, 0 /* verbose_level */);

	if (f_vv) {
		cout << "ttp_codes::create_matrix_H_subfield C_inv:" << endl;
		Int_vec_print_integer_matrix_width(cout, C_inv, m, m, m, 2);
	}

	FQ->Linear_algebra->mult_matrix_matrix(C, C_inv, AA, m, m, m,
			0 /* verbose_level */);

	if (f_vv) {
		cout << "ttp_codes::create_matrix_H_subfield C * C_inv:" << endl;
		Int_vec_print_integer_matrix_width(cout, AA, m, m, m, 2);
	}


	FQ->Linear_algebra->mult_matrix_matrix(C, M, H, m, m, n,
			0 /* verbose_level */);

	if (f_v) {
		cout << "ttp_codes::create_matrix_H_subfield H = C * M:" << endl;
		Int_vec_print_integer_matrix_width(cout, H, m, n, n, 2);
		FQ->Io->latex_matrix(cout, f_elements_exponential,
				symbol_for_print, H, m, n);
	}


#if 0
	rk = F.Gauss_int(M, FALSE /* f_special */, TRUE /* f_complete */, base_cols,
		FALSE /* f_P */, NULL, m /* m */, n /* n */, 0 /* Pn */,
		verbose_level - 2);
	cout << "has rank " << rk << endl;
#endif

	tt_field_reduction(*FQ, *Fq, m, n, H, H_subfield, verbose_level - 2);

	if (f_v) {
		cout << "ttp_codes::create_matrix_H_subfield H_subfield:" << endl;
		Int_vec_print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
		Fq->Io->latex_matrix(cout, f_elements_exponential,
				symbol_for_print_subfield, H_subfield, m, n);
	}

	FREE_int(H);
	FREE_int(AA);

	if (f_v) {
		cout << "ttp_codes::create_matrix_H_subfield" << endl;
	}

}



void ttp_codes::tt_field_reduction(
		field_theory::finite_field &FQ,
		field_theory::finite_field &f,
		int m, int n, int *M, int *MM, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int  i, j, a, z, b, c, Q, q;
	int index;

	if (f_v) {
		cout << "ttp_codes::tt_field_reduction" << endl;
	}

	Q = FQ.q;
	q = f.q;
	index = (Q - 1) / (q - 1);
	if (f_v) {
		cout << "ttp_codes::tt_field_reduction, Q=" << Q
				<< " q=" << q << " index=" << index << endl;
	}
	if (f_vv) {
		cout << "ttp_codes::tt_field_reduction before:" << endl;
		Int_vec_print_integer_matrix_width(cout, M, m, n, n, 2);
		//print_integer_matrix(cout, M, m, n);
		cout << endl;
		FQ.Io->print_integer_matrix_zech(cout, M, m, n);
		cout << endl;
	}
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			a = M[i * n + j];
			if (a == 0) {
				c = 0;
			}
			else {
				if (f.e == 1) {
					if (a >= q) {
						cout << "ttp_codes::tt_field_reduction: element does not "
								"lie in the subfield: " << a << endl;
						exit(1);
					}
					c = a;
				}
				else {
					z = FQ.log_alpha(a);
					b = z / index;
					if (b * index != z) {
						cout << "coding_theory_domain::tt_field_reduction "
								"b * index != z" << endl;
						exit(1);
					}
					c = f.alpha_power(b);
				}
			}
			MM[i * n + j] = c;
		}
	}
	if (f_vv) {
		cout << "ttp_codes::tt_field_reduction after:" << endl;
		Int_vec_print_integer_matrix_width(cout, MM, m, n, n, 2);
		//print_integer_matrix(cout, MM, m, n);
		cout << endl;
		f.Io->print_integer_matrix_zech(cout, MM, m, n);
		cout << endl;
	}

	if (f_v) {
		cout << "ttp_codes::tt_field_reduction done" << endl;
	}
}





//############################################### old stuff:

void ttp_codes::make_tensor_code_9dimensional_as_point_set(
		field_theory::finite_field *F,
	int *&the_set, int &length,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_hyperoval = FALSE;
	const char *override_poly = "";
	const char *override_poly_Q = "";
	int i, t, q;
	int *code;

	if (f_v) {
		cout << "ttp_codes::make_tensor_code_9dimensional_as_point_set" << endl;
		}
	q = F->q;
	if (q == 2) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
	}
	else if (q == 3) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
	}
	else if (q == 4) {
		override_poly_Q = "19"; override_poly = "7"; f_hyperoval = FALSE;
		// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
		// F_16 generated by X^4+X+1 = 19
		// F_4 generated by X^2+X+1 = 7
	}
	else if (q == 5) {
		override_poly_Q = "47"; override_poly = ""; f_hyperoval = FALSE;
		// F_625  generated by X^4 + X^3 + 3X + 2
		// F_25  generated by X^2 + 4X + 2  = 47
	}
	else if (q == 7) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
	}
	else if (q == 8) {
		override_poly_Q = "97"; override_poly = "11"; f_hyperoval = TRUE;
		// F_4096 generated by x^12+x^6+x^4+x+1
		// F_64 generated by X^6+X^5+1 = 97
		// F_8 generated by X^3+X+1 = 11
	}
	else if (q == 9) {
		override_poly_Q = ""; override_poly = "17"; f_hyperoval = FALSE;
	}

	string poly_Q, poly_q;

	poly_Q.assign(override_poly_Q);
	poly_q.assign(override_poly);

	make_tensor_code_9_dimensional(q, poly_Q, poly_q,
		f_hyperoval, code, length, verbose_level - 1);

	the_set = NEW_int(length);

	int pt[9];
	long int rk;

	for (t = 0; t < length; t++) {
		for (i = 0; i < 9; i++) {
			pt[i] = code[i * length + t];
		}
		F->Projective_space_basic->PG_element_rank_modified(
				pt, 1, 9, rk);
		the_set[t] = rk;
	}
	FREE_int(code);
	if (f_v) {
		cout << "ttp_codes::make_tensor_code_9dimensional_as_point_set done" << endl;
		cout << "created the set: ";
		Int_vec_print(cout, the_set, length);
		cout << endl;
	}
}

void ttp_codes::make_tensor_code_9_dimensional(int q,
	std::string &override_poly_Q,
	std::string &override_poly,
	int f_hyperoval,
	int *&code, int &length,
	int verbose_level)
// creates two finite_field objects
{
	field_theory::finite_field F;
	field_theory::finite_field f;
	algebra::rank_checker rc;
	int exponents[9];
	int *M;
	int *C;
	int *C_inv;
	int *H;
	int *H_subfield;
	int index, Q, i, j, t, m, n, r, beta, beta_q;
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);


	if (f_v) {
		cout << "ttp_codes::make_tensor_code_9_dimensional q=" << q << endl;
	}

	//q = 2; override_poly_Q = ""; override_poly = ""; int f_hyperoval = FALSE;
	//q = 3; override_poly_Q = ""; override_poly = ""; int f_hyperoval = FALSE;
	//q = 4; override_poly_Q = "19"; override_poly = "7"; int f_hyperoval = FALSE;
		// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
		// F_16 generated by X^4+X+1 = 19
		// F_4 generated by X^2+X+1 = 7
	//q = 5; override_poly_Q = "47"; override_poly = ""; int f_hyperoval = FALSE;
		// F_625  generated by X^4 + X^3 + 3X + 2
		// F_25  generated by X^2 + 4X + 2  = 47
	//q = 7; override_poly_Q = ""; override_poly = ""; int f_hyperoval = FALSE;
	//q = 8; override_poly_Q = "97"; override_poly = "11"; int f_hyperoval = TRUE;
		// F_4096 generated by x^12+x^6+x^4+x+1
		// F_64 generated by X^6+X^5+1 = 97
		// F_8 generated by X^3+X+1 = 11
	//q = 9; override_poly_Q = ""; override_poly = "17"; int f_hyperoval = FALSE;
	beta = q;
	Q = q * q;
	m = 9;
	if (f_hyperoval) {
		n = Q + 2;
	}
	else {
		n = Q + 1;
	}
	r = 5;
	if (q == 4) {
		r = 7;
	}
	if (q == 3) {
		r = 9;
	}
	exponents[0] = 0;
	exponents[1] = q + 1;
	exponents[2] = 2 * q + 2;
	exponents[3] = q;
	exponents[4] = 1;
	exponents[5] = 2 * q;
	exponents[6] = 2;
	exponents[7] = 2 * q + 1;
	exponents[8] = q + 2;
	//exponents[0] = 0;
	//exponents[1] = q;
	//exponents[2] = 2 * q;
	//exponents[3] = 1;
	//exponents[4] = q + 1;
	//exponents[5] = 2 * q + 1;
	//exponents[6] = 2;
	//exponents[7] = q + 2;
	//exponents[8] = 2 * q + 2;

	index = (Q - 1) / (q - 1);


	cout << "q = " << q
			<< " override polynomial = " << override_poly << endl;
	cout << "Q = " << Q << endl;

	F.init_override_polynomial_small_order(
			Q, override_poly_Q,
			FALSE /* f_without_tables */,
			FALSE /* f_compute_related_fields */,
			verbose_level);

	cout << "field of order " << Q << " initialized" << endl;
	beta_q = F.power(beta, q);
	f.init_override_polynomial_small_order(
			q, override_poly,
			FALSE /* f_without_tables */,
			FALSE /* f_compute_related_fields */,
			verbose_level);

	cout << "field of order " << q << " initialized" << endl;
	cout << "n = " << n << endl;
	cout << "index = " << index << endl;
	cout << "beta = " << beta << endl;
	cout << "beta_q = " << beta_q << endl;
	F.compute_subfields(verbose_level - 3);


	field_theory::subfield_structure *SubS;

	SubS = NEW_OBJECT(field_theory::subfield_structure);

	if (f_v) {
		cout << "ttp_codes::make_tensor_code_9_dimensional "
				"before SubS->init" << endl;
	}
	SubS->init(
			&F,
			&f, verbose_level);
	if (f_v) {
		cout << "ttp_codes::make_tensor_code_9_dimensional "
				"after SubS->init" << endl;
	}



	M = NEW_int(m * n);
	C = NEW_int(m * m);
	C_inv = NEW_int(m * m);
	H = NEW_int(m * n);
	H_subfield = NEW_int(m * n);

	rc.init(&f, m, n, r + 1);

	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			M[i * n + j] = 0;
		}
	}
	for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++) {
			C[i * m + j] = 0;
		}
	}
	for (t = 0; t < Q; t++) {
		for (i = 0; i < m; i++) {
			M[i * n + t] = F.power(t, exponents[i]);
		}
	}
	{
		M[2 * n + Q] = 1;
		if (f_hyperoval) {
			M[1 * n + Q + 1] = 1;
		}
		int nb_C_coeffs = 15;
		int k, aa;
		int C_coeffs[] = {
			0, 0, 1,
			1, 1, 1,
			2, 2, 1,
			3, 3, 1,
			3, 4, 1,
			4, 3, beta_q,
			4, 4, beta,
			5, 5, 1,
			5, 6, 1,
			6, 5, beta_q,
			6, 6, beta,
			7, 7, 1,
			7, 8, 1,
			8, 7, beta_q,
			8, 8, beta,
			};
		for (k = 0; k < nb_C_coeffs; k++) {
			i = C_coeffs[k * 3 + 0];
			j = C_coeffs[k * 3 + 1];
			aa = C_coeffs[k * 3 + 2];
			C[i * m + j] = aa;
		}
	}

	cout << "M:" << endl;
	Int_vec_print_integer_matrix_width(
			cout, M, m, n, n, 2);

	{
		int *all_one, *col_sum;

		all_one = NEW_int(n);
		col_sum = NEW_int(m);
		for (i = 0; i < n; i++) {
			all_one[i] = 1;
		}
		F.Linear_algebra->mult_matrix_matrix(
				M, all_one, col_sum, m, n, 1,
				0 /* verbose_level */);
		cout << "col_sum:" << endl;
		Int_vec_print_integer_matrix_width(
				cout, col_sum, m, 1, 1, 2);
		FREE_int(all_one);
		FREE_int(col_sum);
	}

#if 0
	for (j = 0; j < n; j++) {
		PG_element_normalize(F, M + j, n, m);
		}
	cout << "column normalized M:" << endl;
	print_integer_matrix_width(cout, M, m, n, n, 2);
#endif


	cout << "C:" << endl;
	Int_vec_print_integer_matrix_width(
			cout, C, m, m, m, 2);

	F.Linear_algebra->invert_matrix(
			C, C_inv, m, 0 /* verbose_level */);

	cout << "C_inv:" << endl;
	Int_vec_print_integer_matrix_width(
			cout, C_inv, m, m, m, 2);

	{
		int *AA;
		AA = NEW_int(m * m);
		F.Linear_algebra->mult_matrix_matrix(
				C, C_inv, AA, m, m, m,
				0 /* verbose_level */);
		cout << "C * C_inv:" << endl;
		Int_vec_print_integer_matrix_width(
				cout, AA, m, m, m, 2);
		FREE_int(AA);
	}

	F.Linear_algebra->mult_matrix_matrix(
			C, M, H, m, m, n,
			0 /* verbose_level */);
	cout << "H = C * M:" << endl;
	Int_vec_print_integer_matrix_width(
			cout, H, m, n, n, 2);


#if 0
	rk = F.Gauss_int(
			M, FALSE /* f_special */, TRUE /* f_complete */, base_cols,
		FALSE /* f_P */, NULL, m /* m */, n /* n */, 0 /* Pn */,
		FALSE, FALSE);
	cout << "has rank " << rk << endl;
#endif

	if (f_vv) {
		cout << "before field reduction:" << endl;
		Int_vec_print_integer_matrix_width(
				cout, H, m, n, n, 2);
		cout << endl;
		f.Io->print_integer_matrix_zech(
				cout, H, m, n);
		cout << endl;
	}

	if (f_vv) {
		cout << "before SubS->retract_int_vec" << endl;
	}
	SubS->retract_int_vec(
			H, H_subfield, m * n, 0 /* verbose_level */);
	if (f_vv) {
		cout << "after SubS->retract_int_vec" << endl;
	}


	//field_reduction(F, f, m, n, H, H_subfield, TRUE, TRUE);
	if (f_vv) {
		cout << "after field reduction:" << endl;
		Int_vec_print_integer_matrix_width(
				cout, H_subfield, m, n, n, 2);
		cout << endl;
		f.Io->print_integer_matrix_zech(
				cout, H_subfield, m, n);
		cout << endl;
	}
	cout << "H_subfield:" << endl;
	Int_vec_print_integer_matrix_width(
			cout, H_subfield, m, n, n, 2);

	code = H_subfield;
	length = n;

	FREE_OBJECT(SubS);
	FREE_int(M);
	FREE_int(C);
	FREE_int(C_inv);
	FREE_int(H);

}


void ttp_codes::do_tensor(
		int q,
		std::string &override_poly_Q,
		std::string &override_poly_q,
	int f_construction_A, int f_hyperoval,
	int f_construction_B,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	field_theory::finite_field F;
	field_theory::finite_field f;
	int index;
	int exponents[9];
	int *M;
	int *H_subfield;
	int *C;
	int *C_inv;


	int q2;
	int Q;
	int m, n;
	int r;
	int beta, beta_q;
	int f_elements_exponential = TRUE;
	std::string symbol_for_print("\\alpha");
	std::string symbol_for_print_subfield("\\omega");

	coding_theory::coding_theory_domain Codes;



	if (f_v) {
		cout << "ttp_codes::do_tensor" << endl;
		cout << "f_construction_A=" << f_construction_A << endl;
		cout << "f_hyperoval=" << f_hyperoval << endl;
		cout << "f_construction_B=" << f_construction_B << endl;
	}


	q2 = q * q;
	Q = 0;
	if (f_construction_A) {
		Q = q2;
	}
	else if (f_construction_B) {
		Q = q2 * q;
	}
	index = (Q - 1) / (q - 1);

	int f_without_tables = FALSE;

	if (f_v) {
		cout << "q = " << q
				<< " override polynomial_q = " << override_poly_q << endl;
		cout << "Q = " << Q << endl;
		cout << "index = " << index << endl;
	}

	F.init_override_polynomial_small_order(Q,
			override_poly_Q,
			f_without_tables,
			FALSE /* f_compute_related_fields */,
			verbose_level - 2);



	if (f_v) {
		cout << "field of order " << Q << " initialized" << endl;
	}

	f.init_override_polynomial_small_order(q,
			override_poly_q,
			f_without_tables,
			FALSE /* f_compute_related_fields */,
			verbose_level - 2);

	if (f_v) {
		cout << "field of order " << q << " initialized" << endl;
		cout << "index = " << index << endl;
	}

	F.compute_subfields(verbose_level);


	coding_theory::ttp_codes TTp;


	TTp.create_matrix_M(
			M,
			&F, &f,
			m, n, beta, r, exponents,
			f_construction_A, f_hyperoval, f_construction_B,
			f_elements_exponential, symbol_for_print,
			verbose_level - 2);

	beta_q = F.power(beta, q);

	if (f_v) {
		cout << "after create_matrix_M" << endl;
		cout << "m = " << m << endl;
		cout << "n = " << n << endl;
		cout << "Q = " << Q << endl;
		cout << "q2 = " << q2 << endl;
		cout << "beta = " << beta << endl;
		cout << "beta_q = " << beta_q << endl;
		cout << "Exponents: ";
		Int_vec_print(cout, exponents, m);
		cout << endl;
	}

	if (f_v) {
		cout << "M:" << endl;
		Int_vec_print_integer_matrix_width(
				cout, M, m, n, n, 2);

		F.Io->latex_matrix(
				cout, f_elements_exponential, symbol_for_print, M, m, n);
	}




#if 0
	for (j = 0; j < n; j++) {
		PG_element_normalize(F, M + j, n, m);
		}
	cout << "column normalized M:" << endl;
	Int_vec_print_integer_matrix_width(
			cout, M, m, n, n, 2);
#endif




	C = NEW_int(m * m);
	C_inv = NEW_int(m * m);
	H_subfield = NEW_int(m * n);


	TTp.create_matrix_H_subfield(
			&F, &f,
		H_subfield, C, C_inv, M, m, n, beta, beta_q,
		f_elements_exponential,
		symbol_for_print,
		symbol_for_print_subfield,
		f_construction_A, f_construction_B,
		verbose_level - 2);


	if (f_v) {
		cout << "after create_matrix_H_subfield" << endl;
		cout << "H_subfield:" << endl;
		Int_vec_print_integer_matrix_width(
				cout, H_subfield, m, n, n, 2);
		f.Io->latex_matrix(
				cout, f_elements_exponential,
				symbol_for_print_subfield, H_subfield, m, n);
	}

	int rk;

	rk = f.Linear_algebra->Gauss_easy(
			H_subfield, m, n);
	if (f_v) {
		cout << "after row reduction:" << endl;
		cout << "H_subfield:" << endl;
		Int_vec_print_integer_matrix_width(
				cout, H_subfield, rk, n, n, 2);
	}

#if 0
	Codes.do_other_stuff(&F, &f, beta, beta_q,
		M, C, C_inv, H_subfield,
		m, n, r,
		f_elements_exponential, symbol_for_print, symbol_for_print_subfield,
		f_construction_A, f_hyperoval, f_construction_B,
		verbose_level);
#endif

}




void ttp_codes::action_on_code(
		field_theory::finite_field &F,
		field_theory::finite_field &f, int m, int n,
	int *M, int *H_subfield,
	int *C, int *C_inv, int *A, int *U,
	int *perm, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int *perm2;
	int *U_subfield;
	int *T, *B, *B_subfield;
	int i, j;
	coding_theory::coding_theory_domain Codes;
	coding_theory::ttp_codes TTp;


	perm2 = NEW_int(n);
	U_subfield = NEW_int(m * m);
	T = NEW_int(m * m);
	B = NEW_int(m * m);
	B_subfield = NEW_int(m * m);

	if (f_v) {
		//cout << "ttp_codes::action_on_code" << endl;
		if (f_vv) {
			cout << "A" << endl;
			Int_vec_print_integer_matrix_width(cout, A, m, m, m, 2);
		}
	}



	F.Linear_algebra->projective_action_on_columns_from_the_left(
			A, M, m, n, perm, verbose_level - 1);
	//F.transpose_matrix(A, At, m, m);

#if 1
	//cout << "C:" << endl;
	//Int_vec_print_integer_matrix_width(cout, C, m, m, m, 2);

	F.Linear_algebra->mult_matrix_matrix(C, A, T, m, m, m,
			0 /* verbose_level */);

	//cout << "C * A:" << endl;
	//Int_vec_print_integer_matrix_width(cout, T, m, m, m, 2);

	//cout << "C_inv:" << endl;
	//Int_vec_print_integer_matrix_width(cout, C_inv, m, m, m, 2);

	F.Linear_algebra->mult_matrix_matrix(T, C_inv, B, m, m, m,
			0 /* verbose_level */);

	//cout << "transformed, C * A * C_inv:" << endl;
	//Int_vec_print_integer_matrix_width(cout, B, m, m, m, 2);

	if (f_vv) {
		cout << "transformed:" << endl;
		Int_vec_print_integer_matrix_width(cout, B, m, m, m, 2);
	}



	TTp.tt_field_reduction(F, f, m, m, B, B_subfield, 0);
	if (f_vv) {
		cout << "transformed matrix over the subfield:" << endl;
		Int_vec_print_integer_matrix_width(cout, B_subfield, m, m, m, 2);
	}
	if (f_vv) {
		cout << "U:" << endl;
		Int_vec_print_integer_matrix_width(cout, U, m, m, m, 2);
	}

	TTp.tt_field_reduction(F, f, m, m, U, U_subfield, 0);

	if (f_vv) {
		cout << "U over the subfield:" << endl;
		Int_vec_print_integer_matrix_width(cout, U_subfield, m, m, m, 2);
	}

	for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++) {
			if (U_subfield[i * m + j] != B_subfield[i * m + j]) {
				cout << "entries " << i << "," << j << " differ" << endl;
				cout << "U over the subfield:" << endl;
				Int_vec_print_integer_matrix_width(cout, U_subfield, m, m, m, 2);
				cout << "R transformed over the subfield:" << endl;
				Int_vec_print_integer_matrix_width(cout, B_subfield, m, m, m, 2);
				exit(1);
			}
		}
	}


	//f.transpose_matrix_in_place(U_subfield, m);
	//if (f_vv) {
		//cout << "after transpose:" << endl;
		//Int_vec_print_integer_matrix_width(cout, B_subfield, m, m, m, 2);
		//}

	f.Linear_algebra->projective_action_on_columns_from_the_left(
			U_subfield, H_subfield, m, n, perm2,
			verbose_level - 1);

	for (i = 0; i < n; i++) {
		if (perm[i] != perm2[i]) {
			cout << "permutations differ in position " << i << endl;
			exit(1);
		}
	}
#endif
	FREE_int(perm2);
	FREE_int(U_subfield);
	FREE_int(T);
	FREE_int(B);
	FREE_int(B_subfield);
}

void ttp_codes::test_cyclic(
		field_theory::finite_field &F,
		field_theory::finite_field &f,
	int *Aut, int *M, int *H_subfield,
	int *C, int *C_inv, int *U,
	int q, int Q, int m, int n,
	int beta, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int f_vvv = (verbose_level >= 3);
	int u;
	int QQ = Q * Q;
	int N = QQ - 1;
	field_theory::finite_field FQQ;
	int *abcd, a, b, c, d, e1, e2, r1, r2, a0, a1, b0, b1, E1, E2, ex;
	number_theory::number_theory_domain NT;
	int f_without_tables = FALSE;


	int i, j, len, exponent, subexponent, subfield_index;
	int *taken;
	int *transversal, tl = 0;

	subfield_index = (QQ - 1) / (Q - 1);
	ex = (QQ - 1) / subfield_index;

	FQQ.finite_field_init_small_order(QQ,
			f_without_tables,
			FALSE /* f_compute_related_fields */,
			verbose_level);
	FQQ.compute_subfields(verbose_level);

	taken = NEW_int(N);
	transversal = NEW_int(N);
	for (i = 0; i < N; i++)
		taken[i] = FALSE;

	if (f_v) {
		cout << "test_cyclic" << endl;
	}
	if (f_vvv) {
		cout << "cyclotomic cosets : exponent : subexponent" << endl;
	}
	for (i = 0; i < N; i++) {
		j = (i) % N;
		if (taken[j]) {
			continue;
		}
		//j0 = j;
		taken[j] = TRUE;
		if (f_vvv) {
			cout << Q << "-cyclotomic coset of " << j << " : " << j;
		}
		len = 1;
		while (TRUE) {
			j = (Q * j) % N;
			if (taken[j]) {
				break;
			}
			taken[j] = TRUE;
			len++;
			if (f_vvv) {
				cout << "," << j;
			}
		}
		exponent = N / NT.gcd_lint(N, j);
		subexponent = exponent / NT.gcd_lint(Q - 1, exponent);
		if (f_vvv) {
			cout << " : " << exponent << " : " << subexponent << endl;
		}
		if (len == 2 && exponent == n && subexponent == exponent) {
			transversal[tl++] = j;
		}
	}

	if (f_v) {
		cout << "found " << tl << " irreducible polynomials exponent = " << n << endl;
	}
	if (f_vv) {
		cout << "transversal: ";
		for (i = 0; i < tl; i++) {
			cout << transversal[i] << " ";
		}
		cout << endl;
		cout << "exponents:";
		for (i = 0; i < n; i++) {
			if (!taken[i]) {
				continue;
			}
			cout << i << ", ";
		}
		cout << endl;
	}
	abcd = NEW_int(tl * 4);
	if (f_v) {
		cout << "i : e1 : e2 : E1 : E2 : r1 : r2 : a0 : a1 : b0 : b1 : a : b : c : d" << endl;
	}
	for (i = 0; i < tl; i++) {
		e1 = transversal[i];
		e2 = (Q * e1) % N;
		E1 = e1 / ex;
		E2 = e2 / ex;
		if (E1 * ex != e1) {
			cout << "E1 * ex != e1" << endl;
			cout << "e1=" << e1 << endl;
			cout << "ex=" << ex << endl;
			exit(1);
		}
		if (E2 * ex != e2) {
			cout << "E2 * subfield_index != e2" << endl;
			cout << "e2=" << e2 << endl;
			cout << "ex=" << ex << endl;
			exit(1);
		}
		//cout << "e1=" << e1 << endl;
		//cout << "e2=" << e2 << endl;
		r1 = FQQ.alpha_power(e1);
		r2 = FQQ.alpha_power(e2);
		//cout << "r1=" << r1 << endl;
		//cout << "r2=" << r2 << endl;
		a0 = FQQ.mult(r1, r2);
		a1 = FQQ.add(r1, r2);
		if (a0) {
			b0 = F.alpha_power(FQQ.log_alpha(a0) / subfield_index);
		}
		else {
			b0 = 0;
		}
		if (a1) {
			b1 = F.alpha_power(FQQ.log_alpha(a1) / subfield_index);
		}
		else {
			b1 = 0;
		}
		a = 0;
		b = 1;
		c = F.negate(b0);
		d = b1;
		if (f_v) {
			cout << i
			<< " : " << e1 << " : " << e2
			<< " : " << E1 << " : " << E2
			<< " : " << r1 << " : " << r2
			<< " : " << a0 << " : " << a1
			<< " : " << b0 << " : " << b1
			<< " : " << a << " : " << b << " : " << c << " : " << d << endl;
			cout << i << " : X^2 - " << b1 << " X + " << b0 << endl;
		}
		abcd[i * 4 + 0] = a;
		abcd[i * 4 + 1] = b;
		abcd[i * 4 + 2] = c;
		abcd[i * 4 + 3] = d;
	}


	//exit(1);

	for (u = 0; u < tl; u++) {
		a = abcd[u * 4 + 0];
		b = abcd[u * 4 + 1];
		c = abcd[u * 4 + 2];
		d = abcd[u * 4 + 3];
		if (f_v) {
			cout << "============================" << endl;
			cout << "u=" << u << endl;
		}
		is_cyclic(FQQ, F, f, Aut, M, H_subfield, C, C_inv, U,
			q, Q, m, n, beta, a, b, c, d, verbose_level);
	}
	FREE_int(taken);
	FREE_int(transversal);
	FREE_int(abcd);
}


void ttp_codes::is_cyclic(
		field_theory::finite_field &FQQ,
		field_theory::finite_field &F,
		field_theory::finite_field &f,
	int *Aut, int *M, int *H_subfield,
	int *C, int *C_inv, int *U,
	int q, int Q, int m, int n,
	int beta, int a, int b, int c, int d,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	//int f_vvv = (verbose_level >= 3);
	int i, j;
	int *v1, *v2;
	int *perm;
	int *Hgamma, *Hgamma_subfield, *M2, *M3;
	int *base_cols;
	combinatorics::combinatorics_domain Combi;
	coding_theory::coding_theory_domain Codes;


	v1 = NEW_int(m);
	v2 = NEW_int(m);
	perm = NEW_int(n);
	base_cols = NEW_int(n);
	Hgamma = NEW_int(m * n);
	Hgamma_subfield = NEW_int(m * n);
	M2 = NEW_int(m * n);
	M3 = NEW_int(m * n);

	if (f_v) {
		cout << "is_cyclic: a=" << a << " b=" << b << " c=" << c << " d=" << d << endl;
		}

#if CONSTRUCTION_A
	F.representing_matrix9_R(Aut, q, a, b, c, d);
	F.representing_matrix9_U(U, a, b, c, d, beta);
#endif
#if CONSTRUCTION_B
	F.representing_matrix8_R(Aut, q, a, b, c, d);
	F.representing_matrix8_U(U, a, b, c, d, beta);
#endif




	action_on_code(
			F, f, m, n, M, H_subfield,
			C, C_inv, Aut, U, perm,
			verbose_level - 1);
	if (f_v) {
		Combi.perm_print(cout, perm, n);
		cout << endl;
		}

	for (i = 0; i < m; i++) {
		v1[i] = M[i * n + 0];
		M2[i * n + 0] = v1[i];
		}
	j = 0;
	if (f_vv) {
		cout << "j=" << j << " v1=" << endl;
		Int_vec_print_integer_matrix_width(
				cout, v1, 1, m, m, 2);
		}
	for (j = 1; j < n; j++) {
		F.Linear_algebra->mult_matrix_matrix(
				Aut, v1, v2, m, m, 1,
				0 /* verbose_level */);
		if (f_vv) {
			cout << "j=" << j << " v2=" << endl;
			Int_vec_print_integer_matrix_width(
					cout, v2, 1, m, m, 2);
			}
		for (i = 0; i < m; i++) {
			M2[i * n + j] = v2[i];
			v1[i] = v2[i];
			}
		}
	F.Linear_algebra->mult_matrix_matrix(
			Aut, v1, v2, m, m, 1,
			0 /* verbose_level */);
	if (f_v) {
		cout << "last v2=" << endl;;
		Int_vec_print_integer_matrix_width(
				cout, v2, 1, m, m, 2);
		}
	if (v2[0] != 1) {
		cout << "not an n-cycle" << endl;
		exit(1);
		}
	for (i = 1; i <m; i++)
		if (v2[i]) {
			cout << "not an n-cycle" << endl;
			exit(1);
			}
	coding_theory::ttp_codes TTp;


	F.Linear_algebra->mult_matrix_matrix(
			C, M2, Hgamma, m, m, n,
			0 /* verbose_level */);
	TTp.tt_field_reduction(
			F, f, m, n, Hgamma, Hgamma_subfield, 0);

	if (f_v) {
		cout << "permuted matrix Hgamma_subfield: " << endl;
		Int_vec_print_integer_matrix_width(
				cout, Hgamma_subfield, m, n, n, 2);
		}

	F.Linear_algebra->Gauss_int(
			M2, FALSE /* f_special */,
			TRUE /* f_complete */, base_cols,
		FALSE /* f_P */, NULL, m /* m */, n /* n */, 0 /* Pn */,
		verbose_level - 2);
	//cout << "has rank " << rk << endl;
	//print_integer_matrix_width(cout, MMM, m, n, n, 2);

	F.Linear_algebra->reverse_matrix(M2, M3, m, n);
	//cout << "reversed matrix: " << endl;
	//print_integer_matrix_width(cout, M2, m, n, n, 2);

	F.Linear_algebra->Gauss_int(
			M3, FALSE /* f_special */,
			FALSE /* f_complete */, base_cols,
		FALSE /* f_P */, NULL, m /* m */, n /* n */, 0 /* Pn */,
		verbose_level - 2);
	//cout << "has rank " << rk << endl;

	F.Linear_algebra->reverse_matrix(M3, M2, m, n);

	if (f_v) {
		cout << "normal form: " << endl;
		Int_vec_print_integer_matrix_width(
				cout, M2, m, n, n, 2);
		}

	ring_theory::unipoly_domain FqX(&F);
	ring_theory::unipoly_object gen, Xnm1, quo, rem, h, Xma;

	//cout << "creating polynomial of degree " << n - m << endl;
	FqX.create_object_of_degree(gen, n - m);
	for (i = 0; i <= n - m; i++) {
		a = M2[i];
		FqX.s_i(gen, i) = a;
		}
	if (f_v) {
		cout << "generator polynomial: ";
		FqX.print_object(gen, cout);
		cout << endl;
		}
	//cout << "creating polynomial of degree " << n << endl;
	FqX.create_object_of_degree(Xnm1, n);
	for (i = 0; i <= n; i++) {
		if (i == 0)
			a = F.negate(1);
		else if (i == n)
			a = 1;
		else
			a = 0;
		FqX.s_i(Xnm1, i) = a;
		}
	if (f_vv) {
		cout << "X^n-1: ";
		FqX.print_object(Xnm1, cout);
		cout << endl;
		}
	FqX.create_object_of_degree(quo, n);
	FqX.create_object_of_degree(rem, n);

	FqX.division_with_remainder(Xnm1, gen, quo, rem, 0);
	if (f_v) {
		cout << "quo=" << endl;
		FqX.print_object(quo, cout);
		cout << endl;
		cout << "rem=" << endl;
		FqX.print_object(rem, cout);
		cout << endl;
		}

	int QQ = Q * Q;
	//finite_field FQQ;
	int subgroup_index, deg_h, n_index;

	deg_h = FqX.degree(quo);
	FqX.create_object_of_degree(h, deg_h);
	for (i = 0; i <= deg_h; i++) {
		a = FqX.s_i(quo, i);
		FqX.s_i(h, i) = a;
		}
	cout << "reverse polynomial h=" << endl;
	FqX.print_object(h, cout);
	cout << endl;
	for (i = 0; i <= deg_h; i++) {
		a = FqX.s_i(h, i);
		if (a != 0 && a != 1) {
			break;
		}
	}
	//if (a > deg_h) {
		//cout << "polynomial has only 0/1-coefficients" << endl;
		//exit(1);
	//	}

	//FQQ.init(QQ, FALSE, FALSE);
	ring_theory::unipoly_domain FQQX(&FQQ);

	subgroup_index = (QQ - 1) / (Q - 1);
	if (f_vv) {
		cout << "subgroup_index=" << subgroup_index << endl;
		}
	for (i = 0; i <= deg_h; i++) {
		a = FqX.s_i(h, i);
		if (a) {
			b = F.log_alpha(a);
			b *= subgroup_index;
			a = FQQ.alpha_power(b);
			}
		FqX.s_i(h, i) = a;
		}
	if (f_vv) {
		cout << "embedded polynomial:" << endl;
		FQQX.print_object(h, cout);
		cout << endl;
		}
	n_index = (QQ - 1) / n;
	if (f_v) {
		cout << "n_index=" << n_index << endl;
		cout << "zero : alpha_power : zeta_n power" << endl;
		}

	int *taken, *transversal, tl = 0;

	taken = NEW_int(n);
	transversal = NEW_int(n);
	for (i = 0; i < n; i++)
		taken[i] = FALSE;

#if 0
	for (i = 0; i < ; i++) {
		j = (i) % N;
		if (taken[j])
			continue;
		j0 = j;
		taken[j] = TRUE;
		if (f_v) {
			cout << Q << "-cyclotomic coset of " << j << " : " << j;
			}
		len = 1;
		while (TRUE) {
			j = (Q * j) % N;
			if (taken[j])
				break;
			taken[j] = TRUE;
			len++;
			if (f_v)
				cout << "," << j;
			}
		exponent = N / gcd_int(N, j);
		subexponent = exponent / gcd_int(Q - 1, exponent);
		if (f_v) {
			cout << " : " << exponent << " : " << subexponent << endl;
			}
		if (len == 2 && exponent == n && subexponent == exponent) {
			transversal[tl++] = j;
			}
		}
#endif



	for (a = 1; a < QQ; a++) {
		FQQX.create_object_of_degree(Xma, 1);
		FQQX.s_i(Xma, 0) = FQQ.negate(a);
		FQQX.s_i(Xma, 1) = 1;
		FQQX.division_with_remainder(h, Xma, quo, rem, 0);
		b = FQQX.s_i(rem, 0);
		if (b == 0) {
			c = FQQ.log_alpha(a);
			d = c / n_index;
			d = d % n;
			if (f_v) {
				cout << a << " : {" << d << " ";
				}
			if (!taken[d]) {
				transversal[tl++] = d;
				taken[d] = TRUE;
				j = d;
				while (TRUE) {
					j = (j * q) % n;
					if (taken[j])
						break;
					taken[j] = TRUE;
					if (f_v)
						cout << "," << j;
					}
				}
			if (f_v) {
				cout << "} : " << c << " : " << d << endl;
				}
			}
		}

	cout << "we found the following " << q << "-cyclotomic cosets" << endl;
	for (i = 0; i < tl; i++) {
		j = transversal[i];
		cout << "{";
		while (TRUE) {
			cout << j << " ";
			j = (j * q) % n;
			if (j == transversal[i]) {
				cout << "}" << endl;
				break;
				}
			}
		}

	FREE_int(v1);
	FREE_int(v2);
	FREE_int(base_cols);
	FREE_int(Hgamma);
	FREE_int(Hgamma_subfield);
	FREE_int(M2);
	FREE_int(M3);
}

void ttp_codes::test_representation(
		field_theory::finite_field &F,
		field_theory::finite_field &f, int Q,
	int beta, int m, int n, int *H_subfield)
{
	int *U1, *U2, *U3, *U4;
	int *U1s, *U2s, *U3s, *U4s;
	int *perm1, *perm2, *perm3, *perm4;
	int a1, b1, c1, d1;
	int a2, b2, c2, d2;
	int a3, b3, c3, d3;
	int i, j;
	combinatorics::combinatorics_domain Combi;
	coding_theory::coding_theory_domain Codes;


	U1 = NEW_int(m * m);
	U2 = NEW_int(m * m);
	U3 = NEW_int(m * m);
	U4 = NEW_int(m * m);
	U1s = NEW_int(m * m);
	U2s = NEW_int(m * m);
	U3s = NEW_int(m * m);
	U4s = NEW_int(m * m);
	perm1 = NEW_int(n);
	perm2 = NEW_int(n);
	perm3 = NEW_int(n);
	perm4 = NEW_int(n);

	choose_abcd_at_random(F, Q, a1, b1, c1, d1);
	choose_abcd_at_random(F, Q, a2, b2, c2, d2);
	multiply_abcd(F, a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3);
#if CONSTRUCTION_A
	F.representing_matrix9_U(U1, a1, b1, c1, d1, beta);
	F.representing_matrix9_U(U2, a2, b2, c2, d2, beta);
	F.representing_matrix9_U(U3, a3, b3, c3, d3, beta);
#endif
#if CONSTRUCTION_B
	F.representing_matrix8_U(U1, a1, b1, c1, d1, beta);
	F.representing_matrix8_U(U2, a2, b2, c2, d2, beta);
	F.representing_matrix8_U(U3, a3, b3, c3, d3, beta);
#endif
	F.Linear_algebra->mult_matrix_matrix(U2, U1, U4, m, m, m,
			0 /* verbose_level */);


	coding_theory::ttp_codes TTp;

	TTp.tt_field_reduction(F, f, m, m, U1, U1s, 0);
	TTp.tt_field_reduction(F, f, m, m, U2, U2s, 0);
	TTp.tt_field_reduction(F, f, m, m, U3, U3s, 0);
	TTp.tt_field_reduction(F, f, m, m, U4, U4s, 0);

	f.Linear_algebra->projective_action_on_columns_from_the_left(U1s, H_subfield, m, n, perm1, 0);
	f.Linear_algebra->projective_action_on_columns_from_the_left(U2s, H_subfield, m, n, perm2, 0);
	f.Linear_algebra->projective_action_on_columns_from_the_left(U3s, H_subfield, m, n, perm3, 0);
	f.Linear_algebra->projective_action_on_columns_from_the_left(U4s, H_subfield, m, n, perm4, 0);
	for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++) {
			if (U3[i * m + j] != U4[i * m + j]) {
				cout << "error in representation" << endl;
				cout << "a1=" << a1 << " b1=" << b1 << " c1=" << c1 << " d1=" << d1 << endl;
				cout << "a2=" << a2 << " b2=" << b2 << " c2=" << c2 << " d2=" << d2 << endl;
				cout << "a3=" << a3 << " b3=" << b3 << " c3=" << c3 << " d3=" << d3 << endl;
				cout << "U1:" << endl;
				Int_vec_print_integer_matrix_width(cout, U1, m, m, m, 2);
				cout << "U2:" << endl;
				Int_vec_print_integer_matrix_width(cout, U2, m, m, m, 2);
				cout << "U3:" << endl;
				Int_vec_print_integer_matrix_width(cout, U3, m, m, m, 2);
				cout << "U4:" << endl;
				Int_vec_print_integer_matrix_width(cout, U4, m, m, m, 2);
				cout << "U1s:" << endl;
				Int_vec_print_integer_matrix_width(cout, U1s, m, m, m, 2);
				cout << "U2s:" << endl;
				Int_vec_print_integer_matrix_width(cout, U2s, m, m, m, 2);
				cout << "U3s:" << endl;
				Int_vec_print_integer_matrix_width(cout, U3s, m, m, m, 2);
				cout << "U4s:" << endl;
				Int_vec_print_integer_matrix_width(cout, U4s, m, m, m, 2);
				cout << "perm1:" << endl;
				Combi.perm_print(cout, perm1, n);
				cout << endl;
				cout << "perm2:" << endl;
				Combi.perm_print(cout, perm2, n);
				cout << endl;
				cout << "perm3:" << endl;
				Combi.perm_print(cout, perm3, n);
				cout << endl;
				cout << "perm4:" << endl;
				Combi.perm_print(cout, perm4, n);
				cout << endl;
				exit(1);
				}
			}
		}
	FREE_int(U1);
	FREE_int(U2);
	FREE_int(U3);
	FREE_int(U4);
	FREE_int(U1s);
	FREE_int(U2s);
	FREE_int(U3s);
	FREE_int(U4s);
	FREE_int(perm1);
	FREE_int(perm2);
	FREE_int(perm3);
	FREE_int(perm4);
}

void ttp_codes::multiply_abcd(field_theory::finite_field &F,
	int a1, int b1, int c1, int d1,
	int a2, int b2, int c2, int d2,
	int &a3, int &b3, int &c3, int &d3)
{
	a3 = F.add(F.mult(a1, a2), F.mult(b1, c2));
	b3 = F.add(F.mult(a1, b2), F.mult(b1, d2));
	c3 = F.add(F.mult(c1, a2), F.mult(d1, c2));
	d3 = F.add(F.mult(c1, b2), F.mult(d1, d2));
}

int ttp_codes::choose_abcd_first(
		field_theory::finite_field &F,
		int Q, int &a, int &b, int &c, int &d)
{
	for (a = 0; a < Q; a++) {
		for (b = 0; b < Q; b++) {
			for (c = 0; c < Q; c++) {
				for (d = 0; d < Q; d++) {

					if (F.add(F.mult(a,d), F.negate(F.mult(b,c))) != 0) {
						return TRUE;
						}
					}
				}
			}
		}
	return FALSE;
}

int ttp_codes::choose_abcd_next(
		field_theory::finite_field &F,
		int Q, int &a, int &b, int &c, int &d)
{
	while (choose_abcd_next2(F, Q, a, b, c, d)) {
		if (F.add(F.mult(a,d), F.negate(F.mult(b,c))) != 0) {
			return TRUE;
			}
		}
	return FALSE;
}

int ttp_codes::choose_abcd_next2(
		field_theory::finite_field &F,
		int Q, int &a, int &b, int &c, int &d)
{
	int abcd[4], i;

	abcd[0] = a;
	abcd[1] = b;
	abcd[2] = c;
	abcd[3] = d;
	for (i = 3; i >= 0; i--) {
		if (abcd[i] < Q - 1) {
			abcd[i]++;
			a = abcd[0];
			b = abcd[1];
			c = abcd[2];
			d = abcd[3];
			return TRUE;
			}
		abcd[i] = 0;
		}
	return FALSE;
}

void ttp_codes::choose_abcd_at_random(
		field_theory::finite_field &F,
		int Q, int &a, int &b, int &c, int &d)
{
	orbiter_kernel_system::os_interface Os;

	while (TRUE) {
		a = Os.random_integer(Q);
		b = Os.random_integer(Q);
		c = Os.random_integer(Q);
		d = Os.random_integer(Q);

		if (F.add(F.mult(a,d), F.negate(F.mult(b,c))) != 0) {
			return;
			}
		}
	return;
}

int ttp_codes::compute_mindist(
		field_theory::finite_field &f,
		int m, int n,
		int *generator_matrix, int verbose_level)
{
	int d, k, i, j;
	int *AA;
	coding_theory::coding_theory_domain Code;

	k = m;
	AA = NEW_int(k * n);
	for (i = 0; i < k; i++) {
		for (j = 0; j < n; j++) {
			AA[i * n + j] = generator_matrix[i * n + j];
			}
		}
	d = Code.mindist(n, k, f.q, AA,
			verbose_level - 2, 0 /*idx_zero */, 1 /*idx_one*/,
			f.private_add_table(), f.private_mult_table());

	FREE_int(AA);
	return d;
}

int ttp_codes::abcd_term(
		field_theory::finite_field &f,
		int a, int b, int c, int d,
		int e1, int e2, int e3, int e4)
{
	int x = 1;
	int q;
	number_theory::number_theory_domain NT;

	q = NT.i_power_j(f.p, (f.e >> 1));

	if (e1 + e2 + e3 + e4 != 2 * q + 2) {
		cout << "degree error" << endl;
		cout << "q = " << q << endl;
		cout << "e1=" << e1 << endl;
		cout << "e2=" << e2 << endl;
		cout << "e3=" << e3 << endl;
		cout << "e4=" << e4 << endl;
		exit(1);
		}
	if (e1) {
		x = f.mult(x, f.power(a, e1));
		}
	if (e2) {
		x = f.mult(x, f.power(b, e2));
		}
	if (e3) {
		x = f.mult(x, f.power(c, e3));
		}
	if (e4) {
		x = f.mult(x, f.power(d, e4));
		}
	return x;
}



void ttp_codes::do_other_stuff(
		field_theory::finite_field *F,
		field_theory::finite_field *f,
		int beta, int beta_q,
	int *M, int *C, int *C_inv, int *H_subfield,
	int m, int n, int r,
	int f_elements_exponential,
	std::string &symbol_for_print,
	std::string &symbol_for_print_subfield,
	int f_construction_A, int f_hyperoval,
	int f_construction_B,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int Q = F->q;
	int q = f->q;
	int *H_subfield_gauss;
	int *H_subfield_t;
	int *G_subfield;
	int *G_subfield_bar;
	int *G_subfield_bar_t;
	int *G_subfield_t;
	int *MMM;
	//int *M2;
	//int *AAA;
	int *U;
	//int *U_subfield;
	//int *S;
	//int *Tmp;
	int *Aut;
	//int *Aut_subfield;
	int *base_cols;
	int *kernel_cols;
	int *perm;
	int *GH;
	combinatorics::combinatorics_domain Combi;

	algebra::rank_checker rc;
	int rk, i, j, nb_kernel_cols;


	MMM = NEW_int(m * n);
	//M2 = NEW_int(m * n);
	//AAA = NEW_int(m * m);
	U = NEW_int(m * m);
	//U_subfield = NEW_int(m * m);
	H_subfield_gauss = NEW_int(m * n);
	H_subfield_t = NEW_int(n * m);
	G_subfield = NEW_int((n - m) * n);
	G_subfield_bar = NEW_int((n - m) * n);
	G_subfield_bar_t = NEW_int((n - m) * n);
	G_subfield_t = NEW_int((n - m) * n);
	//S = NEW_int(n);
	//Tmp = NEW_int(m * m);
	Aut = NEW_int(m * m);
	//Aut_subfield = NEW_int(m * m);
	base_cols = NEW_int(n);
	kernel_cols = NEW_int(n);
	perm = NEW_int(n);
	GH = NEW_int(n * n);


	rc.init(f, m, n, r + 1);


	f->Linear_algebra->transpose_matrix(
			H_subfield, H_subfield_t, m, n);

	if (f_v) {
		cout << "H_subfield_t:" << endl;
		Int_vec_print_integer_matrix_width(
				cout, H_subfield_t, n, m, m, 2);
		}


	//rk = f.rank_and_basecols(H_subfield, m, base_cols, TRUE, FALSE);
		// only works for square matrices

	// copy the generator matrix, since otherwise the representation would not work any more.
	for (i = 0; i < m * n; i++) {
		H_subfield_gauss[i] = H_subfield[i];
		}

	rk = f->Linear_algebra->Gauss_int(
			H_subfield_gauss, FALSE /* f_special */,
			TRUE /* f_complete */, base_cols,
		FALSE /* f_P */, NULL, m /* m */, n /* n */, 0 /* Pn */,
		verbose_level - 2);

	if (f_v) {
		cout << "has rank " << rk << endl;

		cout << "base cols: " << endl;
		for (j = 0; j < rk; j++) {
			cout << base_cols[j] << " ";
			}
		cout << endl;

		cout << "H_subfield after Gaussian elimination:" << endl;
		Int_vec_print_integer_matrix_width(
				cout, H_subfield_gauss, m, n, n, 2);
		f->Io->latex_matrix(cout,
				f_elements_exponential,
				symbol_for_print_subfield, H_subfield_gauss, m, n);
		}


	int kernel_m, kernel_n, k;
	int *base_cols2;

	base_cols2 = NEW_int(n);
	f->Linear_algebra->matrix_get_kernel(
			H_subfield_gauss, m, n, base_cols, rk,
		kernel_m, kernel_n, G_subfield_t,
		verbose_level - 2);


	if (f_vv) {
		cout << "G_subfield_t:" << endl;
		Int_vec_print_integer_matrix_width(
				cout,
				G_subfield_t, kernel_m, kernel_n, kernel_n, 2);
		}

	f->Linear_algebra->transpose_matrix(
			G_subfield_t,
			G_subfield, kernel_m, kernel_n);
	k = kernel_n;

	if (f_vv) {
		cout << "G_subfield:" << endl;
		Int_vec_print_integer_matrix_width(cout,
				G_subfield, k, n, n, 2);
		}

	f->Linear_algebra->Gauss_int(
			G_subfield, FALSE /* f_special */,
			TRUE /* f_complete */, base_cols2,
		FALSE /* f_P */, NULL, k /* m */, n /* n */, 0 /* Pn */,
		verbose_level - 2);

	if (f_vv) {
		cout << "G_subfield after Gauss" << endl;
		Int_vec_print_integer_matrix_width(
				cout,
				G_subfield, k, n, n, 2);
		cout << "rk=" << rk << endl;
		}

	if (q == 4) {
		for (i = 0; i < k * n; i++) {
			G_subfield_bar[i] = f->bar(G_subfield[i]);
			}
		f->Linear_algebra->transpose_matrix(
				G_subfield_bar,
				G_subfield_bar_t, k, n);

		f->Linear_algebra->mult_matrix_matrix(
				G_subfield,
				G_subfield_bar_t, GH, k, n, m,
				0 /* verbose_level */);

		if (f_vv) {
			cout << "G\\bar{G}^\\top" << endl;
			Int_vec_print_integer_matrix_width(
					cout,
					GH, k, m, m, 2);
			}
		}



	f->Linear_algebra->kernel_columns(
			n, rk /*nb_base_cols*/,
			base_cols, kernel_cols);
	nb_kernel_cols = n - rk;

	if (f_vv) {
		cout << "kernel cols: " << endl;
		for (j = 0; j < nb_kernel_cols; j++) {
			cout << kernel_cols[j] << " ";
			}
		cout << endl;
		}


	int_submatrix_all_rows(
			H_subfield, m, n, nb_kernel_cols, kernel_cols, MMM);

	if (f_vv) {
		cout << "MMM:" << endl;
		Int_vec_print_integer_matrix_width(
				cout,
				MMM, m, nb_kernel_cols, nb_kernel_cols, 2);
		}

#if 0
	int dist;

	dist = compute_mindist(f, m, n, H_subfield, verbose_level);
	cout << "The dual code has minimum distance " << dist << endl;
	cout << "i.e., is a (" << n << ", " << m << ", " << dist << ")_" << q << " code" << endl;
#endif


#if 0
	cout << "checking the rank condition for the columns of the matrix" << endl;
	Int_vec_print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
	for (j = 0; j < n; j++) {
		//PG_element_rank_modified(F, M + j, n /* stride */, m, a);
		//S[j] = a;
		cout << "j=" << j << endl;
		//int_vec_print(cout, S, j + 1);
		//cout << endl;
		if (FALSE && j == 6) {
			f_v = TRUE;
			f_vv = TRUE;
			f_vvv = TRUE;
			}
		if (f_vv) {
			Int_vec_print_integer_matrix_width(cout, H_subfield, m, j + 1, n, 2);
			cout << endl;
			}
		if (!rc.check_rank_matrix_input(j + 1, H_subfield, n, f_vv, f_vvv, FALSE)) {
			cout << "j+1=" << j + 1 << ", does not have any " << r << " independent" << endl;
			exit(1);
			}
		}
	cout << "any " << r << " are independent" << endl;
#endif
	cout << "we got a " << m << " x " << n << " check matrix for an ";
	cout << "(" << n << ", " << n - m << ", " << r + 1 << ") code over F_" << q << endl;

	//exit(1);


	if (f_construction_A) {
		F->Io->display_T2(cout);
		F->Io->display_N2(cout);
		}
	else if (f_construction_B) {
		F->Io->display_T3(cout);
		F->Io->display_N3(cout);
		}



	for (i = 0; i < m * m; i++) {
		Aut[i] = 0;
		}

	linear_algebra::representation_theory_domain RF;

	RF.init(F, verbose_level);

	if (f_construction_A) {
		// changed to new base:
		Aut[0*m+0] = 1;
		Aut[1*m+1] = 1;
		Aut[2*m+2] = 1;
		Aut[3*m+4] = 1;
		Aut[4*m+3] = 1;
		Aut[5*m+6] = 1;
		Aut[6*m+5] = 1;
		Aut[7*m+8] = 1;
		Aut[8*m+7] = 1;
		cout << "Frobenius:" << endl;

		RF.representing_matrix9b(U, beta);
		}

	else if (f_construction_B) {
		Aut[0*m+0] = 1;
		Aut[1*m+1] = 1;
		Aut[3*m+2] = 1;
		Aut[4*m+3] = 1;
		Aut[2*m+4] = 1;
		Aut[6*m+5] = 1;
		Aut[7*m+6] = 1;
		Aut[5*m+7] = 1;
		F->Linear_algebra->transpose_matrix_in_place(Aut, m);
		cout << "Frobenius:" << endl;

		RF.representing_matrix8_V(U, beta);
		}

	if (f_v) {
		cout << "computing action on code" << endl;
		}
	action_on_code(
			*F, *f, m, n, M, H_subfield,
			C, C_inv, Aut, U, perm, verbose_level);


	if (f_v) {
		cout << "testing if cyclic" << endl;
		}

	int a, b, c, d;
#if 1

	if (f_construction_A) {
		if (q == 4 && !f_hyperoval) {
			test_cyclic(
					*F, *f, Aut, M, H_subfield,
					C, C_inv, U, q, Q, m, n, beta, 1);
			exit(1);
			}
		if (q == 8 && !f_hyperoval) {
			test_cyclic(
					*F, *f, Aut, M, H_subfield,
					C, C_inv, U, q, Q, m, n, beta, 1);
			exit(1);
			}
		if (q == 5) {
			test_cyclic(
					*F, *f, Aut, M, H_subfield,
					C, C_inv, U, q, Q, m, n, beta, 1);
			exit(1);
			}
		}
	else if (f_construction_B) {

#if 0
	if (q == 3) {
		int abcd[] = {
			0,1,1,0,
			1,1,0,1,
			1,3,0,1,
			1,9,0,1,
			1,0,0,3
			};
		for (i = 0; i < 5; i++) {
			a = abcd[i * 4 + 0];
			b = abcd[i * 4 + 1];
			c = abcd[i * 4 + 2];
			d = abcd[i * 4 + 3];
			cout << "a=" << a << " b=" << b << " c=" << c << " d=" << d << endl;

			setup_representing_matrix(F, q, Aut, a, b, c, d);
			F.representing_matrix8a(U, a, b, c, d, beta);
			action_on_code(
					F, f, m, n, M, H_subfield,
					C, C_inv, Aut, U, perm, TRUE, FALSE);
			}
		exit(1);
#endif
		}


	if (q == 4) {
		test_cyclic(
				*F, *f, Aut, M, H_subfield,
				C, C_inv, U, q, Q, m, n, beta, 1);
		exit(1);
		}

#endif

#if 1
	if (f_v) {
		cout << "testing the representation" << endl;
		}

	for (i = 0; i < 100; i++) {
		test_representation(*F, *f, Q, beta, m, n, H_subfield);
		}

	if (f_v) {
		cout << "representation tested 100 times" << endl;
		}
#endif

	choose_abcd_first(*F, Q, a, b, c, d);
	do {
		cout << "a=" << a << " b=" << b << " c=" << c << " d=" << d << " : ";

		if (f_construction_A) {
			RF.representing_matrix9_R(Aut, q, a, b, c, d);
			}
		else if (f_construction_B) {
			RF.representing_matrix8_R(Aut, q, a, b, c, d);
			}

		//Int_vec_print_integer_matrix_width(cout, Aut, m, m, m, 2);



		if (f_construction_A) {
			RF.representing_matrix9_U(U, a, b, c, d, beta);
			//cout << "U:" << endl;
			//Int_vec_print_integer_matrix_width(cout, U, m, m, m, 2);
			}
		else if (f_construction_B) {
			RF.representing_matrix8_U(U, a, b, c, d, beta);
			//cout << "U:" << endl;
			//Int_vec_print_integer_matrix_width(cout, U, m, m, m, 2);
			}

		//cout << "action on code: " << endl;
		action_on_code(
				*F, *f, m, n, M, H_subfield,
				C, C_inv, Aut, U, perm, verbose_level);

		if (Combi.perm_order(perm, n) == n) {
			cout << "cyclic" << endl;
			}
#if 0
		if (perm_order(perm, n) == n) {
			is_cyclic(F, f,
				Aut, M, H_subfield, C, C_inv, U,
				q, Q, m, n, beta, a, b, c, d);
			exit(1);
			}
#endif


		} while (choose_abcd_next(*F, Q, a, b, c, d));
}


void ttp_codes::int_submatrix_all_rows(
		int *A, int m, int n,
	int nb_cols, int *cols, int *B)
{
	int i, j;

	for (i = 0; i < m; i++) {
		for (j = 0; j < nb_cols; j++) {
			B[i * nb_cols + j] = A[i * n + cols[j]];
		}
	}
}



}}}

