/*
 * blt_set_with_action.cpp
 *
 *  Created on: Apr 7, 2019
 *      Author: betten
 */




#include "orbiter.h"

using namespace std;

namespace orbiter {
namespace layer5_applications {
namespace orthogonal_geometry_applications {


blt_set_with_action::blt_set_with_action()
{
	A = NULL;
	Blt_set_domain = NULL;

	set = NULL;

	Aut_gens = NULL;
	Inv = NULL;
	A_on_points = NULL;
	Orbits_on_points = NULL;

	T = NULL;
	Pi_ij = NULL;
}

blt_set_with_action::~blt_set_with_action()
{
	if (Inv) {
		FREE_OBJECT(Inv);
	}
	if (A_on_points) {
		FREE_OBJECT(A_on_points);
	}
	if (Orbits_on_points) {
		FREE_OBJECT(Orbits_on_points);
	}
	if (T) {
		FREE_lint(T);
	}
	if (Pi_ij) {
		FREE_lint(Pi_ij);
	}
}

void blt_set_with_action::init_set(
		actions::action *A,
		orthogonal_geometry::blt_set_domain *Blt_set_domain,
		long int *set,
		groups::strong_generators *Aut_gens, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "blt_set_with_action::init_set" << endl;
	}
	blt_set_with_action::A = A;
	blt_set_with_action::Blt_set_domain = Blt_set_domain;
	blt_set_with_action::set = set;
	blt_set_with_action::Aut_gens = Aut_gens;

	Inv = NEW_OBJECT(orthogonal_geometry::blt_set_invariants);
	if (f_v) {
		cout << "blt_set_with_action::init_set "
				"before Inv->init" << endl;
	}
	Inv->init(Blt_set_domain, set, verbose_level - 1);
	if (f_v) {
		cout << "blt_set_with_action::init_set "
				"after Inv->init" << endl;
	}

	if (Aut_gens) {
		if (f_v) {
			cout << "blt_set_with_action::init_set "
					"before init_orbits_on_points" << endl;
		}
		init_orbits_on_points(verbose_level - 1);
		if (f_v) {
			cout << "blt_set_with_action::init_set "
					"after init_orbits_on_points" << endl;
		}
	}

	if (f_v) {
		cout << "blt_set_with_action::init_set before compute_T" << endl;
	}
	compute_T(verbose_level - 1);
	if (f_v) {
		cout << "blt_set_with_action::init_set after compute_T" << endl;
	}

	if (f_v) {
		cout << "blt_set_with_action::init_set before compute_Pi_ij" << endl;
	}
	compute_Pi_ij(verbose_level - 1);
	if (f_v) {
		cout << "blt_set_with_action::init_set after compute_Pi_ij" << endl;
	}

	if (f_v) {
		cout << "blt_set_with_action::init_set done" << endl;
	}
}


void blt_set_with_action::init_orbits_on_points(
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "blt_set_with_action::init_orbits_on_points" << endl;
	}

	if (f_v) {
		cout << "blt_set_with_action action "
				"on points:" << endl;
	}
	A_on_points = A->Induced_action->restricted_action(
			Inv->the_set_in_orthogonal,
			Blt_set_domain->target_size,
			0 /*verbose_level*/);
	if (f_v) {
		cout << "blt_set_with_action action "
				"on points done" << endl;
	}



	if (f_v) {
		cout << "blt_set_with_action::init_orbits_on_points "
				"computing orbits on points:" << endl;
	}
	Orbits_on_points = Aut_gens->orbits_on_points_schreier(
			A_on_points, 0 /*verbose_level*/);
	if (f_v) {
		cout << "We found " << Orbits_on_points->nb_orbits
				<< " orbits on points" << endl;
	}

	if (f_v) {
		cout << "blt_set_with_action::init_orbits_on_points "
				"Orbits on points:" << endl;
		Orbits_on_points->print_and_list_orbits(cout);
	}


	if (f_v) {
		cout << "blt_set_with_action::init_orbits_on_points done" << endl;
	}
}




void blt_set_with_action::print_automorphism_group(
	std::ostream &ost)
{
	if (Aut_gens) {
		ring_theory::longinteger_object go;

		Aut_gens->group_order(go);

		ost << "The automorphism group has order " << go << ".\\\\" << endl;
		ost << "\\bigskip" << endl;
		ost << "Orbits of the automorphism group on points "
				"of the BLT-set:\\\\" << endl;
		Orbits_on_points->print_and_list_orbits_sorted_by_length_tex(ost);
	}
	else {
		ost << "The automorphism group is not available.\\\\" << endl;

	}
}

void blt_set_with_action::report(std::ostream &ost, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "blt_set_with_action::report" << endl;
	}

	if (Aut_gens) {

		print_summary(ost);


		ost << "The stabilizer is generated by:\\\\" << endl;
		Aut_gens->print_generators_tex(ost);

		{
			string str;
			Orbits_on_points->print_orbit_length_distribution_to_string(str);
			ost << "Orbits on points: $" << str << "$\\\\" << endl;
		}

	}

	ost << "\\bigskip" << endl;
	ost << "BLT-set and tangent hyperplanes $T$:\\\\" << endl;
	ost << "\\bigskip" << endl;


	Blt_set_domain->report_given_point_set(ost,
			set, Blt_set_domain->q + 1, verbose_level);

	ost << "\\bigskip" << endl;


	ost << "Tangent hyperplanes:\\\\" << endl;

	Blt_set_domain->G54->print_set_tex(
			ost, T, Blt_set_domain->target_size, verbose_level);

	ost << "\\bigskip" << endl;


	orbiter_kernel_system::latex_interface Li;

	ost << "$\\Pi_{ij}$ matrix:" << endl;
	ost << "$$" << endl;
	ost << "\\left[" << endl;

	Li.print_lint_matrix_tex(ost,
			Pi_ij,
			Blt_set_domain->target_size,
			Blt_set_domain->target_size);

	ost << "\\right]" << endl;
	ost << "$$" << endl;

	ost << "\\bigskip" << endl;

	ost << "First row of $\\Pi_{ij}$ (with the diagonal entry removed):\\\\" << endl;

	Blt_set_domain->G53->print_set_tex(ost,
			Pi_ij + 1, Blt_set_domain->q,
			verbose_level);

	ost << "\\bigskip" << endl;


	Inv->latex(ost, verbose_level);


	ost << "\\bigskip" << endl;
	ost << "Orthogonal space:\\\\" << endl;
	ost << "\\bigskip" << endl;

	Blt_set_domain->O->report(ost, verbose_level);


	if (f_v) {
		cout << "blt_set_with_action::report done" << endl;
	}
}

void blt_set_with_action::print_summary(std::ostream &ost)
{
	ost << "\\subsection*{Summary}" << endl;


	ost << "{\\renewcommand{\\arraystretch}{1.5}" << endl;
	ost << "$$" << endl;
	ost << "\\begin{array}{|l|r|r|}" << endl;
	ost << "\\hline" << endl;
	ost << "\\mbox{Object} & \\mbox{Number}  & \\mbox{Orbit type} \\\\";
	ost << "\\hline" << endl;
	ost << "\\hline" << endl;
	ost << "\\mbox{Points} & " << Blt_set_domain->target_size << " & ";
	{
		string str;
		Orbits_on_points->print_orbit_length_distribution_to_string(str);
		ost << str;
	}
	ost << "\\\\" << endl;
	ost << "\\hline" << endl;

	ost << "\\end{array}" << endl;
	ost << "$$}" << endl;
}

void blt_set_with_action::compute_T(int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "blt_set_with_action::compute_T" << endl;
	}
	int i;
	//int i, j;
	//long int plane_rk1, plane_rk2, a;

	T = NEW_lint(Blt_set_domain->target_size);
	for (i = 0; i < Blt_set_domain->target_size; i++) {
		T[i] = Blt_set_domain->compute_tangent_hyperplane(
				set[i],
				0 /* verbose_level */);
	}

	if (f_v) {
		cout << "blt_set_with_action::compute_T done" << endl;
	}
}


void blt_set_with_action::compute_Pi_ij(int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "blt_set_with_action::compute_Pi_ij" << endl;
	}
	int i, j;
	long int plane_rk1, plane_rk2, a;

	Pi_ij = NEW_lint(Blt_set_domain->target_size * Blt_set_domain->target_size);

	Lint_vec_zero(Pi_ij, Blt_set_domain->target_size * Blt_set_domain->target_size);

	for (i = 0; i < Blt_set_domain->target_size; i++) {
		plane_rk1 = T[i];
		for (j = 0; j < Blt_set_domain->target_size; j++) {
			if (i == j) {
				continue;
			}
			plane_rk2 = T[j];
			a = Blt_set_domain->intersection_of_hyperplanes(
					plane_rk1, plane_rk2,
					0 /* verbose_level */);
			Pi_ij[i * Blt_set_domain->target_size + j] = a;
		}
	}

	if (f_v) {
		cout << "blt_set_with_action::compute_Pi_ij done" << endl;
	}
}



}}}

