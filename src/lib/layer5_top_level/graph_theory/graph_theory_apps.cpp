/*
 * graph_theory_apps.cpp
 *
 *  Created on: Jan 10, 2023
 *      Author: betten
 */



#include "orbiter.h"

using namespace std;

namespace orbiter {
namespace layer5_applications {
namespace apps_graph_theory {


graph_theory_apps::graph_theory_apps()
{

}

graph_theory_apps::~graph_theory_apps()
{

}


void graph_theory_apps::automorphism_group(
		graph_theory::colored_graph *CG, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "graph_theory_apps::automorphism_group" << endl;
	}

	orbiter_kernel_system::file_io Fio;
	string fname;

	fname.assign(CG->label);
	fname.append(".colored_graph");


	actions::nauty_interface_with_group Nauty;
	actions::action *Aut;

	if (f_v) {
		cout << "graph_theory_apps::automorphism_group "
				"before Nauty.create_automorphism_group_of_colored_graph_object" << endl;
	}
	Aut = Nauty.create_automorphism_group_of_colored_graph_object(CG, verbose_level);
	if (f_v) {
		cout << "graph_theory_apps::automorphism_group "
				"after Nauty.create_automorphism_group_of_colored_graph_object" << endl;
	}

	string fname_report;

	fname_report.assign(CG->label);
	fname_report.append("_report.tex");


	{
		string title, author, extra_praeamble;
		char str[1000];

		snprintf(str, 1000, "Automorphism group of %s", CG->label_tex.c_str());
		title.assign(str);


		{
			ofstream ost(fname_report);
			orbiter_kernel_system::latex_interface L;

			L.head(ost,
					FALSE /* f_book*/,
					TRUE /* f_title */,
					title, author,
					FALSE /* f_toc */,
					FALSE /* f_landscape */,
					TRUE /* f_12pt */,
					TRUE /* f_enlarged_page */,
					TRUE /* f_pagenumbers */,
					extra_praeamble /* extra_praeamble */);


			ring_theory::longinteger_object go;

			Aut->Strong_gens->group_order(go);

			ost << "\\noindent The automorphism group of $" << CG->label_tex << "$ "
					"has order " << go << " and is generated by:\\\\" << endl;
			Aut->Strong_gens->print_generators_tex(ost);


			if (f_v) {
				cout << "graph_theory_apps::automorphism_group after report" << endl;
			}


			L.foot(ost);

		}
		orbiter_kernel_system::file_io Fio;

		cout << "written file " << fname_report << " of size "
				<< Fio.file_size(fname_report) << endl;
	}

	string fname_group;

	fname_group.assign(CG->label);
	fname_group.append("_group.makefile");

	if (f_v) {
		cout << "graph_theory_apps::automorphism_group "
				"before Aut->export_to_orbiter_as_bsgs "
				"label = " << CG->label << endl;
	}
	Aut->degree--;
	if (f_v) {
		cout << "graph_theory_apps::automorphism_group "
				"before Aut->export_to_orbiter_as_bsgs "
				"degree = " << Aut->degree << endl;
	}
	Aut->export_to_orbiter_as_bsgs(fname_group,
			CG->label, CG->label_tex, Aut->Strong_gens,
			verbose_level);
	if (f_v) {
		cout << "graph_theory_apps::automorphism_group "
				"after Aut->export_to_orbiter_as_bsgs" << endl;
	}
	//file_io Fio;

	cout << "written file " << fname_group << " of size "
			<< Fio.file_size(fname_group) << endl;

	if (f_v) {
		cout << "graph_theory_apps::automorphism_group done" << endl;
	}

}

void graph_theory_apps::expander_graph(
		int p, int q,
		int f_special,
		field_theory::finite_field *F,
		actions::action *A,
		int *&Adj, int &N,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);

	if (f_v) {
		cout << "graph_theory_apps::expander_graph" << endl;
	}

	groups::sims *Sims;

	Sims = A->Sims;


	//longinteger_object go;
	long int goi;

	goi = Sims->group_order_lint();

	if (f_v) {
		cout << "graph_theory_apps::expander_graph "
				"found a group of order " << goi << endl;
	}



	int i, j;
	int a0, a1, a2, a3;
	int sqrt_p;

	int *sqrt_mod_q;
	int I;
	int *A4;
	int nb_A4 = 0;

	A4 = NEW_int((p + 1) * 4);
	sqrt_mod_q = NEW_int(q);
	for (i = 0; i < q; i++) {
		sqrt_mod_q[i] = -1;
	}
	for (i = 0; i < q; i++) {
		j = F->mult(i, i);
		sqrt_mod_q[j] = i;
	}
	if (f_v) {
		cout << "graph_theory_apps::expander_graph sqrt_mod_q:" << endl;
		Int_vec_print(cout, sqrt_mod_q, q);
		cout << endl;
	}

	sqrt_p = 0;
	for (i = 1; i < p; i++) {
		if (i * i > p) {
			sqrt_p = i - 1;
			break;
		}
	}
	if (f_v) {
		cout << "graph_theory_apps::expander_graph p=" << p << endl;
		cout << "graph_theory_apps::expander_graph sqrt_p = " << sqrt_p << endl;
	}


	for (I = 0; I < q; I++) {
		if (F->add(F->mult(I, I), 1) == 0) {
			break;
		}
	}
	if (I == q) {
		cout << "graph_theory_apps::expander_graph did not find I" << endl;
		exit(1);
	}
	if (f_v) {
		cout << "graph_theory_apps::expander_graph I=" << I << endl;
	}

	for (a0 = 1; a0 <= sqrt_p; a0++) {
		if (EVEN(a0)) {
			continue;
		}
		for (a1 = -sqrt_p; a1 <= sqrt_p; a1++) {
			if (ODD(a1)) {
				continue;
			}
			for (a2 = -sqrt_p; a2 <= sqrt_p; a2++) {
				if (ODD(a2)) {
					continue;
				}
				for (a3 = -sqrt_p; a3 <= sqrt_p; a3++) {
					if (ODD(a3)) {
						continue;
					}
					if (a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3 == p) {
						if (f_v) {
							cout << "graph_theory_apps::expander_graph solution " << nb_A4 << " : " << a0
									<< ", " << a1 << ", " << a2 << ", "
									<< a3 << ", " << endl;
						}
						if (nb_A4 == p + 1) {
							cout << "graph_theory_apps::expander_graph too many solutions" << endl;
							exit(1);
						}
						A4[nb_A4 * 4 + 0] = a0;
						A4[nb_A4 * 4 + 1] = a1;
						A4[nb_A4 * 4 + 2] = a2;
						A4[nb_A4 * 4 + 3] = a3;
						nb_A4++;
					}
				}
			}
		}
	}

	if (f_v) {
		cout << "graph_theory_apps::expander_graph nb_A4=" << nb_A4 << endl;
	}
	if (nb_A4 != p + 1) {
		cout << "graph_theory_apps::expander_graph nb_A4 != p + 1" << endl;
		exit(1);
	}

	if (f_v) {
		Int_matrix_print(A4, nb_A4, 4);
	}

	data_structures_groups::vector_ge *gens;
	int *Elt1;
	int *Elt2;
	int *Elt3;
	int M4[4];
	int det; //, s, sv;

	Elt1 = NEW_int(A->elt_size_in_int);
	Elt2 = NEW_int(A->elt_size_in_int);
	Elt3 = NEW_int(A->elt_size_in_int);

	gens = NEW_OBJECT(data_structures_groups::vector_ge);
	gens->init(A, verbose_level - 2);
	gens->allocate(nb_A4, verbose_level - 2);

	if (f_v) {
		cout << "graph_theory_apps::expander_graph making connection set:" << endl;
	}
	for (i = 0; i < nb_A4; i++) {

		if (f_vv) {
			cout << "graph_theory_apps::expander_graph "
					"making generator " << i << ":" << endl;
		}
		a0 = A4[i * 4 + 0];
		a1 = A4[i * 4 + 1];
		a2 = A4[i * 4 + 2];
		a3 = A4[i * 4 + 3];
		while (a0 < 0) {
			a0 += q;
		}
		while (a1 < 0) {
			a1 += q;
		}
		while (a2 < 0) {
			a2 += q;
		}
		while (a3 < 0) {
			a3 += q;
		}
		a0 = a0 % q;
		a1 = a1 % q;
		a2 = a2 % q;
		a3 = a3 % q;
		if (f_vv) {
			cout << "graph_theory_apps::expander_graph "
					"making generator " << i << ": a0=" << a0
					<< " a1=" << a1 << " a2=" << a2
					<< " a3=" << a3 << endl;
		}
		M4[0] = F->add(a0, F->mult(I, a1));
		M4[1] = F->add(a2, F->mult(I, a3));
		M4[2] = F->add(F->negate(a2), F->mult(I, a3));
		M4[3] = F->add(a0, F->negate(F->mult(I, a1)));

		if (f_vv) {
			cout << "M4=";
			Int_vec_print(cout, M4, 4);
			cout << endl;
		}

		if (f_special) {
			det = F->add(F->mult(M4[0], M4[3]),
					F->negate(F->mult(M4[1], M4[2])));

			if (f_vv) {
				cout << "det=" << det << endl;
			}

#if 0
			s = sqrt_mod_q[det];
			if (s == -1) {
				cout << "graph_theory_apps::expander_graph determinant is not a square" << endl;
				exit(1);
			}
			sv = F->inverse(s);
			if (f_vv) {
				cout << "graph_theory_apps::expander_graph det=" << det << " sqrt=" << s
						<< " mutiplying by " << sv << endl;
			}
			for (j = 0; j < 4; j++) {
				M4[j] = F->mult(sv, M4[j]);
			}
			if (f_vv) {
				cout << "graph_theory_apps::expander_graph M4=";
				int_vec_print(cout, M4, 4);
				cout << endl;
			}
#endif
		}

		A->make_element(Elt1, M4, verbose_level - 1);

		if (f_v) {
			cout << "graph_theory_apps::expander_graph s_" << i << "=" << endl;
			A->element_print_quick(Elt1, cout);
		}

		A->element_move(Elt1, gens->ith(i), 0);
	}

	if (f_v) {
		cout << "graph_theory_apps::expander_graph "
				"before Sims->Cayley_graph" << endl;
	}
	Sims->Cayley_graph(Adj, N, gens, verbose_level);
	if (f_v) {
		cout << "graph_theory_apps::expander_graph "
				"after Sims->Cayley_graph" << endl;
	}


	if (f_v) {
		cout << "graph_theory_apps::expander_graph "
				"The adjacency matrix of a graph with " << goi
				<< " vertices has been computed" << endl;
		//int_matrix_print(Adj, goi, goi);
	}

	int k;
	k = 0;
	for (i = 0; i < N; i++) {
		if (Adj[0 * N + i]) {
			k++;
		}
	}
	if (f_v) {
		cout << "graph_theory_apps::expander_graph "
				"the graph is regular of degree " << k << endl;
	}


	//N = goi;


	FREE_OBJECT(gens);
	//FREE_OBJECT(A);
	FREE_int(A4);
	FREE_int(Elt1);
	FREE_int(Elt2);
	FREE_int(Elt3);
	//FREE_OBJECT(F);

	if (f_v) {
		cout << "graph_theory_apps::expander_graph done" << endl;
	}
}

}}}

