/*
 * combinatorics_global.cpp
 *
 *  Created on: May 25, 2021
 *      Author: betten
 */



#include "orbiter.h"

using namespace std;

namespace orbiter {
namespace layer5_applications {
namespace apps_combinatorics {


combinatorics_global::combinatorics_global()
{

}

combinatorics_global::~combinatorics_global()
{

}

void combinatorics_global::create_design_table(design_create *DC,
		std::string &problem_label,
		design_tables *&T,
		groups::strong_generators *Gens,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "combinatorics_global::create_design_table" << endl;
	}
	orbiter_kernel_system::latex_interface L;

	if (f_v) {
		cout << "combinatorics_global::create_design_table design:" << endl;
		cout << "$$" << endl;
		L.lint_set_print_tex(cout, DC->set, DC->sz);
		cout << endl;
		cout << "$$" << endl;

		if (DC->f_has_group) {
			cout << "The stabilizer is generated by:" << endl;
			DC->Sg->print_generators_tex(cout);
		}
	}




	T = NEW_OBJECT(design_tables);

	if (f_v) {
		cout << "combinatorics_global::create_design_table before T->init" << endl;
	}
	T->init(DC->A, DC->A2,
			DC->set, DC->sz,
			problem_label,
			Gens, verbose_level);
	if (f_v) {
		cout << "combinatorics_global::create_design_table after T->init" << endl;
	}



	if (f_v) {
		cout << "combinatorics_global::create_design_table done" << endl;
	}
}



void combinatorics_global::load_design_table(design_create *DC,
		std::string &problem_label,
		design_tables *&T,
		groups::strong_generators *Gens,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "combinatorics_global::load_design_table" << endl;
	}
	orbiter_kernel_system::latex_interface L;
	//actions::action *A;
	//int *Elt1;
	//int *Elt2;

	//A = DC->A;

	//Elt2 = NEW_int(A->elt_size_in_int);



	if (f_v) {
		cout << "combinatorics_global::load_design_table design:" << endl;
		cout << "$$" << endl;
		L.lint_set_print_tex(cout, DC->set, DC->sz);
		cout << endl;
		cout << "$$" << endl;

		if (DC->f_has_group) {
			cout << "The stabilizer is generated by:" << endl;
			DC->Sg->print_generators_tex(cout);
		}
	}




	T = NEW_OBJECT(design_tables);

	if (f_v) {
		cout << "combinatorics_global::load_design_table before T->init_from_file" << endl;
	}
	T->init_from_file(DC->A, DC->A2,
			DC->set, DC->sz,
			problem_label,
			Gens, verbose_level);
	if (f_v) {
		cout << "combinatorics_global::load_design_table after T->init_from_file" << endl;
	}

	if (f_v) {
		cout << "combinatorics_global::load_design_table done" << endl;
	}

}



#if 0
		std::string &input_prefix,
		std::string &design_tables_prefix,
		std::string &group_label,
		std::string &group_order,
		std::string &generators_data,
#endif

#if 0
	orbit_of_sets *SetOrb;

	SetOrb = NEW_OBJECT(orbit_of_sets);

	cout << "computing orbit:" << endl;
	SetOrb->init(DC->A, DC->A2,
			DC->set, DC->sz, DC->A->Strong_gens->gens,
			verbose_level);
	cout << "computing orbit done" << endl;


	large_set_classify *LS;

	LS = NEW_OBJECT(large_set_classify);

	int f_lexorder_test = TRUE;
	char str[1000];
	string base_fname;


	sprintf(str, "LS_%s", DC->prefix);
	base_fname.assign(str);

	LS->init(DC,
			input_prefix, base_fname,
			0 /*search_depth*/,
			f_lexorder_test,
			design_tables_prefix,
			verbose_level);




	LS->init_designs(SetOrb, verbose_level);


#if 0
	if (f_read_classification) {
		cout << "reading classification at level "
				<< read_classification_level << endl;

		orbit_transversal *T;

		LS->read_classification(T,
				read_classification_level, verbose_level);

		cout << "computing and reporting ago distribution:" << endl;

		T->report_ago_distribution(cout);

		FREE_OBJECT(T);
	}
	else if (f_lift_this) {
		cout << "lifting a given set" << endl;
		int *lift_starter;
		int lift_starter_sz;


		int_vec_scan(lift_this_set, lift_starter, lift_starter_sz);
		cout << "lift_starter = ";
		int_vec_print(cout, lift_starter, lift_starter_sz);
		cout << endl;


	}
#endif
	//else if (f_lift_this_with_group) {
		cout << "lifting a given set with a given group" << endl;


#if 0
		long int *lift_starter;
		int lift_starter_sz;


		lint_vec_scan(lift_this_with_group_set, lift_starter, lift_starter_sz);

		cout << "lift_starter = ";
		lint_vec_print(cout, lift_starter, lift_starter_sz);
		cout << endl;
#endif


		int *gens_data;
		int gens_data_sz;
		int nb_elements;

		Int_vec_scan(generators_data, gens_data, gens_data_sz);
		cout << "gens_data = ";
		Int_vec_print(cout, gens_data, gens_data_sz);
		cout << endl;


		nb_elements = gens_data_sz / A->make_element_size;

		strong_generators *SG;
		vector_ge *nice_gens;
		int orbit_length;

		SG = NEW_OBJECT(strong_generators);

		cout << "before SG->init_from_data_with_target_go_ascii" << endl;
		SG->init_from_data_with_target_go_ascii(A,
				gens_data,
				nb_elements, A->make_element_size,
				group_order.c_str(),
				nice_gens,
				verbose_level);

		// computing the normalizer:
		strong_generators *gens_N;
		{
			sims *G;
			sims *H;
			char str[1000];
			string fname_magma_prefix;

			sprintf(str, "%s_normalizer", A->label);
			fname_magma_prefix.assign(str);

			if (!A->f_has_sims) {
				cout << "A does not have sims" << endl;
				exit(1);
			}
			G = A->Sims;
			H = SG->create_sims(verbose_level - 2);
			A->normalizer_using_MAGMA(fname_magma_prefix,
					G, H, gens_N, verbose_level);
			cout << "generators for the normalizer are:" << endl;
			gens_N->print_generators_tex(cout);
			FREE_OBJECT(H);
		}

		orbit_length = SG->group_order_as_lint();

		cout << "The group is generated by the following strong generating set:" << endl;
		SG->print_elements_latex_ost(cout);

		long int *Large_sets;
		int nb_large_sets;

		long int *lift_starter = NULL;
		string solution_file_name;
		solution_file_name.assign("");

		LS->process_starter_case(lift_starter, 0 /*lift_starter_sz*/,
				SG, group_label,
				group_label, orbit_length,
				FALSE /*f_read_solution_file*/, solution_file_name,
				Large_sets, nb_large_sets,
				TRUE /* f_compute_normalizer_orbits */, gens_N,
				verbose_level);
		cout << "processing starter case done" << endl;

		FREE_OBJECT(SG);
		FREE_OBJECT(nice_gens);

		cout << "lifting a given set with a given group done" << endl;
	//}
#if 0
	else if (f_lift_case) {
		cout << "lifting a single case" << endl;

		set_and_stabilizer *Rep;

		LS->read_classification_single_case(Rep,
				lift_case_level, lift_case, verbose_level);

		cout << "the set in case " << lift_case << " is:" << endl;
		Rep->print_set_tex(cout);
		cout << endl;

		cout << "The designs are:" << endl;
		for (i = 0; i < Rep->sz; i++) {
			int a;

			a = Rep->data[i];
			cout << i << " & " << a << " & ";
			lint_vec_print(cout, LS->Design_table + a * LS->design_size, LS->design_size);
			cout << endl;
		}

		cout << "The blocks of the designs are:" << endl;
		int *block;

		block = NEW_int(LS->DC->k);

		for (i = 0; i < Rep->sz; i++) {
			int a, b, j;

			a = Rep->data[i];
			cout << "design " << i << " is " << a << " has the following blocks:" << endl;
			for (j = 0; j < LS->design_size; j++) {
				b = LS->Design_table[a * LS->design_size + j];
				LS->DC->unrank_block_in_PG_2_q(block,
						b, 0 /*verbose_level*/);
				cout << "block " << j << " is " << b << " : ";
				int_vec_print(cout, block, LS->DC->k);
				cout << endl;
			}
		}

		FREE_int(block);


		cout << "strong generators are:" << endl;
		Rep->Strong_gens->print_generators_tex();

		cout << "The elements are:" << endl;
		Rep->Strong_gens->print_elements_ost(cout);

		sylow_structure *Syl;
		sims *S;

		cout << "creating Sims:" << endl;
		S = Rep->Strong_gens->create_sims(0 /* verbose_level */);
		Syl = NEW_OBJECT(sylow_structure);

		cout << "creating Sylow structure:" << endl;
		Syl->init(S, 0 /*verbose_level*/);
		Syl->report(cout);

#if 0
		cout << "processing starter case with full stabilizer:" << endl;
		LS->process_starter_case(Rep, Rep->Strong_gens, verbose_level);
		cout << "processing starter case done" << endl;
#else
		int sylow_select;

		for (sylow_select = 0; sylow_select < Syl->nb_primes; sylow_select++) {

			if (f_sylow_select) {
				if (Syl->primes[sylow_select] != sylow_select_prime) {
					cout << "skipping this prime because of -sylow_select" << endl;
					continue;
				}
			}
			cout << "processing starter case with Sylow subgroup "
					<< sylow_select << " / " << Syl->nb_primes << " of stabilizer, "
					"for p=" << Syl->primes[sylow_select] << endl;
			char prefix[1000];
			char group_label[1000];
			int orbit_length;

			orbit_length = Syl->primes[sylow_select];
			sprintf(prefix, "Case_%d_", lift_case);
			sprintf(group_label, "Syl_%d", Syl->primes[sylow_select]);

			long int *Large_sets;
			int nb_large_sets;

			strong_generators *SG1;

			if (f_cyclic_subgroup_with_n_fixpoints) {
				cout << "finding cyclic subgroup with n fixpoints, for n = "
						<< cyclic_subgroup_with_n_fixpoints << endl;
				SG1 = Syl->Sub[sylow_select].SG->find_cyclic_subgroup_with_exactly_n_fixpoints(
						cyclic_subgroup_with_n_fixpoints, A, verbose_level);
			}
			else {
				SG1 = Syl->Sub[sylow_select].SG;
			}
			cout << "considering the group generated by:" << endl;
			SG1->print_generators_tex();
			LS->process_starter_case(Rep->data, Rep->sz, SG1,
					prefix, group_label, orbit_length,
					f_read_solution_file, solution_file_name,
					Large_sets, nb_large_sets,
					FALSE /* f_compute_normalizer_orbits */, NULL /* gens_N */,
					verbose_level);
			cout << "processing starter case done" << endl;
			if (f_read_solution_file) {
				cout << "We found " << nb_large_sets << " large sets" << endl;
				lint_matrix_print(Large_sets, nb_large_sets, LS->size_of_large_set);
			}
		}
#endif
	}
	else {
		if (f_depth) {
			cout << "classification of subsets of size " << depth << endl;
			LS->gen->depth = depth;

			LS->compute(verbose_level);
		}
	}
#endif

	FREE_int(Elt2);


	if (f_v) {
		cout << "combinatorics_global::lift_design done" << endl;
	}

}
#endif




void combinatorics_global::Hill_cap56(
	char *fname, int &nb_Pts, long int *&Pts,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int epsilon, n, q, w, i;
	apps_geometry::polar *P;
	actions::action *A;
	actions::action *An;
	field_theory::finite_field *F;
	number_theory::number_theory_domain NT;
	geometry::geometry_global Gg;
	orbiter_kernel_system::os_interface Os;

	if (f_v) {
		cout << "combinatorics_global::Hill_cap" << endl;
		}
	epsilon = -1;
	n = 6;
	q = 3;
	w = Gg.Witt_index(epsilon, n - 1);

	P = NEW_OBJECT(apps_geometry::polar);
	A = NEW_OBJECT(actions::action);
	An = NEW_OBJECT(actions::action);
	F = NEW_OBJECT(field_theory::finite_field);

	F->finite_field_init(q, FALSE /* f_without_tables */, 0);
	if (f_v) {
		cout << "Hill_cap before init_orthogonal" << endl;
		}

	int f_semilinear;

	if (NT.is_prime(F->q)) {
		f_semilinear = FALSE;
		}
	else {
		f_semilinear = TRUE;
		}

	if (f_v) {
		cout << "f_semilinear=" << f_semilinear << endl;
		}

	A->init_orthogonal_group(epsilon,
		n, F,
		TRUE /* f_on_points */, FALSE /* f_on_lines */,
		FALSE /* f_on_points_and_lines */,
		f_semilinear, TRUE /* f_basis */,
		0/*verbose_level*/);




	if (f_v) {
		cout << "Hill_cap created action:" << endl;
		A->print_info();
		}


	induced_actions::action_on_orthogonal *AO = A->G.AO;
	orthogonal_geometry::orthogonal *O;

	O = AO->O;

	if (f_v) {
		cout << "after init_orthogonal" << endl;
		}
	data_structures_groups::vector_ge *nice_gens;

	An->init_projective_group(n, F, TRUE /* f_semilinear */,
		TRUE /* f_basis */, TRUE /* f_init_sims */,
		nice_gens,
		verbose_level - 2);

	FREE_OBJECT(nice_gens);

	if (f_v) {
		cout << "after init_projective_group" << endl;
		}

	if (f_v) {
		cout << "Hill_cap before P.init" << endl;
		}
	P->init(A, O, epsilon, n, w, F, w, verbose_level - 2);
	if (f_v) {
		cout << "Hill_cap before P.init2" << endl;
		}
	P->init2(w, verbose_level - 2);
	if (f_v) {
		cout << "Hill_cap before P.compute_orbits" << endl;
		}
	int t0 = Os.os_ticks();
	P->compute_orbits(t0, verbose_level - 2);

	if (f_v) {
		cout << "we found " << P->nb_orbits
				<< " orbits at depth " << w << endl;
		}

	//P.compute_cosets(w, 0, verbose_level);

#if 1

	ring_theory::longinteger_object *Rank_lines;
	int nb_lines;

	if (f_v) {
		cout << "Hill_cap before P.dual_polar_graph" << endl;
		}
	P->dual_polar_graph(w, 0, Rank_lines, nb_lines, verbose_level - 2);


	cout << "there are " << nb_lines << " lines" << endl;
	for (i = 0; i < nb_lines; i++) {
		cout << setw(5) << i << " : " << Rank_lines[i] << endl;
		}
	geometry::grassmann Grass;

	if (f_v) {
		cout << "Hill_cap before Grass.init" << endl;
		}
	Grass.init(n, w, F, 0 /*verbose_level*/);

	cout << "there are " << nb_lines
			<< " lines, generator matrices are:" << endl;
	for (i = 0; i < nb_lines; i++) {
		Grass.unrank_longinteger(Rank_lines[i], 0/*verbose_level - 3*/);
		cout << setw(5) << i << " : " << Rank_lines[i] << ":" << endl;
		Int_vec_print_integer_matrix_width(cout, Grass.M, w, n, n, 2);
		}

#endif



	groups::sims *S;
	ring_theory::longinteger_object go;
	//int goi;
	int *Elt;

	Elt = NEW_int(P->A->elt_size_in_int);
	S = P->A->Sims;
	S->group_order(go);
	cout << "found a group of order " << go << endl;
	//goi = go.as_int();

	if (f_v) {
		cout << "Hill_cap finding an element of order 7" << endl;
		}
	S->random_element_of_order(Elt, 7 /* order */, verbose_level);
	cout << "an element of order 7 is:" << endl;
	P->A->element_print_quick(Elt, cout);



	groups::schreier *Orb;
	int N;

	if (f_v) {
		cout << "Hill_cap computing orbits on points" << endl;
		}
	Orb = NEW_OBJECT(groups::schreier);
	Orb->init(P->A, verbose_level - 2);
	Orb->init_single_generator(Elt, verbose_level - 2);
	Orb->compute_all_point_orbits(verbose_level - 2);
	if (f_vv) {
		cout << "Hill_cap the orbits on points are:" << endl;
		Orb->print_and_list_orbits(cout);
		}








	int *pt_coords;
	//int *Good_orbits;
	int *set;
	int a, nb_pts, j;

	N = Orb->nb_orbits;
	nb_pts = P->A->degree;
	pt_coords = NEW_int(nb_pts * n);
	set = NEW_int(nb_pts);
	//Good_orbits = NEW_int(N);

	for (i = 0; i < nb_pts; i++) {
		O->unrank_point(pt_coords + i * n, 1, i, 0);
		}
	cout << "point coordinates:" << endl;
	Int_vec_print_integer_matrix_width(cout, pt_coords, nb_pts, n, n, 2);

	cout << "evaluating quadratic form:" << endl;
	for (i = 0; i < nb_pts; i++) {
		a = O->evaluate_quadratic_form(pt_coords + i * n, 1);
		cout << setw(3) << i << " : " << a << endl;
		}
	int sz[9];
	int i1, i2, i3, i4, i5, i6, i7, i8, ii;
	int nb_sol;

	int *Sets; // [max_sol * 56]
	int max_sol = 100;
	combinatorics::combinatorics_domain Combi;

	Sets = NEW_int(max_sol * 56);

	sz[0] = 0;
	nb_sol = 0;
	for (i1 = 0; i1 < N; i1++) {
		sz[1] = sz[0];
		append_orbit_and_adjust_size(Orb, i1, set, sz[1]);
		//cout << "after append_orbit_and_adjust_size :";
		//int_vec_print(cout, set, sz[1]);
		//cout << endl;
		if (!Gg.test_if_arc(F, pt_coords, set, sz[1], n, verbose_level)) {
			continue;
			}
		for (i2 = i1 + 1; i2 < N; i2++) {
			sz[2] = sz[1];
			append_orbit_and_adjust_size(Orb, i2, set, sz[2]);
			if (!Gg.test_if_arc(F, pt_coords, set, sz[2], n, verbose_level)) {
				continue;
				}
			for (i3 = i2 + 1; i3 < N; i3++) {
				sz[3] = sz[2];
				append_orbit_and_adjust_size(Orb, i3, set, sz[3]);
				if (!Gg.test_if_arc(F, pt_coords, set, sz[3], n, verbose_level)) {
					continue;
					}
				for (i4 = i3 + 1; i4 < N; i4++) {
					sz[4] = sz[3];
					append_orbit_and_adjust_size(Orb, i4, set, sz[4]);
					if (!Gg.test_if_arc(F, pt_coords, set, sz[4], n, verbose_level)) {
						continue;
						}
					for (i5 = i4 + 1; i5 < N; i5++) {
						sz[5] = sz[4];
						append_orbit_and_adjust_size(Orb, i5, set, sz[5]);
						if (!Gg.test_if_arc(F, pt_coords, set, sz[5], n, verbose_level)) {
							continue;
							}
						for (i6 = i5 + 1; i6 < N; i6++) {
							sz[6] = sz[5];
							append_orbit_and_adjust_size(Orb, i6, set, sz[6]);
							if (!Gg.test_if_arc(F, pt_coords, set, sz[6], n, verbose_level)) {
								continue;
								}
							for (i7 = i6 + 1; i7 < N; i7++) {
								sz[7] = sz[6];
								append_orbit_and_adjust_size(Orb, i7, set, sz[7]);
								if (!Gg.test_if_arc(F, pt_coords, set, sz[7], n, verbose_level)) {
									continue;
									}
								for (i8 = i7 + 1; i8 < N; i8++) {
									sz[8] = sz[7];
									append_orbit_and_adjust_size(Orb, i8, set, sz[8]);
									if (!Gg.test_if_arc(F, pt_coords, set, sz[8], n, verbose_level)) {
										continue;
										}

									if (sz[8] != 56) {
										cout << "error, the size of the arc is not 56" << endl;
										exit(1);
										}
									for (ii = 0; ii < sz[8]; ii++) {
										int rk;
										O->F->PG_element_rank_modified(pt_coords + set[ii] * n, 1, n, rk);
										Sets[nb_sol * 56 + ii] = rk;
										}

									nb_sol++;
									cout << "solution " << nb_sol << ", a set of size " << sz[8] << " : ";
									cout << i1 << "," << i2 << "," << i3 << "," << i4 << "," << i5 << "," << i6 << "," << i7 << "," << i8 << endl;
									Int_vec_print(cout, set, sz[8]);
									cout << endl;


#if 0
									solution(w, n, A, O, pt_coords,
										set, sz[8], Rank_lines, nb_lines, verbose_level);
									cout << endl;
#endif

									} // next i8
								} // next i7
							} // next i6
						} // next i5
					} // next i4
				} // next i3
			} // next i2
		} // next i1
	cout << "there are " << nb_sol << " solutions" << endl;
	cout << "out of " << Combi.int_n_choose_k(N, 8) << " possibilities" << endl;


	for (i = 0; i < nb_sol; i++) {
		cout << "Solution " << i << ":" << endl;
		for (j = 0; j < 56; j++) {
			cout << Sets[i * 56 + j] << " ";
			}
		cout << endl;
		}

	if (nb_sol == 0) {
		cout << "error, no solution" << endl;
		exit(1);
		}

	nb_Pts = 56;
	Pts = NEW_lint(56);
	for (j = 0; j < 56; j++) {
		Pts[j] = Sets[0 * 56 + j];
		}
	sprintf(fname, "Hill_cap_56.txt");

	FREE_int(Sets);

	FREE_OBJECT(P);
	FREE_OBJECT(A);
	FREE_OBJECT(An);
	FREE_OBJECT(F);

}

void combinatorics_global::append_orbit_and_adjust_size(groups::schreier *Orb,
		int idx, int *set, int &sz)
// Used by Hill_cap56()
{
	int f, i, len;

	f = Orb->orbit_first[idx];
	len = Orb->orbit_len[idx];
	for (i = 0; i < len; i++) {
		set[sz++] = Orb->orbit[f + i];
	}
}


#if 0
void combinatorics_global::classify_objects_using_nauty(
		data_structures::data_input_stream_description *Data,
		data_structures::classify_bitvectors *CB,
	std::string &output_fname,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	//int input_idx;
	//int t0;
	//orbiter_kernel_system::file_io Fio;
	//orbiter_kernel_system::os_interface Os;
	//int nb_objects_to_test;
	//long int *Ago;
	//vector<vector<long int>> Reps;


	if (f_v) {
		cout << "combinatorics_global::classify_objects_using_nauty" << endl;
	}

#if 0
	if (f_v) {
		cout << "combinatorics_global::classify_objects_using_nauty "
				"before count_number_of_objects_to_test" << endl;
	}
	nb_objects_to_test = Data->count_number_of_objects_to_test(
		verbose_level - 1);

	t0 = Os.os_ticks();


	Ago = NEW_lint(nb_objects_to_test);

	int N_points = -1;
	int design_b = -1;
	int design_k = -1;
	int partition_class_size = -1;

	for (input_idx = 0; input_idx < Data->nb_inputs; input_idx++) {
		if (f_v) {
			cout << "combinatorics_global::classify_objects_using_nauty input "
					<< input_idx << " / " << Data->nb_inputs
					<< " is:" << endl;
		}

		if (Data->input_type[input_idx] == INPUT_TYPE_FILE_OF_DESIGNS) {
			if (f_v) {
				cout << "combinatorics_global::classify_objects_using_nauty "
					"input " << input_idx << " / " << Data->nb_inputs
					<< " from file " << Data->input_string[input_idx]
					<< ":" << endl;
			}

			if (N_points == -1) {
				N_points = Data->input_data1[input_idx];
				design_b = Data->input_data2[input_idx];
				design_k = Data->input_data3[input_idx];
				partition_class_size = Data->input_data4[input_idx];
			}
			else {
				if (Data->input_data1[input_idx] != N_points) {
					cout << "combinatorics_global::classify_objects_using_nauty N_points is not constant" << endl;
					exit(1);
				}
				if (Data->input_data2[input_idx] != design_b) {
					cout << "combinatorics_global::classify_objects_using_nauty design_b is not constant" << endl;
					exit(1);
				}
				if (Data->input_data3[input_idx] != design_k) {
					cout << "combinatorics_global::classify_objects_using_nauty design_k is not constant" << endl;
					exit(1);
				}
			}

			handle_input_file(CB, nb_objects_to_test, t0,
					Data->input_string[input_idx], input_idx, Data->nb_inputs,
					N_points, design_b, design_k, partition_class_size,
					Ago, Reps,
					verbose_level);

			if (f_v) {
				cout << "combinatorics_global::classify_objects_using_nauty "
					"input " << input_idx << " / " << Data->nb_inputs
					<< " from file " << Data->input_string[input_idx]
					<< " finished" << endl;
			}
		} // if INPUT_TYPE_FILE_OF_DESIGNS
		else {
			cout << "combinatorics_global::classify_objects_using_nauty unknown input type" << endl;
			exit(1);
		}

		if (f_v) {
			cout << "combinatorics_global::classify_objects_using_nauty distribution of automorphism group orders of new isomorphism types after file "
				<< input_idx << " / " << Data->nb_inputs << " is:" << endl;
			tally C;

			C.init_lint(Ago, CB->nb_types, FALSE, 0);
			C.print_naked(TRUE);
			cout << endl;
		}

	} // next input_idx


#if 0
	int t;

	for (t = 0; t < nb_test_perm; t++) {
		int *perm;
		int degree;
		int i;

		cout << "combinatorics_global::classify_objects_using_nauty testing permutation " << test_perm[t] << endl;
		scan_permutation_from_string(test_perm[t],
			perm, degree, verbose_level);
		cout << "the permutation is:" << endl;
		for (i = 0; i < degree; i++) {
			cout << i << " -> " << perm[i] << endl;
		}
	}
#endif

	if (N_points == -1) {
		cout << "N_points == -1" << endl;
		exit(1);
	}

	set_of_sets *SoS;
	int i, j;

	SoS = NEW_OBJECT(set_of_sets);

	cout << "saving" << endl;
	cout << "combinatorics_global::classify_objects_using_nauty allocating set of sets of size " << Reps.size() << " each of size " << design_b << endl;
	SoS->init_basic_constant_size(N_points, Reps.size(), design_b, 0 /* verbose_level */);

	for (i = 0; i < Reps.size(); i++) {
		vector<long int> rep;

		rep = Reps[i];
		for (j = 0; j < design_b; j++) {
			SoS->Sets[i][j] = rep[j];
		}
	}

	SoS->save_constant_size_csv(output_fname, verbose_level);

#if 0
	if (f_v) {
		cout << "combinatorics_global::classify_objects_using_nauty "
				"before compute_and_print_ago_distribution" << endl;
	}

	compute_and_print_ago_distribution(cout, CB, verbose_level);

	if (f_v) {
		cout << "combinatorics_global::classify_objects_using_nauty "
				"after compute_and_print_ago_distribution" << endl;
	}

	if (f_v) {
		cout << "classify_objects_using_nauty before CB->finalize" << endl;
	}

	//CB->finalize(verbose_level); // computes C_type_of and perm
#endif


#endif

	if (f_v) {
		cout << "combinatorics_global::classify_objects_using_nauty done" << endl;
	}
}





void combinatorics_global::handle_input_file(data_structures::classify_bitvectors *CB,
		int nb_objects_to_test, int t0,
		std::string &fname, int input_file_idx, int nb_input_files,
		int N_points, int design_b, int design_k, int partition_class_size,
		long int *Ago, std::vector<std::vector<long int>> &Reps,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int f_vvv = (verbose_level >= 3);
	orbiter_kernel_system::os_interface Os;

	int nck;
	int nb_classes = design_b / partition_class_size;
	int t1, dt;

	if (f_v) {
		cout << "combinatorics_global::handle_input_file fname=" << fname << endl;
	}

	combinatorics::combinatorics_domain Combi;

	nck = Combi.int_n_choose_k(N_points, design_k);

	data_structures::set_of_sets *SoS;

	SoS = NEW_OBJECT(data_structures::set_of_sets);

	if (f_v) {
		cout << "N_points=" << N_points << endl;
		cout << "design_b=" << design_b << endl;
		cout << "design_k=" << design_k << endl;
		cout << "partition_class_size=" << partition_class_size << endl;
		cout << "nb_classes=" << nb_classes << endl;
		cout << "combinatorics_global::handle_input_file Reading the file " << fname << endl;
	}

	SoS->init_from_file(
			nck /* underlying_set_size */,
			fname, verbose_level);

	if (f_v) {
		cout << "Read the file " << fname << endl;
	}

	int h;


	if (f_v) {
		cout << "combinatorics_global::handle_input_file processing "
			<< SoS->nb_sets << " objects" << endl;
	}

	for (h = 0; h < SoS->nb_sets; h++) {

		if (f_v) {
			cout << "Input set " << h << " / " << SoS->nb_sets << ", "
					<< input_file_idx << " / " << nb_input_files << ":" << endl;
		}

		long int *the_set_in;
		int set_size_in;


		set_size_in = SoS->Set_size[h];
		the_set_in = SoS->Sets[h];



		if (set_size_in != design_b) {
			cout << "handle_input_file "
					"set_size_in != design_b" << endl;
			exit(1);
		}

		if (FALSE) {
			orbiter_kernel_system::Orbiter->Lint_vec->matrix_print(the_set_in, nb_classes, partition_class_size);
		}
		if (f_vv || ((h % 1024) == 0)) {
			cout << "combinatorics_global::handle_input_file "
					"The input set " << h << " / " << SoS->nb_sets << ", "
					<< input_file_idx << " / " << nb_input_files << " : "
				<< " has size " << set_size_in << ":" << endl;
		}

		if (f_vvv) {
			cout << "combinatorics_global::handle_input_file "
					"The input set is:" << endl;
			Lint_vec_print(cout, the_set_in, set_size_in);
			cout << endl;
		}




		geometry::incidence_structure *Inc;
		int *partition;

		Inc = NEW_OBJECT(geometry::incidence_structure);
		Inc->init_large_set(
				the_set_in /* blocks */,
				N_points, design_b, design_k, partition_class_size,
				partition, 0 /*verbose_level*/);

#if 0
		{
			string fname_input;
			char str[1000];
			string_tools ST;
			file_io Fio;

			fname_input.assign(fname);
			ST.chop_off_extension(fname_input);
			sprintf(str, "_input_%d.csv", h);
			fname_input.append(str);
			Fio.int_matrix_write_csv(fname_input, Inc->M, Inc->nb_rows, Inc->nb_cols);
		}
#endif


		data_structures_groups::incidence_structure_with_group *IG;

		IG = NEW_OBJECT(data_structures_groups::incidence_structure_with_group);
		IG->init(Inc,
				partition,
				0/*verbose_level - 2*/);

		int f_found;
		int idx;
		ring_theory::longinteger_object go;

		geometry::incidence_structure *Inc_out;


		process_object(
					CB,
					IG,
					Inc_out,
					//f_save_incma_in_and_out, save_incma_in_and_out_prefix,
					nb_objects_to_test,
					f_found, idx,
					go,
					verbose_level - 2);

#if 0
		{
			string fname_output;
			char str[1000];
			string_tools ST;
			file_io Fio;

			fname_output.assign(fname);
			ST.chop_off_extension(fname_output);
			sprintf(str, "_output_%d.csv", h);
			fname_output.append(str);
			Fio.int_matrix_write_csv(fname_output, Inc_out->M, Inc_out->nb_rows, Inc_out->nb_cols);
		}
#endif

		FREE_OBJECT(Inc_out);
		FREE_OBJECT(IG);
		FREE_OBJECT(Inc);
		FREE_int(partition);


		if (f_found) {

			if (f_v) {
				cout << "combinatorics_global::handle_input_file input set " << h << " found at position " << idx
					<< ", corresponding to input object " << CB->Type_rep[idx]
					<< " and hence is skipped" << endl;
			}
		}
		else {
			if (f_v) {
				cout << "combinatorics_global::handle_input_file new isomorphism type: ";
				Lint_vec_print(cout, the_set_in, set_size_in);
				cout << endl;
			}
			vector<long int> rep;
			int i;

			for (i = 0; i < set_size_in; i++) {
				rep.push_back(the_set_in[i]);
			}
			Reps.push_back(rep);

			t1 = Os.os_ticks();
			//cout << "poset_classification::print_level_info t0=" << t0 << endl;
			//cout << "poset_classification::print_level_info t1=" << t1 << endl;
			dt = t1 - t0;
			//cout << "poset_classification::print_level_info dt=" << dt << endl;

			if (f_v) {
				cout << "Time ";
				Os.time_check_delta(cout, dt);
			}

			//longinteger_object go;

			//IG->A_perm->group_order(go);

			if (f_v) {
				cout << " --- New isomorphism type! input set " << h
					<< " / " << SoS->nb_sets << ", " << input_file_idx << " / " << nb_input_files << " : "
					<< " The n e w number of "
					"isomorphism types is " << CB->nb_types << " go=" << go << endl;
			}

			Ago[CB->nb_types - 1] = go.as_lint();

		}

		if (f_vv) {
			cout << "combinatorics_global::handle_input_file after input set " << h << " / "
					<< SoS->nb_sets << ", " << input_file_idx << " / " << nb_input_files
					<< ", we have " << CB->nb_types
					<< " isomorphism types of objects" << endl;
		}

	} // next h
	FREE_OBJECT(SoS);


	if (f_v) {
		cout << "combinatorics_global::handle_input_file fname=" << fname << ", "
			<< input_file_idx << " / " << nb_input_files << " done" << endl;
	}

}


void combinatorics_global::process_object(
		data_structures::classify_bitvectors *CB,
		data_structures_groups::incidence_structure_with_group *IG,
		geometry::incidence_structure *&Inc_out,
	int nb_objects_to_test,
	int &f_found, int &idx,
	ring_theory::longinteger_object &go,
	int verbose_level)
// does not store IG
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "process_object n=" << CB->n << endl;
	}

	if (f_v) {
		cout << "process_object "
				"before IG->set_stabilizer_and_canonical_form" << endl;
	}


	IG->set_stabilizer_and_canonical_form(
			//f_save_incma_in_and_out, save_incma_in_and_out_prefix,
			TRUE /* f_compute_canonical_form */,
			Inc_out,
			verbose_level);


	if (f_v) {
		cout << "process_object "
				"after IG->set_stabilizer_and_canonical_form" << endl;
	}


	IG->A_perm->group_order(go);

	if (FALSE) {
		cout << "generators for the automorphism group are:" << endl;
		IG->A_perm->Strong_gens->print_generators_tex(cout);
	}


	if (CB->n == 0) {
		cout << "process_object CB->n == 0, calling CB->init with "
				"IG->canonical_form_len=" << IG->canonical_form->get_allocated_length() << endl;
		CB->init(nb_objects_to_test, IG->canonical_form->get_allocated_length(), verbose_level);
	}

#if 0
	if (f_v) {
		cout << "process_object before CB->search_and_add_if_new" << endl;
		cout << "canonical_form=";
		IG->print_canonical_form(cout);

	}
#endif

	CB->search_and_add_if_new(IG->canonical_form->get_data(), NULL /*IG*/, f_found, idx, verbose_level);


	if (f_v) {
		cout << "process_object done" << endl;
	}
}
#endif





}}}

