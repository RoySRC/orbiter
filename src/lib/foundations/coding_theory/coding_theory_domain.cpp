/*
 * coding_theory_domain.cpp
 *
 *  Created on: Apr 21, 2019
 *      Author: betten
 */


#include "foundations.h"

using namespace std;



namespace orbiter {
namespace foundations {


coding_theory_domain::coding_theory_domain()
{

}

coding_theory_domain::~coding_theory_domain()
{

}





void coding_theory_domain::twisted_tensor_product_codes(
	int *&H_subfield, int &m, int &n,
	finite_field *F, finite_field *f,
	int f_construction_A, int f_hyperoval,
	int f_construction_B, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int index;
	int exponents[9];
	int *M;
	//int *H_subfield;
	int *C;
	int *C_inv;

	int q = f->q;
	int q2;
	int Q;
	//int m, n;
	int r;
	int beta, beta_q;
	int f_elements_exponential = TRUE;
	const char *symbol_for_print = "\\alpha";
	const char *symbol_for_print_subfield = "\\omega";



	if (f_v) {
		cout << "twisted_tensor_product_codes" << endl;
		cout << "f_construction_A=" << f_construction_A << endl;
		cout << "f_hyperoval=" << f_hyperoval << endl;
		cout << "f_construction_B=" << f_construction_B << endl;
		}


	q2 = q * q;
	Q = 0;
	if (f_construction_A) {
		Q = q2;
		}
	else if (f_construction_B) {
		Q = q2 * q;
		}
	index = (Q - 1) / (q - 1);

	if (Q != F->q) {
		cout << "twisted_tensor_product_codes Q != F->q" << endl;
		exit(1);
		}


	if (f_vv) {
		cout << "q = " << q << endl;
		cout << "Q = " << Q << endl;
		cout << "index = " << index << endl;
		}

#if 0
	F.init_override_polynomial(Q, override_poly_Q, verbose_level - 2);

	if (f_vv) {
		cout << "field of order " << Q << " initialized" << endl;
		}

	f.init_override_polynomial(q, override_poly_q, verbose_level - 2);

	if (f_vv) {
		cout << "field of order " << q << " initialized" << endl;
		cout << "index = " << index << endl;
		}
#endif

	F->compute_subfields(verbose_level - 2);


	create_matrix_M(
			M,
			F, f,
			m, n, beta, r, exponents,
			f_construction_A, f_hyperoval, f_construction_B,
			f_elements_exponential, symbol_for_print,
			verbose_level - 2);

	beta_q = F->power(beta, q);

	if (f_vv) {
		cout << "twisted_tensor_product_codes after create_matrix_M" << endl;
		cout << "m = " << m << endl;
		cout << "n = " << n << endl;
		cout << "Q = " << Q << endl;
		cout << "q2 = " << q2 << endl;
		cout << "beta = " << beta << endl;
		cout << "beta_q = " << beta_q << endl;
		cout << "Exponents: ";
		int_vec_print(cout, exponents, m);
		cout << endl;
		}

	if (f_vv) {
		cout << "twisted_tensor_product_codes: M:" << endl;
		print_integer_matrix_width(cout, M, m, n, n, 2);

		F->latex_matrix(cout, f_elements_exponential, symbol_for_print, M, m, n);
		}




#if 0
	for (j = 0; j < n; j++) {
		PG_element_normalize(F, M + j, n, m);
		}
	cout << "column normalized M:" << endl;
	print_integer_matrix_width(cout, M, m, n, n, 2);
#endif




	C = NEW_int(m * m);
	C_inv = NEW_int(m * m);
	H_subfield = NEW_int(m * n);


	create_matrix_H_subfield(F, f,
		H_subfield, C, C_inv, M, m, n, beta, beta_q,
		f_elements_exponential, symbol_for_print, symbol_for_print_subfield,
		f_construction_A, f_hyperoval, f_construction_B,
		verbose_level - 2);


	if (f_v) {
		cout << "twisted_tensor_product_codes: after create_matrix_H_subfield" << endl;
		cout << "H_subfield:" << endl;
		print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
		f->latex_matrix(cout, f_elements_exponential, symbol_for_print_subfield, H_subfield, m, n);
		}

	FREE_int(M);
	FREE_int(C);
	FREE_int(C_inv);

}


void coding_theory_domain::create_matrix_M(
	int *&M,
	finite_field *F, finite_field *f,
	int &m, int &n, int &beta, int &r, int *exponents,
	int f_construction_A, int f_hyperoval, int f_construction_B,
	int f_elements_exponential, const char *symbol_for_print,
	int verbose_level)
// int exponents[9]
{
	int f_v = (verbose_level >= 1);
	//int f_vv = (verbose_level >= 2);
	int i, j, t, q, Q, q2;

	q = f->q;
	q2 = q * q;


	if (f_construction_A) {

#if 0
		//q = 2; override_poly_Q = ""; override_poly = "";
		//q = 3; override_poly_Q = ""; override_poly = "";
		q = 4; override_poly_Q = "19"; override_poly = "7";
			// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
			// F_16 generated by X^4+X+1 = 19
			// F_4 generated by X^2+X+1 = 7
		//q = 5; override_poly_Q = "47"; override_poly = "";
			// F_625  generated by X^4 + X^3 + 3X + 2
			// F_25  generated by X^2 + 4X + 2  = 47
		//q = 7; override_poly_Q = ""; override_poly = "";
		//q = 8; override_poly_Q = "97"; override_poly = "11";
			// F_4096 generated by x^12+x^6+x^4+x+1
			// F_64 generated by X^6+X^5+1 = 97
			// F_8 generated by X^3+X+1 = 11
		//q = 9; override_poly_Q = ""; override_poly = "17";
#endif
		Q = q2;
		beta = q;
		m = 9;
		if (f_hyperoval) {
			n = Q + 2;
			}
		else {
			n = Q + 1;
			}
		r = 5;
		if (q == 4)
			r = 7;
		if (q == 3)
			r = 9;
		// 3 orbits of length 1: 0, q+1, 2q+2
		exponents[0] = 0;
		exponents[1] = q + 1;
		exponents[2] = 2 * q + 2;
		//orbit (q,1)
		exponents[3] = q;
		exponents[4] = 1;
		// orbit (2q, 2)
		exponents[5] = 2 * q;
		exponents[6] = 2;
		// orbit (2q+1, q+2)
		exponents[7] = 2 * q + 1;
		exponents[8] = q + 2;
		//exponents[0] = 0;
		//exponents[1] = q;
		//exponents[2] = 2 * q;
		//exponents[3] = 1;
		//exponents[4] = q + 1;
		//exponents[5] = 2 * q + 1;
		//exponents[6] = 2;
		//exponents[7] = q + 2;
		//exponents[8] = 2 * q + 2;
		}
	else if (f_construction_B) {

#if 0
		//q = 2; override_poly_Q = ""; override_poly = ""; r = 9;
		//q = 3; override_poly_Q = ""; override_poly = ""; r = 5;
		q = 4; override_poly_Q = ""; override_poly = "7"; r = 4;
			// F_4096  generated by X^8 + X^4 + X^3 + X^2 + 1 = 4096
		//q = 5; override_poly_Q = ""; override_poly = ""; r = 4;
		//q = 7; override_poly_Q = ""; override_poly = ""; r = 4;
#endif

		beta = q;
		Q = q2 * q;
		m = 8;
		n = Q + 1;

		exponents[0] = 0;
		exponents[1] = q2 + q + 1;
		exponents[2] = 1;
		exponents[3] = q;
		exponents[4] = q2;
		exponents[5] = q + 1;
		exponents[6] = q2 + q;
		exponents[7] = q2 + 1;
		//exponents[0] = 0;
		//exponents[1] = q;
		//exponents[2] = 1;
		//exponents[3] = q + 1;
		//exponents[4] = q2;
		//exponents[5] = q2 + q;
		//exponents[6] = q2 + 1;
		//exponents[7] = q2 + q + 1;
		}
	else {
		cout << "create_matrix_M(): please specify the construction using option -A or -B" << endl;
		exit(1);
		}


	// create matrix M:
	M = NEW_int(m * n);
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			M[i * n + j] = 0;
			}
		}
	for (t = 0; t < Q; t++) {
		for (i = 0; i < m; i++) {
			M[i * n + t] = F->power(t, exponents[i]);
			}
		}
	if (f_construction_A) {
		M[2 * n + Q] = 1;
		if (f_hyperoval)
			M[1 * n + Q + 1] = 1;
		}
	else if (f_construction_B) {
		M[1 * n + Q] = 1;
		}

	if (f_v) {
		cout << "M:" << endl;
		print_integer_matrix_width(cout, M, m, n, n, 2);

		F->latex_matrix(cout, f_elements_exponential,
				symbol_for_print, M, m, n);
		}


	if (f_v) {
		int *all_one, *col_sum;

		all_one = NEW_int(n);
		col_sum = NEW_int(m);
		for (i = 0; i < n; i++)
			all_one[i] = 1;
		F->mult_matrix_matrix(M, all_one, col_sum, m, n, 1,
				0 /* verbose_level */);
		cout << "overall col_sum:" << endl;
		print_integer_matrix_width(cout, col_sum, m, 1, 1, 2);
		FREE_int(all_one);
		FREE_int(col_sum);
		}


}



void coding_theory_domain::create_matrix_H_subfield(
	finite_field *F, finite_field*f,
	int *H_subfield, int *C, int *C_inv, int *M,
	int m, int n, int beta, int beta_q,
	int f_elements_exponential, const char *symbol_for_print,
	const char *symbol_for_print_subfield,
	int f_construction_A, int f_hyperoval, int f_construction_B,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int i, j;
	int q;
	//int *C;
	//int *C_inv;
	int *H;
	int *AA;

	q = f->q;

	// matrix C is zero:
	H = NEW_int(m * n);
	AA = NEW_int(m * m);
	for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++) {
			C[i * m + j] = 0;
			}
		}


	if (f_construction_A) {
		int nb_C_coeffs = 15;
		int k, aa;
		int C_coeffs[] = {
			0, 0, 1,
			1, 1, 1,
			2, 2, 1,
			3, 3, 1,
			3, 4, 1,
			4, 3, beta_q,
			4, 4, beta,
			5, 5, 1,
			5, 6, 1,
			6, 5, beta_q,
			6, 6, beta,
			7, 7, 1,
			7, 8, 1,
			8, 7, beta_q,
			8, 8, beta,
			};
		for (k = 0; k < nb_C_coeffs; k++) {
			i = C_coeffs[k * 3 + 0];
			j = C_coeffs[k * 3 + 1];
			aa = C_coeffs[k * 3 + 2];
			C[i * m + j] = aa;
			}
		}
	else if (f_construction_B) {
		int nb_C_coeffs = 20;
		int k, aa;
		int C_coeffs[] = {
			0, 0, 1,
			1, 1, 1,
			2, 2, 1,
			2, 3, 1,
			2, 4, 1,
			3, 2, beta,
			3, 3, beta_q,
			3, 4, F->beta_trinomial(q, beta, 1, 0, 0),
			4, 2, F->beta_trinomial(q, beta, 0, 0, 2),
			4, 3, F->beta_trinomial(q, beta, 0, 2, 0),
			4, 4, F->beta_trinomial(q, beta, 2, 0, 0),
			5, 5, 1,
			5, 6, 1,
			5, 7, 1,
			6, 5, F->beta_trinomial(q, beta, 0, 1, 1),
			6, 6, F->beta_trinomial(q, beta, 1, 1, 0),
			6, 7, F->beta_trinomial(q, beta, 1, 0, 1),
			7, 5, F->beta_trinomial(q, beta, 0, 2, 2),
			7, 6, F->beta_trinomial(q, beta, 2, 2, 0),
			7, 7, F->beta_trinomial(q, beta, 2, 0, 2),
			};
		for (k = 0; k < nb_C_coeffs; k++) {
			i = C_coeffs[k * 3 + 0];
			j = C_coeffs[k * 3 + 1];
			aa = C_coeffs[k * 3 + 2];
			C[i * m + j] = aa;
			}
		}


	if (f_v) {
		cout << "matrix C:" << endl;
		print_integer_matrix_width(cout, C, m, m, m, 2);
		F->latex_matrix(cout, f_elements_exponential,
				symbol_for_print, C, m, m);
		}


	F->invert_matrix(C, C_inv, m);

	if (f_vv) {
		cout << "C_inv:" << endl;
		print_integer_matrix_width(cout, C_inv, m, m, m, 2);
		}

	F->mult_matrix_matrix(C, C_inv, AA, m, m, m,
			0 /* verbose_level */);

	if (f_vv) {
		cout << "C * C_inv:" << endl;
		print_integer_matrix_width(cout, AA, m, m, m, 2);
		}


	F->mult_matrix_matrix(C, M, H, m, m, n,
			0 /* verbose_level */);

	if (f_v) {
		cout << "H = C * M:" << endl;
		print_integer_matrix_width(cout, H, m, n, n, 2);
		F->latex_matrix(cout, f_elements_exponential,
				symbol_for_print, H, m, n);
		}


#if 0
	rk = F.Gauss_int(M, FALSE /* f_special */, TRUE /* f_complete */, base_cols,
		FALSE /* f_P */, NULL, m /* m */, n /* n */, 0 /* Pn */,
		verbose_level - 2);
	cout << "has rank " << rk << endl;
#endif

	tt_field_reduction(*F, *f, m, n, H, H_subfield, verbose_level - 2);

	if (f_v) {
		cout << "H_subfield:" << endl;
		print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
		f->latex_matrix(cout, f_elements_exponential,
				symbol_for_print_subfield, H_subfield, m, n);
		}

	FREE_int(H);
	FREE_int(AA);
}



void coding_theory_domain::tt_field_reduction(
		finite_field &F, finite_field &f,
		int m, int n, int *M, int *MM, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int  i, j, a, z, b, c, Q, q;
	int index;

	Q = F.q;
	q = f.q;
	index = (Q - 1) / (q - 1);
	if (f_v) {
		cout << "field reduction, Q=" << Q
				<< " q=" << q << " index=" << index << endl;
		}
	if (f_vv) {
		cout << "before:" << endl;
		print_integer_matrix_width(cout, M, m, n, n, 2);
		//print_integer_matrix(cout, M, m, n);
		cout << endl;
		F.print_integer_matrix_zech(cout, M, m, n);
		cout << endl;
		}
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			a = M[i * n + j];
			if (a == 0) {
				c = 0;
				}
			else {
				if (f.e == 1) {
					if (a >= q) {
						cout << "field reduction: element does not "
								"lie in the subfield: " << a << endl;
						exit(1);
						}
					c = a;
					}
				else {
					z = F.log_alpha(a);
					b = z / index;
					if (b * index != z) {
						cout << "b * index != z" << endl;
						exit(1);
						}
					c = f.alpha_power(b);
					}
				}
			MM[i * n + j] = c;
			}
		}
	if (f_vv) {
		cout << "after:" << endl;
		print_integer_matrix_width(cout, MM, m, n, n, 2);
		//print_integer_matrix(cout, MM, m, n);
		cout << endl;
		f.print_integer_matrix_zech(cout, MM, m, n);
		cout << endl;
		}
}





//############################################### old stuff:

void coding_theory_domain::make_tensor_code_9dimensional_as_point_set(
	finite_field *F,
	int *&the_set, int &length,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_hyperoval = FALSE;
	const char *override_poly = "";
	const char *override_poly_Q = "";
	int i, t, q;
	int *code;

	if (f_v) {
		cout << "make_tensor_code_9dimensional_as_point_set" << endl;
		}
	q = F->q;
	if (q == 2) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
		}
	else if (q == 3) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
		}
	else if (q == 4) {
		override_poly_Q = "19"; override_poly = "7"; f_hyperoval = FALSE;
		// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
		// F_16 generated by X^4+X+1 = 19
		// F_4 generated by X^2+X+1 = 7
		}
	else if (q == 5) {
		override_poly_Q = "47"; override_poly = ""; f_hyperoval = FALSE;
		// F_625  generated by X^4 + X^3 + 3X + 2
		// F_25  generated by X^2 + 4X + 2  = 47
		}
	else if (q == 7) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
		}
	else if (q == 8) {
		override_poly_Q = "97"; override_poly = "11"; f_hyperoval = TRUE;
		// F_4096 generated by x^12+x^6+x^4+x+1
		// F_64 generated by X^6+X^5+1 = 97
		// F_8 generated by X^3+X+1 = 11
		}
	else if (q == 9) {
		override_poly_Q = ""; override_poly = "17"; f_hyperoval = FALSE;
		}
	make_tensor_code_9_dimensional(q, override_poly_Q, override_poly,
		f_hyperoval, code, length, verbose_level - 1);

	the_set = NEW_int(length);

	int pt[9], rk;

	for (t = 0; t < length; t++) {
		for (i = 0; i < 9; i++) {
			pt[i] = code[i * length + t];
			}
		F->PG_element_rank_modified(pt, 1, 9, rk);
		the_set[t] = rk;
		}
	FREE_int(code);
	if (f_v) {
		cout << "make_tensor_code_9dimensional_as_point_set done" << endl;
		cout << "created the set: ";
		int_vec_print(cout, the_set, length);
		cout << endl;
		}
}

void coding_theory_domain::make_tensor_code_9_dimensional(int q,
	const char *override_poly_Q, const char *override_poly,
	int f_hyperoval,
	int *&code, int &length,
	int verbose_level)
{
	finite_field F;
	finite_field f;
	rank_checker rc;
	int exponents[9];
	int *M;
	int *C;
	int *C_inv;
	int *H;
	int *H_subfield;
	int index, Q, i, j, t, m, n, r, beta, beta_q;
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);


	if (f_v) {
		cout << "make_tensor_code_9_dimensional q=" << q << endl;
		}

	//q = 2; override_poly_Q = ""; override_poly = ""; int f_hyperoval = FALSE;
	//q = 3; override_poly_Q = ""; override_poly = ""; int f_hyperoval = FALSE;
	//q = 4; override_poly_Q = "19"; override_poly = "7"; int f_hyperoval = FALSE;
		// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
		// F_16 generated by X^4+X+1 = 19
		// F_4 generated by X^2+X+1 = 7
	//q = 5; override_poly_Q = "47"; override_poly = ""; int f_hyperoval = FALSE;
		// F_625  generated by X^4 + X^3 + 3X + 2
		// F_25  generated by X^2 + 4X + 2  = 47
	//q = 7; override_poly_Q = ""; override_poly = ""; int f_hyperoval = FALSE;
	//q = 8; override_poly_Q = "97"; override_poly = "11"; int f_hyperoval = TRUE;
		// F_4096 generated by x^12+x^6+x^4+x+1
		// F_64 generated by X^6+X^5+1 = 97
		// F_8 generated by X^3+X+1 = 11
	//q = 9; override_poly_Q = ""; override_poly = "17"; int f_hyperoval = FALSE;
	beta = q;
	Q = q * q;
	m = 9;
	if (f_hyperoval) {
		n = Q + 2;
		}
	else {
		n = Q + 1;
		}
	r = 5;
	if (q == 4)
		r = 7;
	if (q == 3)
		r = 9;
	exponents[0] = 0;
	exponents[1] = q + 1;
	exponents[2] = 2 * q + 2;
	exponents[3] = q;
	exponents[4] = 1;
	exponents[5] = 2 * q;
	exponents[6] = 2;
	exponents[7] = 2 * q + 1;
	exponents[8] = q + 2;
	//exponents[0] = 0;
	//exponents[1] = q;
	//exponents[2] = 2 * q;
	//exponents[3] = 1;
	//exponents[4] = q + 1;
	//exponents[5] = 2 * q + 1;
	//exponents[6] = 2;
	//exponents[7] = q + 2;
	//exponents[8] = 2 * q + 2;

	index = (Q - 1) / (q - 1);


	cout << "q = " << q << " override polynomial = " << override_poly << endl;
	cout << "Q = " << Q << endl;

	F.init_override_polynomial(Q, override_poly_Q, verbose_level);
	cout << "field of order " << Q << " initialized" << endl;
	beta_q = F.power(beta, q);
	f.init_override_polynomial(q, override_poly, verbose_level);
	cout << "field of order " << q << " initialized" << endl;
	cout << "n = " << n << endl;
	cout << "index = " << index << endl;
	cout << "beta = " << beta << endl;
	cout << "beta_q = " << beta_q << endl;
	F.compute_subfields(verbose_level - 3);

	M = NEW_int(m * n);
	C = NEW_int(m * m);
	C_inv = NEW_int(m * m);
	H = NEW_int(m * n);
	H_subfield = NEW_int(m * n);

	rc.init(&f, m, n, r + 1);

	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			M[i * n + j] = 0;
			}
		}
	for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++) {
			C[i * m + j] = 0;
			}
		}
	for (t = 0; t < Q; t++) {
		for (i = 0; i < m; i++) {
			M[i * n + t] = F.power(t, exponents[i]);
			}
		}
	{
	M[2 * n + Q] = 1;
	if (f_hyperoval)
		M[1 * n + Q + 1] = 1;
	int nb_C_coeffs = 15;
	int k, aa;
	int C_coeffs[] = {
		0, 0, 1,
		1, 1, 1,
		2, 2, 1,
		3, 3, 1,
		3, 4, 1,
		4, 3, beta_q,
		4, 4, beta,
		5, 5, 1,
		5, 6, 1,
		6, 5, beta_q,
		6, 6, beta,
		7, 7, 1,
		7, 8, 1,
		8, 7, beta_q,
		8, 8, beta,
		};
	for (k = 0; k < nb_C_coeffs; k++) {
		i = C_coeffs[k * 3 + 0];
		j = C_coeffs[k * 3 + 1];
		aa = C_coeffs[k * 3 + 2];
		C[i * m + j] = aa;
		}
	}

	cout << "M:" << endl;
	print_integer_matrix_width(cout, M, m, n, n, 2);

	{
		int *all_one, *col_sum;

		all_one = NEW_int(n);
		col_sum = NEW_int(m);
		for (i = 0; i < n; i++)
			all_one[i] = 1;
		F.mult_matrix_matrix(M, all_one, col_sum, m, n, 1,
				0 /* verbose_level */);
		cout << "col_sum:" << endl;
		print_integer_matrix_width(cout, col_sum, m, 1, 1, 2);
		FREE_int(all_one);
		FREE_int(col_sum);
	}

#if 0
	for (j = 0; j < n; j++) {
		PG_element_normalize(F, M + j, n, m);
		}
	cout << "column normalized M:" << endl;
	print_integer_matrix_width(cout, M, m, n, n, 2);
#endif


	cout << "C:" << endl;
	print_integer_matrix_width(cout, C, m, m, m, 2);

	F.invert_matrix(C, C_inv, m);

	cout << "C_inv:" << endl;
	print_integer_matrix_width(cout, C_inv, m, m, m, 2);

	{
	int *AA;
	AA = NEW_int(m * m);
	F.mult_matrix_matrix(C, C_inv, AA, m, m, m,
			0 /* verbose_level */);
	cout << "C * C_inv:" << endl;
	print_integer_matrix_width(cout, AA, m, m, m, 2);
	FREE_int(AA);
	}

	F.mult_matrix_matrix(C, M, H, m, m, n,
			0 /* verbose_level */);
	cout << "H = C * M:" << endl;
	print_integer_matrix_width(cout, H, m, n, n, 2);


#if 0
	rk = F.Gauss_int(M, FALSE /* f_special */, TRUE /* f_complete */, base_cols,
		FALSE /* f_P */, NULL, m /* m */, n /* n */, 0 /* Pn */,
		FALSE, FALSE);
	cout << "has rank " << rk << endl;
#endif

	if (f_vv) {
		cout << "before field reduction:" << endl;
		print_integer_matrix_width(cout, H, m, n, n, 2);
		cout << endl;
		f.print_integer_matrix_zech(cout, H, m, n);
		cout << endl;
		}
	F.retract_int_vec(f, 2, H, H_subfield, m * n, 0 /* verbose_level */);
	//field_reduction(F, f, m, n, H, H_subfield, TRUE, TRUE);
	if (f_vv) {
		cout << "after field reduction:" << endl;
		print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
		cout << endl;
		f.print_integer_matrix_zech(cout, H_subfield, m, n);
		cout << endl;
		}
	cout << "H_subfield:" << endl;
	print_integer_matrix_width(cout, H_subfield, m, n, n, 2);

	code = H_subfield;
	length = n;

	FREE_int(M);
	FREE_int(C);
	FREE_int(C_inv);
	FREE_int(H);

}


void coding_theory_domain::make_cyclic_code(int n, int q, int t,
		int *roots, int nb_roots, int f_poly, char *poly,
		int f_dual, char *fname, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int p, e, m, r, i;
	longinteger_object Qm1, Index;
	longinteger_domain D;
	number_theory_domain NT;
	file_io Fio;

	NT.factor_prime_power(q, p, e);
	if (f_v) {
		cout << "make_cyclic_code q=" << q << " p=" << q
				<< " e=" << e << " n=" << n << endl;
		for (i = 0; i < nb_roots; i++) {
			cout << roots[i] << " ";
		}
		cout << endl;
		if (f_dual) {
			cout << "dual code" << endl;
		}
	}
	m = NT.order_mod_p(q, n);
	if (f_v) {
		cout << "order mod q is m=" << m << endl;
	}
	D.create_qnm1(Qm1, q, m);

	// q = i_power_j(p, e);
	// GF(q)=GF(p^e) has n-th roots of unity
	D.integral_division_by_int(Qm1, n, Index, r);
	//b = (q - 1) / n;
	if (r != 0) {
		cout << "make_cyclic_code n does not divide q^m-1" << endl;
		exit(1);
	}
	if (f_v) {
		cout << "GF(" << q << "^" << m << ") has "
				<< n << "-th roots of unity" << endl;
		if (Index.is_one()) {
			cout << "this is a primitive code" << endl;
		}
		else {
			cout << "we take as " << n << "-th root \\beta = \\alpha^"
			<< Index << ", where \\alpha is a primitive element of "
					"the field" << endl;
		}
	}

	int j, degree, field_degree;
	int *taken;
	int *transversal, tl = 0;

	field_degree = m * e;
	degree = 0;
	taken = NEW_int(n);
	transversal = NEW_int(n);
	for (i = 0; i < n; i++) {
		taken[i] = FALSE;
	}


	for (i = 0; i < nb_roots; i++) {
		j = roots[i];
		if (taken[j]) {
			cout << q << "-cyclotomic coset of "
					<< j << " already taken" << endl;
			continue;
		}
		if (!taken[j]) {
			transversal[tl++] = j;
		}
		taken[j] = TRUE;
		degree++;
		if (f_v) {
			cout << q << "-cyclotomic coset of "
					<< j << " : " << j;
		}
		while (TRUE) {
			j = (q * j) % n;
			if (taken[j]) {
				break;
			}
			taken[j] = TRUE;
			degree++;
			if (f_v) {
				cout << "," << j;
			}
		}
		if (f_v) {
			cout << " degree=" << degree << endl;
		}
	}

	if (f_v) {
		cout << "transversal: ";
		for (i = 0; i < tl; i++) {
			cout << transversal[i] << " ";
		}
		cout << endl;
		cout << "exponents:";
		for (i = 0; i < n; i++) {
			if (!taken[i]) {
				continue;
			}
			cout << i << ", ";
		}
		cout << endl;
		cout << "degree=" << degree << endl;
	}

	if (f_dual) {
		for (i = 0; i < n; i++) {
			taken[i] = !taken[i];
		}
		degree = n - degree;
		if (f_v) {
			cout << "dually, exponents:";
			for (i = 0; i < n; i++) {
				if (!taken[i])
					continue;
				cout << i << ", ";
			}
			cout << endl;
			cout << "degree=" << degree << endl;
		}
	}

	finite_field Fp;
	unipoly_object M;
	unipoly_object beta, beta_i, c;

	if (f_v) {
		cout << "creating the finite field of order " << p << endl;
	}
	Fp.init(p, verbose_level - 1);

	unipoly_domain FpX(&Fp);
	FpX.create_object_by_rank_string(M,
			get_primitive_polynomial(p, field_degree, 0),
			verbose_level - 2);

	if (f_v) {
		cout << "choosing the following irreducible "
				"and primitive polynomial:" << endl;
		FpX.print_object(M, cout); cout << endl;
	}

	if (f_v) {
		cout << "creating unipoly_domain Fq modulo M" << endl;
	}
	unipoly_domain Fq(&Fp, M, verbose_level);  // Fq = Fp[X] modulo factor polynomial M
	if (f_vv) {
		cout << "extension field created" << endl;
	}

	Fq.create_object_by_rank(c, 0, __FILE__, __LINE__, verbose_level);
	Fq.create_object_by_rank(beta, p, __FILE__, __LINE__, verbose_level); // the element alpha
	Fq.create_object_by_rank(beta_i, 1, __FILE__, __LINE__, verbose_level);
	if (!Index.is_one()) {
		//Fq.power_int(beta, b);
		if (f_v) {
			cout << "\\alpha = ";
			Fq.print_object(beta, cout);
			cout << endl;
		}
		if (f_v) {
			cout << "before Fq.power_longinteger" << endl;
		}
		Fq.power_longinteger(beta, Index, verbose_level - 1);
		if (f_v) {
			cout << "\\beta = \\alpha^" << Index << " = ";
			Fq.print_object(beta, cout);
			cout << endl;
		}
	}
	else {
		if (f_v) {
			cout << "this is a primitive BCH code" << endl;
		}
	}

	if (f_v) {
		cout << "before allocating generator etc" << endl;
	}

	unipoly_object *generator = NEW_OBJECTS(unipoly_object, degree + 2);
	unipoly_object *tmp = NEW_OBJECTS(unipoly_object, degree + 1);
	unipoly_object *coeffs = NEW_OBJECTS(unipoly_object, 2);
	unipoly_object Pc, Pd;


	// create the polynomial X - a:
	if (f_v) {
		cout << "creating X-a" << endl;
	}
	for (i = 0; i < 2; i++) {
		if (i == 1) {
			Fq.create_object_by_rank(coeffs[i], 1, __FILE__, __LINE__, verbose_level);
		}
		else {
			Fq.create_object_by_rank(coeffs[i], 0, __FILE__, __LINE__, verbose_level);
		}
	}
	for (i = 0; i <= degree; i++) {
		if (f_v) {
			cout << "creating generator[" << i << "]" << endl;
		}
		Fq.create_object_by_rank(generator[i], 0, __FILE__, __LINE__, verbose_level);
		Fq.create_object_by_rank(tmp[i], 0, __FILE__, __LINE__, verbose_level);
	}
	if (f_v) {
		cout << "creating generator[0]" << endl;
	}
	Fq.create_object_by_rank(generator[0], 1, __FILE__, __LINE__, verbose_level);

	// now coeffs has degree 1
	// and generator has degree 0

	if (f_vv) {
		cout << "coeffs:" << endl;
		print_polynomial(Fq, 1, coeffs);
		cout << endl;
		cout << "generator:" << endl;
		print_polynomial(Fq, 0, generator);
		cout << endl;
	}

	if (f_v) {
		cout << "creating Pc" << endl;
	}
	Fq.create_object_by_rank(Pc, 0, __FILE__, __LINE__, verbose_level);
	if (f_v) {
		cout << "creating Pd" << endl;
	}
	Fq.create_object_by_rank(Pd, 0, __FILE__, __LINE__, verbose_level);

	r = 0;
	for (i = 0; i < n; i++) {
		if (f_v) {
			cout << "i=" << i << ", r=" << r << endl;
		}
		if (!taken[i]) {
			continue;
		}
		if (f_v) {
			cout << "working on root " << i << endl;
		}
		if (f_v) {
			cout << "before Fq.assign beta" << endl;
		}
		Fq.assign(beta, beta_i, verbose_level);
		if (f_v) {
			cout << "before Fq.power_int" << endl;
		}
		Fq.power_int(beta_i, i, verbose_level);
		if (f_v) {
			cout << "before Fq.negate" << endl;
		}
		Fq.negate(beta_i);
		if (f_v) {
			cout << "before Fq.assign beta_i" << endl;
		}
		Fq.assign(beta_i, coeffs[0], verbose_level);
		if (f_v) {
			cout << "root: " << i << " : ";
			Fq.print_object(beta_i, cout);
			//cout << " : ";
			//print_polynomial(Fq, 2, coeffs);
			cout << endl;
		}


		if (f_v) {
			cout << "before Fq.assign(generator[j], tmp[j])" << endl;
		}
		for (j = 0; j <= r; j++) {
			Fq.assign(generator[j], tmp[j], verbose_level);
		}

		//cout << "tmp:" << endl;
		//print_polynomial(Fq, r, tmp);
		//cout << endl;

		if (f_v) {
			cout << "before Fq.assign(tmp[j], generator[j + 1])" << endl;
		}
		for (j = 0; j <= r; j++) {
			Fq.assign(tmp[j], generator[j + 1], verbose_level);
			}
		Fq.delete_object(generator[0]);
		Fq.create_object_by_rank(generator[0], 0, __FILE__, __LINE__, verbose_level);

		//cout << "generator after shifting up:" << endl;
		//print_polynomial(Fq, r + 1, generator);
		//cout << endl;

		for (j = 0; j <= r; j++) {
			if (f_v) {
				cout << "j=" << j << endl;
			}
			if (f_v) {
				cout << "before Fq.mult(tmp[j], coeffs[0], Pc)" << endl;
			}
			Fq.mult(tmp[j], coeffs[0], Pc, verbose_level - 1);
			if (f_v) {
				cout << "before Fq.add()" << endl;
			}
			Fq.add(Pc, generator[j], Pd);
			if (f_v) {
				cout << "before Fq.assign()" << endl;
			}
			Fq.assign(Pd, generator[j], verbose_level);
		}
		r++;
		if (f_v) {
			cout << "r=" << r << endl;
		}
		if (f_v) {
			cout << "current polynomial: ";
			print_polynomial(Fq, r, generator);
			cout << endl;
		}

	}
	if (f_v) {
		cout << "The generator polynomial is: ";
		print_polynomial(Fq, r, generator);
		cout << endl;
	}

	Fq.delete_object(c);
	Fq.delete_object(beta);
	Fq.delete_object(beta_i);


	int *generator_subfield;
	int *Genma;

	if (f_v) {
		cout << "before field_reduction" << endl;
	}
	field_reduction(n, q, p, e, m, Fp, Fq, r,
		generator, generator_subfield, f_poly, poly, verbose_level);
	cout << "generator polynomial:" << endl;
	for (j = 0; j <= degree; j++) {
		cout << generator_subfield[j] << " ";
	}
	cout << endl;

	if (f_v) {
		cout << "before generator_matrix_cyclic_code" << endl;
	}
	generator_matrix_cyclic_code(n, degree, generator_subfield, Genma);
	cout << "generator matrix: " << endl;
	print_integer_matrix_width(cout, Genma, n - degree, n, n, 3);


	{
	ofstream fp(fname);
	int k = n - degree;


	fp << n << " " << k << " " << t << " " << q << endl;
	for (i = 0; i < k; i++) {
		for (j = 0; j < n; j++) {
			fp << Genma[i * n + j] << " ";
			}
		fp << endl;
		}
	fp << endl;
	}
	cout << "Written file " << fname << " of size "
			<< Fio.file_size(fname) << endl;

	latex_interface L;

	int k = n - degree;

	cout << "$$" << endl;
	cout << "\\left[" << endl;
	L.int_matrix_print_tex(cout, Genma, k, n);
	cout << "\\right]" << endl;
	cout << "$$" << endl;

	//cout << "before FREE_int(taken)" << endl;
	FREE_int(taken);
	//cout << "before FREE_int(transversal)" << endl;
	FREE_int(transversal);
	//cout << "before FREE_int(generator_subfield)" << endl;
	FREE_int(generator_subfield);
	//cout << "before FREE_int(Genma)" << endl;
	FREE_int(Genma);
	//cout << "before FREE_OBJECTS(generator)" << endl;
	for (i = 0; i <= degree; i++) {
		Fq.delete_object(generator[i]);
	}
	//FREE_OBJECTS(generator);
	cout << "before FREE_OBJECTS(tmp)" << endl;
	for (i = 0; i <= degree; i++) {
		Fq.delete_object(tmp[i]);
	}
	FREE_OBJECTS(tmp);
	//cout << "before FREE_OBJECTS(coeffs)" << endl;
	for (i = 0; i < 2; i++) {
		Fq.delete_object(coeffs[i]);
	}
	FREE_OBJECTS(coeffs);

}

void coding_theory_domain::generator_matrix_cyclic_code(int n,
		int degree, int *generator_polynomial, int *&M)
{
	int k = n - degree;
	int i, j;

	M = NEW_int(k * n);
	for (i = 0; i < k * n; i++) {
		M[i] = 0;
	}
	for (i = 0; i < k; i++) {
		for (j = 0; j <= degree; j++) {
			M[i * n + j + i] = generator_polynomial[j];
		}
	}
}

void coding_theory_domain::print_polynomial(unipoly_domain &Fq,
		int degree, unipoly_object *coeffs)
{
	int i, f_first = TRUE;

	for (i = 0; i <= degree; i++) {
		if (Fq.is_zero(coeffs[i])) {
			continue;
		}
		if (!f_first) {
			cout << " + ";
		}
		f_first = FALSE;
		if (!Fq.is_one(coeffs[i])) {
			cout << "(";
			Fq.print_object(coeffs[i], cout);
			cout << ") * ";
		}
		cout << " Z^" << i;
	}
}


void coding_theory_domain::field_reduction(int n, int q, int p, int e, int m,
	finite_field &Fp, unipoly_domain &Fq,
	int degree, unipoly_object *generator, int *&generator_subfield,
	int f_poly, char *poly,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	//int f_vv = (verbose_level >= 2);
	int r;
	longinteger_object Qm1, Index;
	longinteger_domain D;

	if (f_v) {
		cout << "coding_theory_domain::field_reduction" << endl;
	}
	D.create_qnm1(Qm1, q, m);

	D.integral_division_by_int(Qm1, q - 1, Index, r);

	if (r != 0) {
		cout << "coding_theory_domain::field_reduction q - 1 "
				"does not divide q^m - 1" << endl;
		exit(1);
	}
	if (f_v) {
		cout << "considering the subfield GF(" << q
				<< ") of GF(" << q << "^" << m << ")" << endl;
		cout << "subgroup index = " << Index << endl;
	}

	unipoly_object c, beta, beta_i;
	longinteger_object *beta_rk_table, rk;
	int i, j;


	beta_rk_table = NEW_OBJECTS(longinteger_object, q);

	Fq.create_object_by_rank(c, 0, __FILE__, __LINE__, verbose_level);
	Fq.create_object_by_rank(beta, p, __FILE__, __LINE__, verbose_level); // the element alpha
	Fq.create_object_by_rank(beta_i, 1, __FILE__, __LINE__, verbose_level);
	if (f_v) {
		cout << "\\alpha = ";
		Fq.print_object(beta, cout);
		cout << endl;
	}
	Fq.power_longinteger(beta, Index, verbose_level - 1);
	if (f_v) {
		cout << "\\beta = \\alpha^" << Index << " = ";
		Fq.print_object(beta, cout);
		cout << endl;
	}
	for (i = 1; i <= q - 1; i++) {
		Fq.assign(beta, beta_i, verbose_level);
		Fq.power_int(beta_i, i, 0);
		Fq.rank_longinteger(beta_i, beta_rk_table[i]);
		if (f_v) {
			cout << i << " : ";
			Fq.print_object(beta_i, cout);
			cout << " : " << beta_rk_table[i] << endl;
		}
	}

	generator_subfield = NEW_int(degree + 1);

	for (i = 0; i <= degree; i++) {
		Fq.rank_longinteger(generator[i], rk);
		if (f_v) {
			cout << "coefficient " << i << " has rk " << rk << endl;
		}
		if (rk.is_zero()) {
			generator_subfield[i] = 0;
			continue;
		}
		for (j = 1; j <= q - 1; j++) {
			if (D.compare(rk, beta_rk_table[j]) == 0) {
				generator_subfield[i] = j;
				break;
			}
		}
		if (j == q) {
			cout << "error, coefficient "
					"does not lie in the subfield" << endl;
			exit(1);
		}
	}
	if (f_v) {
		cout << "over the subfield, exponential notation:" << endl;
		for (i = 0; i <= degree; i++) {
			cout << " " << generator_subfield[i] << "Z^" << i;
		}
		cout << endl;
	}
	if (f_v) {
		cout << "i : beta^i" << endl;
	}
	for (i = 0; i <= e; i++) {
		Fq.assign(beta, beta_i, verbose_level);
		Fq.power_int(beta_i, i, 0);
		if (f_v) {
			cout << i << " : ";
			Fq.print_object(beta_i, cout);
			cout << endl;
		}
	}

	if (!f_poly) {
		goto the_end;
	}

	{
		finite_field fq;

		fq.init_override_polynomial(q, poly, verbose_level);
		cout << "q = " << q << " override polynomial = " << poly << endl;

		for (i = 0; i <= degree; i++) {
			j = generator_subfield[i];
			if (j == 0) {
				continue;
			}
			generator_subfield[i] = fq.alpha_power(j);
		}
		if (f_v) {
			cout << "over the subfield:" << endl;
			for (i = 0; i <= degree; i++) {
				j = generator_subfield[i];
				if (j == 0) {
					continue;
				}
				cout << " + " << j << " x^" << i;
			}
			cout << endl;
		}
	}

the_end:

	Fq.delete_object(c);
	Fq.delete_object(beta);
	Fq.delete_object(beta_i);
	FREE_OBJECTS(beta_rk_table);

	if (f_v) {
		cout << "coding_theory_domain::field_reduction done" << endl;
	}

}


}}

