/*
 * coding_theory_domain.cpp
 *
 *  Created on: Apr 21, 2019
 *      Author: betten
 */


#include "foundations.h"

using namespace std;



namespace orbiter {
namespace foundations {


coding_theory_domain::coding_theory_domain()
{

}

coding_theory_domain::~coding_theory_domain()
{

}





void coding_theory_domain::twisted_tensor_product_codes(
	int *&H_subfield, int &m, int &n,
	finite_field *F, finite_field *f,
	int f_construction_A, int f_hyperoval,
	int f_construction_B, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int index;
	int exponents[9];
	int *M;
	//int *H_subfield;
	int *C;
	int *C_inv;

	int q = f->q;
	int q2;
	int Q;
	//int m, n;
	int r;
	int beta, beta_q;
	int f_elements_exponential = TRUE;
	string symbol_for_print;
	string symbol_for_print_subfield;


	symbol_for_print.assign("\\alpha");
	symbol_for_print_subfield.assign("\\omega");


	if (f_v) {
		cout << "twisted_tensor_product_codes" << endl;
		cout << "f_construction_A=" << f_construction_A << endl;
		cout << "f_hyperoval=" << f_hyperoval << endl;
		cout << "f_construction_B=" << f_construction_B << endl;
		}


	q2 = q * q;
	Q = 0;
	if (f_construction_A) {
		Q = q2;
		}
	else if (f_construction_B) {
		Q = q2 * q;
		}
	index = (Q - 1) / (q - 1);

	if (Q != F->q) {
		cout << "twisted_tensor_product_codes Q != F->q" << endl;
		exit(1);
		}


	if (f_vv) {
		cout << "q = " << q << endl;
		cout << "Q = " << Q << endl;
		cout << "index = " << index << endl;
		}

#if 0
	F.init_override_polynomial(Q, override_poly_Q, verbose_level - 2);

	if (f_vv) {
		cout << "field of order " << Q << " initialized" << endl;
		}

	f.init_override_polynomial(q, override_poly_q, verbose_level - 2);

	if (f_vv) {
		cout << "field of order " << q << " initialized" << endl;
		cout << "index = " << index << endl;
		}
#endif

	F->compute_subfields(verbose_level - 2);


	create_matrix_M(
			M,
			F, f,
			m, n, beta, r, exponents,
			f_construction_A, f_hyperoval, f_construction_B,
			f_elements_exponential, symbol_for_print,
			verbose_level - 2);

	beta_q = F->power(beta, q);

	if (f_vv) {
		cout << "twisted_tensor_product_codes after create_matrix_M" << endl;
		cout << "m = " << m << endl;
		cout << "n = " << n << endl;
		cout << "Q = " << Q << endl;
		cout << "q2 = " << q2 << endl;
		cout << "beta = " << beta << endl;
		cout << "beta_q = " << beta_q << endl;
		cout << "Exponents: ";
		Orbiter->Int_vec.print(cout, exponents, m);
		cout << endl;
		}

	if (f_vv) {
		cout << "twisted_tensor_product_codes: M:" << endl;
		print_integer_matrix_width(cout, M, m, n, n, 2);

		F->latex_matrix(cout, f_elements_exponential, symbol_for_print, M, m, n);
		}




#if 0
	for (j = 0; j < n; j++) {
		PG_element_normalize(F, M + j, n, m);
		}
	cout << "column normalized M:" << endl;
	print_integer_matrix_width(cout, M, m, n, n, 2);
#endif




	C = NEW_int(m * m);
	C_inv = NEW_int(m * m);
	H_subfield = NEW_int(m * n);


	create_matrix_H_subfield(F, f,
		H_subfield, C, C_inv, M, m, n, beta, beta_q,
		f_elements_exponential, symbol_for_print, symbol_for_print_subfield,
		f_construction_A, f_hyperoval, f_construction_B,
		verbose_level - 2);


	if (f_v) {
		cout << "twisted_tensor_product_codes: after create_matrix_H_subfield" << endl;
		cout << "H_subfield:" << endl;
		print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
		f->latex_matrix(cout, f_elements_exponential, symbol_for_print_subfield, H_subfield, m, n);
		}

	FREE_int(M);
	FREE_int(C);
	FREE_int(C_inv);

}


void coding_theory_domain::create_matrix_M(
	int *&M,
	finite_field *F, finite_field *f,
	int &m, int &n, int &beta, int &r, int *exponents,
	int f_construction_A, int f_hyperoval, int f_construction_B,
	int f_elements_exponential, std::string &symbol_for_print,
	int verbose_level)
// int exponents[9]
{
	int f_v = (verbose_level >= 1);
	//int f_vv = (verbose_level >= 2);
	int i, j, t, q, Q, q2;

	q = f->q;
	q2 = q * q;


	if (f_construction_A) {

#if 0
		//q = 2; override_poly_Q = ""; override_poly = "";
		//q = 3; override_poly_Q = ""; override_poly = "";
		q = 4; override_poly_Q = "19"; override_poly = "7";
			// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
			// F_16 generated by X^4+X+1 = 19
			// F_4 generated by X^2+X+1 = 7
		//q = 5; override_poly_Q = "47"; override_poly = "";
			// F_625  generated by X^4 + X^3 + 3X + 2
			// F_25  generated by X^2 + 4X + 2  = 47
		//q = 7; override_poly_Q = ""; override_poly = "";
		//q = 8; override_poly_Q = "97"; override_poly = "11";
			// F_4096 generated by x^12+x^6+x^4+x+1
			// F_64 generated by X^6+X^5+1 = 97
			// F_8 generated by X^3+X+1 = 11
		//q = 9; override_poly_Q = ""; override_poly = "17";
#endif
		Q = q2;
		beta = q;
		m = 9;
		if (f_hyperoval) {
			n = Q + 2;
			}
		else {
			n = Q + 1;
			}
		r = 5;
		if (q == 4)
			r = 7;
		if (q == 3)
			r = 9;
		// 3 orbits of length 1: 0, q+1, 2q+2
		exponents[0] = 0;
		exponents[1] = q + 1;
		exponents[2] = 2 * q + 2;
		//orbit (q,1)
		exponents[3] = q;
		exponents[4] = 1;
		// orbit (2q, 2)
		exponents[5] = 2 * q;
		exponents[6] = 2;
		// orbit (2q+1, q+2)
		exponents[7] = 2 * q + 1;
		exponents[8] = q + 2;
		//exponents[0] = 0;
		//exponents[1] = q;
		//exponents[2] = 2 * q;
		//exponents[3] = 1;
		//exponents[4] = q + 1;
		//exponents[5] = 2 * q + 1;
		//exponents[6] = 2;
		//exponents[7] = q + 2;
		//exponents[8] = 2 * q + 2;
		}
	else if (f_construction_B) {

#if 0
		//q = 2; override_poly_Q = ""; override_poly = ""; r = 9;
		//q = 3; override_poly_Q = ""; override_poly = ""; r = 5;
		q = 4; override_poly_Q = ""; override_poly = "7"; r = 4;
			// F_4096  generated by X^8 + X^4 + X^3 + X^2 + 1 = 4096
		//q = 5; override_poly_Q = ""; override_poly = ""; r = 4;
		//q = 7; override_poly_Q = ""; override_poly = ""; r = 4;
#endif

		beta = q;
		Q = q2 * q;
		m = 8;
		n = Q + 1;

		exponents[0] = 0;
		exponents[1] = q2 + q + 1;
		exponents[2] = 1;
		exponents[3] = q;
		exponents[4] = q2;
		exponents[5] = q + 1;
		exponents[6] = q2 + q;
		exponents[7] = q2 + 1;
		//exponents[0] = 0;
		//exponents[1] = q;
		//exponents[2] = 1;
		//exponents[3] = q + 1;
		//exponents[4] = q2;
		//exponents[5] = q2 + q;
		//exponents[6] = q2 + 1;
		//exponents[7] = q2 + q + 1;
		}
	else {
		cout << "create_matrix_M(): please specify the construction using option -A or -B" << endl;
		exit(1);
		}


	// create matrix M:
	M = NEW_int(m * n);
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			M[i * n + j] = 0;
			}
		}
	for (t = 0; t < Q; t++) {
		for (i = 0; i < m; i++) {
			M[i * n + t] = F->power(t, exponents[i]);
			}
		}
	if (f_construction_A) {
		M[2 * n + Q] = 1;
		if (f_hyperoval)
			M[1 * n + Q + 1] = 1;
		}
	else if (f_construction_B) {
		M[1 * n + Q] = 1;
		}

	if (f_v) {
		cout << "M:" << endl;
		print_integer_matrix_width(cout, M, m, n, n, 2);

		F->latex_matrix(cout, f_elements_exponential,
				symbol_for_print, M, m, n);
		}


	if (f_v) {
		int *all_one, *col_sum;

		all_one = NEW_int(n);
		col_sum = NEW_int(m);
		for (i = 0; i < n; i++)
			all_one[i] = 1;
		F->mult_matrix_matrix(M, all_one, col_sum, m, n, 1,
				0 /* verbose_level */);
		cout << "overall col_sum:" << endl;
		print_integer_matrix_width(cout, col_sum, m, 1, 1, 2);
		FREE_int(all_one);
		FREE_int(col_sum);
		}


}



void coding_theory_domain::create_matrix_H_subfield(
	finite_field *F, finite_field*f,
	int *H_subfield, int *C, int *C_inv, int *M,
	int m, int n, int beta, int beta_q,
	int f_elements_exponential, std::string &symbol_for_print,
	std::string &symbol_for_print_subfield,
	int f_construction_A, int f_hyperoval, int f_construction_B,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int i, j;
	int q;
	//int *C;
	//int *C_inv;
	int *H;
	int *AA;

	q = f->q;

	// matrix C is zero:
	H = NEW_int(m * n);
	AA = NEW_int(m * m);
	for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++) {
			C[i * m + j] = 0;
			}
		}


	if (f_construction_A) {
		int nb_C_coeffs = 15;
		int k, aa;
		int C_coeffs[] = {
			0, 0, 1,
			1, 1, 1,
			2, 2, 1,
			3, 3, 1,
			3, 4, 1,
			4, 3, beta_q,
			4, 4, beta,
			5, 5, 1,
			5, 6, 1,
			6, 5, beta_q,
			6, 6, beta,
			7, 7, 1,
			7, 8, 1,
			8, 7, beta_q,
			8, 8, beta,
			};
		for (k = 0; k < nb_C_coeffs; k++) {
			i = C_coeffs[k * 3 + 0];
			j = C_coeffs[k * 3 + 1];
			aa = C_coeffs[k * 3 + 2];
			C[i * m + j] = aa;
			}
		}
	else if (f_construction_B) {
		int nb_C_coeffs = 20;
		int k, aa;
		int C_coeffs[] = {
			0, 0, 1,
			1, 1, 1,
			2, 2, 1,
			2, 3, 1,
			2, 4, 1,
			3, 2, beta,
			3, 3, beta_q,
			3, 4, F->beta_trinomial(q, beta, 1, 0, 0),
			4, 2, F->beta_trinomial(q, beta, 0, 0, 2),
			4, 3, F->beta_trinomial(q, beta, 0, 2, 0),
			4, 4, F->beta_trinomial(q, beta, 2, 0, 0),
			5, 5, 1,
			5, 6, 1,
			5, 7, 1,
			6, 5, F->beta_trinomial(q, beta, 0, 1, 1),
			6, 6, F->beta_trinomial(q, beta, 1, 1, 0),
			6, 7, F->beta_trinomial(q, beta, 1, 0, 1),
			7, 5, F->beta_trinomial(q, beta, 0, 2, 2),
			7, 6, F->beta_trinomial(q, beta, 2, 2, 0),
			7, 7, F->beta_trinomial(q, beta, 2, 0, 2),
			};
		for (k = 0; k < nb_C_coeffs; k++) {
			i = C_coeffs[k * 3 + 0];
			j = C_coeffs[k * 3 + 1];
			aa = C_coeffs[k * 3 + 2];
			C[i * m + j] = aa;
			}
		}


	if (f_v) {
		cout << "matrix C:" << endl;
		print_integer_matrix_width(cout, C, m, m, m, 2);
		F->latex_matrix(cout, f_elements_exponential,
				symbol_for_print, C, m, m);
		}


	F->invert_matrix(C, C_inv, m, 0 /* verbose_level */);

	if (f_vv) {
		cout << "C_inv:" << endl;
		print_integer_matrix_width(cout, C_inv, m, m, m, 2);
		}

	F->mult_matrix_matrix(C, C_inv, AA, m, m, m,
			0 /* verbose_level */);

	if (f_vv) {
		cout << "C * C_inv:" << endl;
		print_integer_matrix_width(cout, AA, m, m, m, 2);
		}


	F->mult_matrix_matrix(C, M, H, m, m, n,
			0 /* verbose_level */);

	if (f_v) {
		cout << "H = C * M:" << endl;
		print_integer_matrix_width(cout, H, m, n, n, 2);
		F->latex_matrix(cout, f_elements_exponential,
				symbol_for_print, H, m, n);
		}


#if 0
	rk = F.Gauss_int(M, FALSE /* f_special */, TRUE /* f_complete */, base_cols,
		FALSE /* f_P */, NULL, m /* m */, n /* n */, 0 /* Pn */,
		verbose_level - 2);
	cout << "has rank " << rk << endl;
#endif

	tt_field_reduction(*F, *f, m, n, H, H_subfield, verbose_level - 2);

	if (f_v) {
		cout << "H_subfield:" << endl;
		print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
		f->latex_matrix(cout, f_elements_exponential,
				symbol_for_print_subfield, H_subfield, m, n);
		}

	FREE_int(H);
	FREE_int(AA);
}



void coding_theory_domain::tt_field_reduction(
		finite_field &F, finite_field &f,
		int m, int n, int *M, int *MM, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int  i, j, a, z, b, c, Q, q;
	int index;

	Q = F.q;
	q = f.q;
	index = (Q - 1) / (q - 1);
	if (f_v) {
		cout << "field reduction, Q=" << Q
				<< " q=" << q << " index=" << index << endl;
		}
	if (f_vv) {
		cout << "before:" << endl;
		print_integer_matrix_width(cout, M, m, n, n, 2);
		//print_integer_matrix(cout, M, m, n);
		cout << endl;
		F.print_integer_matrix_zech(cout, M, m, n);
		cout << endl;
		}
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			a = M[i * n + j];
			if (a == 0) {
				c = 0;
				}
			else {
				if (f.e == 1) {
					if (a >= q) {
						cout << "field reduction: element does not "
								"lie in the subfield: " << a << endl;
						exit(1);
						}
					c = a;
					}
				else {
					z = F.log_alpha(a);
					b = z / index;
					if (b * index != z) {
						cout << "b * index != z" << endl;
						exit(1);
						}
					c = f.alpha_power(b);
					}
				}
			MM[i * n + j] = c;
			}
		}
	if (f_vv) {
		cout << "after:" << endl;
		print_integer_matrix_width(cout, MM, m, n, n, 2);
		//print_integer_matrix(cout, MM, m, n);
		cout << endl;
		f.print_integer_matrix_zech(cout, MM, m, n);
		cout << endl;
		}
}





//############################################### old stuff:

void coding_theory_domain::make_tensor_code_9dimensional_as_point_set(
	finite_field *F,
	int *&the_set, int &length,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_hyperoval = FALSE;
	const char *override_poly = "";
	const char *override_poly_Q = "";
	int i, t, q;
	int *code;

	if (f_v) {
		cout << "make_tensor_code_9dimensional_as_point_set" << endl;
		}
	q = F->q;
	if (q == 2) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
		}
	else if (q == 3) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
		}
	else if (q == 4) {
		override_poly_Q = "19"; override_poly = "7"; f_hyperoval = FALSE;
		// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
		// F_16 generated by X^4+X+1 = 19
		// F_4 generated by X^2+X+1 = 7
		}
	else if (q == 5) {
		override_poly_Q = "47"; override_poly = ""; f_hyperoval = FALSE;
		// F_625  generated by X^4 + X^3 + 3X + 2
		// F_25  generated by X^2 + 4X + 2  = 47
		}
	else if (q == 7) {
		override_poly_Q = ""; override_poly = ""; f_hyperoval = FALSE;
		}
	else if (q == 8) {
		override_poly_Q = "97"; override_poly = "11"; f_hyperoval = TRUE;
		// F_4096 generated by x^12+x^6+x^4+x+1
		// F_64 generated by X^6+X^5+1 = 97
		// F_8 generated by X^3+X+1 = 11
		}
	else if (q == 9) {
		override_poly_Q = ""; override_poly = "17"; f_hyperoval = FALSE;
	}

	string poly_Q, poly_q;

	poly_Q.assign(override_poly_Q);
	poly_q.assign(override_poly);

	make_tensor_code_9_dimensional(q, poly_Q, poly_q,
		f_hyperoval, code, length, verbose_level - 1);

	the_set = NEW_int(length);

	int pt[9], rk;

	for (t = 0; t < length; t++) {
		for (i = 0; i < 9; i++) {
			pt[i] = code[i * length + t];
			}
		F->PG_element_rank_modified(pt, 1, 9, rk);
		the_set[t] = rk;
		}
	FREE_int(code);
	if (f_v) {
		cout << "make_tensor_code_9dimensional_as_point_set done" << endl;
		cout << "created the set: ";
		Orbiter->Int_vec.print(cout, the_set, length);
		cout << endl;
		}
}

void coding_theory_domain::make_tensor_code_9_dimensional(int q,
	std::string &override_poly_Q, std::string &override_poly,
	int f_hyperoval,
	int *&code, int &length,
	int verbose_level)
{
	finite_field F;
	finite_field f;
	rank_checker rc;
	int exponents[9];
	int *M;
	int *C;
	int *C_inv;
	int *H;
	int *H_subfield;
	int index, Q, i, j, t, m, n, r, beta, beta_q;
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);


	if (f_v) {
		cout << "make_tensor_code_9_dimensional q=" << q << endl;
		}

	//q = 2; override_poly_Q = ""; override_poly = ""; int f_hyperoval = FALSE;
	//q = 3; override_poly_Q = ""; override_poly = ""; int f_hyperoval = FALSE;
	//q = 4; override_poly_Q = "19"; override_poly = "7"; int f_hyperoval = FALSE;
		// F_256  generated by X^8 + X^4 + X^3 + X^2 + 1
		// F_16 generated by X^4+X+1 = 19
		// F_4 generated by X^2+X+1 = 7
	//q = 5; override_poly_Q = "47"; override_poly = ""; int f_hyperoval = FALSE;
		// F_625  generated by X^4 + X^3 + 3X + 2
		// F_25  generated by X^2 + 4X + 2  = 47
	//q = 7; override_poly_Q = ""; override_poly = ""; int f_hyperoval = FALSE;
	//q = 8; override_poly_Q = "97"; override_poly = "11"; int f_hyperoval = TRUE;
		// F_4096 generated by x^12+x^6+x^4+x+1
		// F_64 generated by X^6+X^5+1 = 97
		// F_8 generated by X^3+X+1 = 11
	//q = 9; override_poly_Q = ""; override_poly = "17"; int f_hyperoval = FALSE;
	beta = q;
	Q = q * q;
	m = 9;
	if (f_hyperoval) {
		n = Q + 2;
		}
	else {
		n = Q + 1;
		}
	r = 5;
	if (q == 4)
		r = 7;
	if (q == 3)
		r = 9;
	exponents[0] = 0;
	exponents[1] = q + 1;
	exponents[2] = 2 * q + 2;
	exponents[3] = q;
	exponents[4] = 1;
	exponents[5] = 2 * q;
	exponents[6] = 2;
	exponents[7] = 2 * q + 1;
	exponents[8] = q + 2;
	//exponents[0] = 0;
	//exponents[1] = q;
	//exponents[2] = 2 * q;
	//exponents[3] = 1;
	//exponents[4] = q + 1;
	//exponents[5] = 2 * q + 1;
	//exponents[6] = 2;
	//exponents[7] = q + 2;
	//exponents[8] = 2 * q + 2;

	index = (Q - 1) / (q - 1);


	cout << "q = " << q << " override polynomial = " << override_poly << endl;
	cout << "Q = " << Q << endl;

	F.init_override_polynomial(Q, override_poly_Q, verbose_level);
	cout << "field of order " << Q << " initialized" << endl;
	beta_q = F.power(beta, q);
	f.init_override_polynomial(q, override_poly, verbose_level);
	cout << "field of order " << q << " initialized" << endl;
	cout << "n = " << n << endl;
	cout << "index = " << index << endl;
	cout << "beta = " << beta << endl;
	cout << "beta_q = " << beta_q << endl;
	F.compute_subfields(verbose_level - 3);

	M = NEW_int(m * n);
	C = NEW_int(m * m);
	C_inv = NEW_int(m * m);
	H = NEW_int(m * n);
	H_subfield = NEW_int(m * n);

	rc.init(&f, m, n, r + 1);

	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			M[i * n + j] = 0;
			}
		}
	for (i = 0; i < m; i++) {
		for (j = 0; j < m; j++) {
			C[i * m + j] = 0;
			}
		}
	for (t = 0; t < Q; t++) {
		for (i = 0; i < m; i++) {
			M[i * n + t] = F.power(t, exponents[i]);
			}
		}
	{
	M[2 * n + Q] = 1;
	if (f_hyperoval)
		M[1 * n + Q + 1] = 1;
	int nb_C_coeffs = 15;
	int k, aa;
	int C_coeffs[] = {
		0, 0, 1,
		1, 1, 1,
		2, 2, 1,
		3, 3, 1,
		3, 4, 1,
		4, 3, beta_q,
		4, 4, beta,
		5, 5, 1,
		5, 6, 1,
		6, 5, beta_q,
		6, 6, beta,
		7, 7, 1,
		7, 8, 1,
		8, 7, beta_q,
		8, 8, beta,
		};
	for (k = 0; k < nb_C_coeffs; k++) {
		i = C_coeffs[k * 3 + 0];
		j = C_coeffs[k * 3 + 1];
		aa = C_coeffs[k * 3 + 2];
		C[i * m + j] = aa;
		}
	}

	cout << "M:" << endl;
	print_integer_matrix_width(cout, M, m, n, n, 2);

	{
		int *all_one, *col_sum;

		all_one = NEW_int(n);
		col_sum = NEW_int(m);
		for (i = 0; i < n; i++)
			all_one[i] = 1;
		F.mult_matrix_matrix(M, all_one, col_sum, m, n, 1,
				0 /* verbose_level */);
		cout << "col_sum:" << endl;
		print_integer_matrix_width(cout, col_sum, m, 1, 1, 2);
		FREE_int(all_one);
		FREE_int(col_sum);
	}

#if 0
	for (j = 0; j < n; j++) {
		PG_element_normalize(F, M + j, n, m);
		}
	cout << "column normalized M:" << endl;
	print_integer_matrix_width(cout, M, m, n, n, 2);
#endif


	cout << "C:" << endl;
	print_integer_matrix_width(cout, C, m, m, m, 2);

	F.invert_matrix(C, C_inv, m, 0 /* verbose_level */);

	cout << "C_inv:" << endl;
	print_integer_matrix_width(cout, C_inv, m, m, m, 2);

	{
	int *AA;
	AA = NEW_int(m * m);
	F.mult_matrix_matrix(C, C_inv, AA, m, m, m,
			0 /* verbose_level */);
	cout << "C * C_inv:" << endl;
	print_integer_matrix_width(cout, AA, m, m, m, 2);
	FREE_int(AA);
	}

	F.mult_matrix_matrix(C, M, H, m, m, n,
			0 /* verbose_level */);
	cout << "H = C * M:" << endl;
	print_integer_matrix_width(cout, H, m, n, n, 2);


#if 0
	rk = F.Gauss_int(M, FALSE /* f_special */, TRUE /* f_complete */, base_cols,
		FALSE /* f_P */, NULL, m /* m */, n /* n */, 0 /* Pn */,
		FALSE, FALSE);
	cout << "has rank " << rk << endl;
#endif

	if (f_vv) {
		cout << "before field reduction:" << endl;
		print_integer_matrix_width(cout, H, m, n, n, 2);
		cout << endl;
		f.print_integer_matrix_zech(cout, H, m, n);
		cout << endl;
		}
	F.retract_int_vec(f, 2, H, H_subfield, m * n, 0 /* verbose_level */);
	//field_reduction(F, f, m, n, H, H_subfield, TRUE, TRUE);
	if (f_vv) {
		cout << "after field reduction:" << endl;
		print_integer_matrix_width(cout, H_subfield, m, n, n, 2);
		cout << endl;
		f.print_integer_matrix_zech(cout, H_subfield, m, n);
		cout << endl;
		}
	cout << "H_subfield:" << endl;
	print_integer_matrix_width(cout, H_subfield, m, n, n, 2);

	code = H_subfield;
	length = n;

	FREE_int(M);
	FREE_int(C);
	FREE_int(C_inv);
	FREE_int(H);

}


void coding_theory_domain::make_cyclic_code(int n, int q, int t,
		int *roots, int nb_roots, int f_poly, std::string &poly,
		int f_dual, char *fname, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int p, e, m, r, i;
	longinteger_object Qm1, Index;
	longinteger_domain D;
	number_theory_domain NT;
	file_io Fio;

	NT.factor_prime_power(q, p, e);
	if (f_v) {
		cout << "make_cyclic_code q=" << q << " p=" << q
				<< " e=" << e << " n=" << n << endl;
		for (i = 0; i < nb_roots; i++) {
			cout << roots[i] << " ";
		}
		cout << endl;
		if (f_dual) {
			cout << "dual code" << endl;
		}
	}
	m = NT.order_mod_p(q, n);
	if (f_v) {
		cout << "order mod q is m=" << m << endl;
	}
	D.create_qnm1(Qm1, q, m);

	// q = i_power_j(p, e);
	// GF(q)=GF(p^e) has n-th roots of unity
	D.integral_division_by_int(Qm1, n, Index, r);
	//b = (q - 1) / n;
	if (r != 0) {
		cout << "make_cyclic_code n does not divide q^m-1" << endl;
		exit(1);
	}
	if (f_v) {
		cout << "GF(" << q << "^" << m << ") has "
				<< n << "-th roots of unity" << endl;
		if (Index.is_one()) {
			cout << "this is a primitive code" << endl;
		}
		else {
			cout << "we take as " << n << "-th root \\beta = \\alpha^"
			<< Index << ", where \\alpha is a primitive element of "
					"the field" << endl;
		}
	}

	int j, degree, field_degree;
	int *taken;
	int *transversal, tl = 0;

	field_degree = m * e;
	degree = 0;
	taken = NEW_int(n);
	transversal = NEW_int(n);
	for (i = 0; i < n; i++) {
		taken[i] = FALSE;
	}


	for (i = 0; i < nb_roots; i++) {
		j = roots[i];
		if (taken[j]) {
			cout << q << "-cyclotomic coset of "
					<< j << " already taken" << endl;
			continue;
		}
		if (!taken[j]) {
			transversal[tl++] = j;
		}
		taken[j] = TRUE;
		degree++;
		if (f_v) {
			cout << q << "-cyclotomic coset of "
					<< j << " : " << j;
		}
		while (TRUE) {
			j = (q * j) % n;
			if (taken[j]) {
				break;
			}
			taken[j] = TRUE;
			degree++;
			if (f_v) {
				cout << "," << j;
			}
		}
		if (f_v) {
			cout << " degree=" << degree << endl;
		}
	}

	if (f_v) {
		cout << "transversal: ";
		for (i = 0; i < tl; i++) {
			cout << transversal[i] << " ";
		}
		cout << endl;
		cout << "exponents:";
		for (i = 0; i < n; i++) {
			if (!taken[i]) {
				continue;
			}
			cout << i << ", ";
		}
		cout << endl;
		cout << "degree=" << degree << endl;
	}

	if (f_dual) {
		for (i = 0; i < n; i++) {
			taken[i] = !taken[i];
		}
		degree = n - degree;
		if (f_v) {
			cout << "dually, exponents:";
			for (i = 0; i < n; i++) {
				if (!taken[i])
					continue;
				cout << i << ", ";
			}
			cout << endl;
			cout << "degree=" << degree << endl;
		}
	}

	finite_field Fp;
	unipoly_object M;
	unipoly_object beta, beta_i, c;

	if (f_v) {
		cout << "creating the finite field of order " << p << endl;
	}
	Fp.finite_field_init(p, verbose_level - 1);

	algebra_global Algebra;
	unipoly_domain FpX(&Fp);
	FpX.create_object_by_rank_string(M,
			Algebra.get_primitive_polynomial(p, field_degree, 0),
			verbose_level - 2);

	if (f_v) {
		cout << "choosing the following irreducible "
				"and primitive polynomial:" << endl;
		FpX.print_object(M, cout); cout << endl;
	}

	if (f_v) {
		cout << "creating unipoly_domain Fq modulo M" << endl;
	}
	unipoly_domain Fq(&Fp, M, verbose_level);  // Fq = Fp[X] modulo factor polynomial M
	if (f_vv) {
		cout << "extension field created" << endl;
	}

	Fq.create_object_by_rank(c, 0, __FILE__, __LINE__, verbose_level);
	Fq.create_object_by_rank(beta, p, __FILE__, __LINE__, verbose_level); // the element alpha
	Fq.create_object_by_rank(beta_i, 1, __FILE__, __LINE__, verbose_level);
	if (!Index.is_one()) {
		//Fq.power_int(beta, b);
		if (f_v) {
			cout << "\\alpha = ";
			Fq.print_object(beta, cout);
			cout << endl;
		}
		if (f_v) {
			cout << "before Fq.power_longinteger" << endl;
		}
		Fq.power_longinteger(beta, Index, verbose_level - 1);
		if (f_v) {
			cout << "\\beta = \\alpha^" << Index << " = ";
			Fq.print_object(beta, cout);
			cout << endl;
		}
	}
	else {
		if (f_v) {
			cout << "this is a primitive BCH code" << endl;
		}
	}

	if (f_v) {
		cout << "before allocating generator etc" << endl;
	}

	unipoly_object *generator = NEW_OBJECTS(unipoly_object, degree + 2);
	unipoly_object *tmp = NEW_OBJECTS(unipoly_object, degree + 1);
	unipoly_object *coeffs = NEW_OBJECTS(unipoly_object, 2);
	unipoly_object Pc, Pd;


	// create the polynomial X - a:
	if (f_v) {
		cout << "creating X-a" << endl;
	}
	for (i = 0; i < 2; i++) {
		if (i == 1) {
			Fq.create_object_by_rank(coeffs[i], 1, __FILE__, __LINE__, verbose_level);
		}
		else {
			Fq.create_object_by_rank(coeffs[i], 0, __FILE__, __LINE__, verbose_level);
		}
	}
	for (i = 0; i <= degree; i++) {
		if (f_v) {
			cout << "creating generator[" << i << "]" << endl;
		}
		Fq.create_object_by_rank(generator[i], 0, __FILE__, __LINE__, verbose_level);
		Fq.create_object_by_rank(tmp[i], 0, __FILE__, __LINE__, verbose_level);
	}
	if (f_v) {
		cout << "creating generator[0]" << endl;
	}
	Fq.create_object_by_rank(generator[0], 1, __FILE__, __LINE__, verbose_level);

	// now coeffs has degree 1
	// and generator has degree 0

	if (f_vv) {
		cout << "coeffs:" << endl;
		print_polynomial(Fq, 1, coeffs);
		cout << endl;
		cout << "generator:" << endl;
		print_polynomial(Fq, 0, generator);
		cout << endl;
	}

	if (f_v) {
		cout << "creating Pc" << endl;
	}
	Fq.create_object_by_rank(Pc, 0, __FILE__, __LINE__, verbose_level);
	if (f_v) {
		cout << "creating Pd" << endl;
	}
	Fq.create_object_by_rank(Pd, 0, __FILE__, __LINE__, verbose_level);

	r = 0;
	for (i = 0; i < n; i++) {
		if (f_v) {
			cout << "i=" << i << ", r=" << r << endl;
		}
		if (!taken[i]) {
			continue;
		}
		if (f_v) {
			cout << "working on root " << i << endl;
		}
		if (f_v) {
			cout << "before Fq.assign beta" << endl;
		}
		Fq.assign(beta, beta_i, verbose_level);
		if (f_v) {
			cout << "before Fq.power_int" << endl;
		}
		Fq.power_int(beta_i, i, verbose_level);
		if (f_v) {
			cout << "before Fq.negate" << endl;
		}
		Fq.negate(beta_i);
		if (f_v) {
			cout << "before Fq.assign beta_i" << endl;
		}
		Fq.assign(beta_i, coeffs[0], verbose_level);
		if (f_v) {
			cout << "root: " << i << " : ";
			Fq.print_object(beta_i, cout);
			//cout << " : ";
			//print_polynomial(Fq, 2, coeffs);
			cout << endl;
		}


		if (f_v) {
			cout << "before Fq.assign(generator[j], tmp[j])" << endl;
		}
		for (j = 0; j <= r; j++) {
			Fq.assign(generator[j], tmp[j], verbose_level);
		}

		//cout << "tmp:" << endl;
		//print_polynomial(Fq, r, tmp);
		//cout << endl;

		if (f_v) {
			cout << "before Fq.assign(tmp[j], generator[j + 1])" << endl;
		}
		for (j = 0; j <= r; j++) {
			Fq.assign(tmp[j], generator[j + 1], verbose_level);
			}
		Fq.delete_object(generator[0]);
		Fq.create_object_by_rank(generator[0], 0, __FILE__, __LINE__, verbose_level);

		//cout << "generator after shifting up:" << endl;
		//print_polynomial(Fq, r + 1, generator);
		//cout << endl;

		for (j = 0; j <= r; j++) {
			if (f_v) {
				cout << "j=" << j << endl;
			}
			if (f_v) {
				cout << "before Fq.mult(tmp[j], coeffs[0], Pc)" << endl;
			}
			Fq.mult(tmp[j], coeffs[0], Pc, verbose_level - 1);
			if (f_v) {
				cout << "before Fq.add()" << endl;
			}
			Fq.add(Pc, generator[j], Pd);
			if (f_v) {
				cout << "before Fq.assign()" << endl;
			}
			Fq.assign(Pd, generator[j], verbose_level);
		}
		r++;
		if (f_v) {
			cout << "r=" << r << endl;
		}
		if (f_v) {
			cout << "current polynomial: ";
			print_polynomial(Fq, r, generator);
			cout << endl;
		}

	}
	if (f_v) {
		cout << "The generator polynomial is: ";
		print_polynomial(Fq, r, generator);
		cout << endl;
	}

	Fq.delete_object(c);
	Fq.delete_object(beta);
	Fq.delete_object(beta_i);


	int *generator_subfield;
	int *Genma;

	if (f_v) {
		cout << "before field_reduction" << endl;
	}
	field_reduction(n, q, p, e, m, Fp, Fq, r,
		generator, generator_subfield, f_poly, poly, verbose_level);
	cout << "generator polynomial:" << endl;
	for (j = 0; j <= degree; j++) {
		cout << generator_subfield[j] << " ";
	}
	cout << endl;

	if (f_v) {
		cout << "before generator_matrix_cyclic_code" << endl;
	}
	generator_matrix_cyclic_code(n, degree, generator_subfield, Genma);
	cout << "generator matrix: " << endl;
	print_integer_matrix_width(cout, Genma, n - degree, n, n, 3);


	{
	ofstream fp(fname);
	int k = n - degree;


	fp << n << " " << k << " " << t << " " << q << endl;
	for (i = 0; i < k; i++) {
		for (j = 0; j < n; j++) {
			fp << Genma[i * n + j] << " ";
			}
		fp << endl;
		}
	fp << endl;
	}
	cout << "Written file " << fname << " of size "
			<< Fio.file_size(fname) << endl;

	latex_interface L;

	int k = n - degree;

	cout << "$$" << endl;
	cout << "\\left[" << endl;
	L.int_matrix_print_tex(cout, Genma, k, n);
	cout << "\\right]" << endl;
	cout << "$$" << endl;

	//cout << "before FREE_int(taken)" << endl;
	FREE_int(taken);
	//cout << "before FREE_int(transversal)" << endl;
	FREE_int(transversal);
	//cout << "before FREE_int(generator_subfield)" << endl;
	FREE_int(generator_subfield);
	//cout << "before FREE_int(Genma)" << endl;
	FREE_int(Genma);
	//cout << "before FREE_OBJECTS(generator)" << endl;
	for (i = 0; i <= degree; i++) {
		Fq.delete_object(generator[i]);
	}
	//FREE_OBJECTS(generator);
	cout << "before FREE_OBJECTS(tmp)" << endl;
	for (i = 0; i <= degree; i++) {
		Fq.delete_object(tmp[i]);
	}
	FREE_OBJECTS(tmp);
	//cout << "before FREE_OBJECTS(coeffs)" << endl;
	for (i = 0; i < 2; i++) {
		Fq.delete_object(coeffs[i]);
	}
	FREE_OBJECTS(coeffs);

}

void coding_theory_domain::generator_matrix_cyclic_code(int n,
		int degree, int *generator_polynomial, int *&M)
{
	int k = n - degree;
	int i, j;

	M = NEW_int(k * n);
	for (i = 0; i < k * n; i++) {
		M[i] = 0;
	}
	for (i = 0; i < k; i++) {
		for (j = 0; j <= degree; j++) {
			M[i * n + j + i] = generator_polynomial[j];
		}
	}
}

void coding_theory_domain::print_polynomial(unipoly_domain &Fq,
		int degree, unipoly_object *coeffs)
{
	int i, f_first = TRUE;

	for (i = 0; i <= degree; i++) {
		if (Fq.is_zero(coeffs[i])) {
			continue;
		}
		if (!f_first) {
			cout << " + ";
		}
		f_first = FALSE;
		if (!Fq.is_one(coeffs[i])) {
			cout << "(";
			Fq.print_object(coeffs[i], cout);
			cout << ") * ";
		}
		cout << " Z^" << i;
	}
}


void coding_theory_domain::field_reduction(int n, int q, int p, int e, int m,
	finite_field &Fp, unipoly_domain &Fq,
	int degree, unipoly_object *generator, int *&generator_subfield,
	int f_poly, std::string &poly,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	//int f_vv = (verbose_level >= 2);
	int r;
	longinteger_object Qm1, Index;
	longinteger_domain D;

	if (f_v) {
		cout << "coding_theory_domain::field_reduction" << endl;
	}
	D.create_qnm1(Qm1, q, m);

	D.integral_division_by_int(Qm1, q - 1, Index, r);

	if (r != 0) {
		cout << "coding_theory_domain::field_reduction q - 1 "
				"does not divide q^m - 1" << endl;
		exit(1);
	}
	if (f_v) {
		cout << "considering the subfield GF(" << q
				<< ") of GF(" << q << "^" << m << ")" << endl;
		cout << "subgroup index = " << Index << endl;
	}

	unipoly_object c, beta, beta_i;
	longinteger_object *beta_rk_table, rk;
	int i, j;


	beta_rk_table = NEW_OBJECTS(longinteger_object, q);

	Fq.create_object_by_rank(c, 0, __FILE__, __LINE__, verbose_level);
	Fq.create_object_by_rank(beta, p, __FILE__, __LINE__, verbose_level); // the element alpha
	Fq.create_object_by_rank(beta_i, 1, __FILE__, __LINE__, verbose_level);
	if (f_v) {
		cout << "\\alpha = ";
		Fq.print_object(beta, cout);
		cout << endl;
	}
	Fq.power_longinteger(beta, Index, verbose_level - 1);
	if (f_v) {
		cout << "\\beta = \\alpha^" << Index << " = ";
		Fq.print_object(beta, cout);
		cout << endl;
	}
	for (i = 1; i <= q - 1; i++) {
		Fq.assign(beta, beta_i, verbose_level);
		Fq.power_int(beta_i, i, 0);
		Fq.rank_longinteger(beta_i, beta_rk_table[i]);
		if (f_v) {
			cout << i << " : ";
			Fq.print_object(beta_i, cout);
			cout << " : " << beta_rk_table[i] << endl;
		}
	}

	generator_subfield = NEW_int(degree + 1);

	for (i = 0; i <= degree; i++) {
		Fq.rank_longinteger(generator[i], rk);
		if (f_v) {
			cout << "coefficient " << i << " has rk " << rk << endl;
		}
		if (rk.is_zero()) {
			generator_subfield[i] = 0;
			continue;
		}
		for (j = 1; j <= q - 1; j++) {
			if (D.compare(rk, beta_rk_table[j]) == 0) {
				generator_subfield[i] = j;
				break;
			}
		}
		if (j == q) {
			cout << "error, coefficient "
					"does not lie in the subfield" << endl;
			exit(1);
		}
	}
	if (f_v) {
		cout << "over the subfield, exponential notation:" << endl;
		for (i = 0; i <= degree; i++) {
			cout << " " << generator_subfield[i] << "Z^" << i;
		}
		cout << endl;
	}
	if (f_v) {
		cout << "i : beta^i" << endl;
	}
	for (i = 0; i <= e; i++) {
		Fq.assign(beta, beta_i, verbose_level);
		Fq.power_int(beta_i, i, 0);
		if (f_v) {
			cout << i << " : ";
			Fq.print_object(beta_i, cout);
			cout << endl;
		}
	}

	if (!f_poly) {
		goto the_end;
	}

	{
		finite_field fq;

		fq.init_override_polynomial(q, poly, verbose_level);
		cout << "q = " << q << " override polynomial = " << poly << endl;

		for (i = 0; i <= degree; i++) {
			j = generator_subfield[i];
			if (j == 0) {
				continue;
			}
			generator_subfield[i] = fq.alpha_power(j);
		}
		if (f_v) {
			cout << "over the subfield:" << endl;
			for (i = 0; i <= degree; i++) {
				j = generator_subfield[i];
				if (j == 0) {
					continue;
				}
				cout << " + " << j << " x^" << i;
			}
			cout << endl;
		}
	}

the_end:

	Fq.delete_object(c);
	Fq.delete_object(beta);
	Fq.delete_object(beta_i);
	FREE_OBJECTS(beta_rk_table);

	if (f_v) {
		cout << "coding_theory_domain::field_reduction done" << endl;
	}

}

void coding_theory_domain::make_mac_williams_equations(longinteger_object *&M,
		int n, int k, int q, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int i, j;
	combinatorics_domain Combi;

	if (f_v) {
		cout << "coding_theory_domain::make_mac_williams_equations" << endl;
	}
	M = NEW_OBJECTS(longinteger_object, (n + 1) * (n + 1));

	for (i = 0; i <= n; i++) {
		for (j = 0; j <= n; j++) {
			Combi.krawtchouk(M[i * (n + 1) + j], n, q, i, j);
		}
	}
	if (f_v) {
		cout << "coding_theory_domain::make_mac_williams_equations done" << endl;
	}
}

void coding_theory_domain::make_table_of_bounds(
		int n_max, int q, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int n, k, d_S, d_H, d_P, d_G;

	if (f_v) {
		cout << "coding_theory_domain::make_table_of_bounds" << endl;
	}
	vector<vector<long int>> Table;
	for (n = 2; n <= n_max; n++) {
		for (k = 1; k <= n; k++) {
			cout << "n=" << n << " k=" << k << " q=" << q << endl;
			d_S = singleton_bound_for_d(n, k, q, 0 /*verbose_level*/);
			cout << "d_S=" << d_S << endl;
			d_H = hamming_bound_for_d(n, k, q, 0 /*verbose_level*/);
			cout << "d_H=" << d_H << endl;
			d_P = plotkin_bound_for_d(n, k, q, 0 /*verbose_level*/);
			cout << "d_P=" << d_P << endl;
			d_G = griesmer_bound_for_d(n, k, q, 0 /*verbose_level*/);
			cout << "d_G=" << d_G << endl;
			vector<long int> entry;

			entry.push_back(n);
			entry.push_back(k);
			entry.push_back(q);
			entry.push_back(d_S);
			entry.push_back(d_H);
			entry.push_back(d_P);
			entry.push_back(d_G);
			Table.push_back(entry);
		}
	}
	long int *T;
	int N;
	int i, j;

	N = Table.size();

	T = NEW_lint(N * 7);
	for (i = 0; i < N; i++) {
		for (j = 0; j < 7; j++) {
			T[i * 7 + j] = Table[i][j];
		}
	}
	file_io Fio;
	std::string fname;
	char str[1000];

	sprintf(str, "_n%d_q%d", n_max, q);

	fname.assign("table_of_bounds");
	fname.append(str);
	fname.append(".csv");

	Fio.lint_matrix_write_csv(fname, T, N, 7);
	cout << "Written file " << fname << " of size " << Fio.file_size(fname) << endl;

	FREE_lint(T);


	if (f_v) {
		cout << "coding_theory_domain::make_table_of_bounds done" << endl;
	}
}



int coding_theory_domain::singleton_bound_for_d(
		int n, int k, int q, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int d;

	if (f_v) {
		cout << "coding_theory_domain::singleton_bound_for_d" << endl;
	}
	d = n - k + 1;
	return d;
}


int coding_theory_domain::hamming_bound_for_d(
		int n, int k, int q, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int e, d, t;
	longinteger_object qnmk, qm1, qm1_power, B, s, a, b;
	longinteger_domain D;
	combinatorics_domain Combi;


	if (f_v) {
		cout << "coding_theory_domain::hamming_bound_for_d" << endl;
	}
	qnmk.create(q, __FILE__, __LINE__);
	qm1.create(q - 1, __FILE__, __LINE__);
	D.power_int(qnmk, n - k);
	qm1_power.create(1, __FILE__, __LINE__);
	B.create(0, __FILE__, __LINE__);
	if (f_vv) {
		cout << "coding_theory_domain::hamming_bound_for_d: "
			"q=" << q << " n=" << n << " k=" << k << " "
			<< q << "^" << n - k << " = " << qnmk << endl;
	}
	for (e = 0; ; e++) {
		Combi.binomial(b, n, e, FALSE);
		D.mult(b, qm1_power, s);
		D.add(B, s, a);
		a.assign_to(B);
		if (D.compare(B, qnmk) == 1) {
			// now the size of the Ball of radius e is bigger than q^{n-m}
			t = e - 1;
			d = 2 * t + 2;
			if (f_vv) {
				cout << "B=" << B << " t=" << t << " d=" << d << endl;
			}
			break;
		}
		if (f_vv) {
			cout << "e=" << e << " B=" << B << " is OK" << endl;
		}
		D.mult(qm1_power, qm1, s);
		s.assign_to(qm1_power);
	}
	if (f_v) {
		cout << "coding_theory_domain::hamming_bound_for_d done" << endl;
	}
	return d;
}

int coding_theory_domain::plotkin_bound_for_d(
		int n, int k, int q, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int d;
	longinteger_object qkm1, qk, qm1, a, b, c, Q, R;
	longinteger_domain D;

	if (f_v) {
		cout << "coding_theory_domain::plotkin_bound_for_d" << endl;
	}

	// d \le \frac{n q^{k-1}}{q^k-1}

	qkm1.create(q, __FILE__, __LINE__);
	D.power_int(qkm1, k - 1);
	a.create(n, __FILE__, __LINE__);
	D.mult(a, qkm1, b);
		// now b = n q^{k-1}

	a.create(q - 1, __FILE__, __LINE__);
	D.mult(b, a, c);
		// now c = n q^{k-1} (q - 1)


	a.create(q, __FILE__, __LINE__);
	D.mult(a, qkm1, qk);
		// now qk = q^k

	a.create(-1, __FILE__, __LINE__);
	D.add(qk, a, b);
		// now b = 2^k - 1

	if (f_vv) {
		cout << "coding_theory_domain::plotkin_bound_for_d "
				"q=" << q << " n=" << n << " k=" << k << endl;
	}
	D.integral_division(c, b, Q, R, FALSE /* verbose_level */);
	d = Q.as_int();
	if (f_vv) {
		cout << c << " / " << b << " = " << d << endl;
	}
	if (f_v) {
		cout << "coding_theory_domain::plotkin_bound_for_d" << endl;
	}
	return d;
}

int coding_theory_domain::griesmer_bound_for_d(
		int n, int k, int q, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int d, n1;

	if (f_v) {
		cout << "coding_theory_domain::griesmer_bound_for_d" << endl;
	}
	for (d = 1; d <= n; d++) {
		n1 = griesmer_bound_for_n(k, d, q, verbose_level - 2);
		if (n1 > n) {
			d--;
			break;
			}
	}
	if (f_v) {
		cout << "coding_theory_domain::griesmer_bound_for_d done" << endl;
	}
	return d;
}

int coding_theory_domain::griesmer_bound_for_n(
		int k, int d, int q, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int i, n;
	longinteger_object qq, qi, d1, S, Q, R, one, a, b;
	longinteger_domain D;

	if (f_v) {
		cout << "coding_theory_domain::griesmer_bound_for_n" << endl;
	}
	one.create(1, __FILE__, __LINE__);
	d1.create(d, __FILE__, __LINE__);
	qq.create(q, __FILE__, __LINE__);
	qi.create(1, __FILE__, __LINE__);
	S.create(0, __FILE__, __LINE__);
	if (f_vv) {
		cout << "coding_theory_domain::griesmer_bound_for_n q=" << q
				<< " d=" << d << " k=" << k << endl;
	}
	for (i = 0; i < k; i++) {
		D.integral_division(d1, qi, Q, R, FALSE /* verbose_level */);
		if (!R.is_zero()) {
			D.add(Q, one, a);
			D.add(S, a, b);
		}
		else {
			D.add(S, Q, b);
		}
		b.assign_to(S);
		D.mult(qi, qq, a);
		a.assign_to(qi);
		if (f_vv) {
			cout << "i=" << i << " S=" << S << endl;
		}
	}
	n = S.as_int();
	if (f_v) {
		cout << "coding_theory_domain::griesmer_bound_for_n" << endl;
	}
	return n;
}

void coding_theory_domain::BCH_generator_polynomial(
	finite_field *F,
	unipoly_object &g, int n,
	int designed_distance, int &bose_distance,
	int &transversal_length, int *&transversal,
	longinteger_object *&rank_of_irreducibles,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int f_vvv = (verbose_level >= 3);
	int p = F->q;
	int e, i, j, r;
	longinteger_object q, b, m1, qm1;
	longinteger_domain D;
	number_theory_domain NT;

	if (f_v) {
		cout << "coding_theory_domain::BCH_generator_polynomial "
				"n=" << n << " designed_distance="
				<< designed_distance << " p=" << p << endl;
	}

	unipoly_domain FX(F);


	e = NT.order_mod_p(p, n);
	q.create(p, __FILE__, __LINE__);
	m1.create(-1, __FILE__, __LINE__);
	D.power_int(q, e);
	D.add(q, m1, qm1);
	// q = i_power_j(p, e);
	// GF(q)=GF(p^e) has n-th roots of unity
	D.integral_division_by_int(qm1, n, b, r);
	//b = (q - 1) / n;
	if (r != 0) {
		cout << "coding_theory_domain::BCH_generator_polynomial "
				"r != 0" << endl;
		exit(1);
	}
	if (f_v) {
		cout << "GF(" << q << ") = GF(" << p << "^" << e
				<< ") has " << n << "-th roots of unity" << endl;
		if (b.is_one()) {
			cout << "this is a primitive BCH code" << endl;
		}
		else {
			cout << "we take as " << n
			<< "-th root \\beta = \\alpha^" << b << ", where "
				"\\alpha is a primitive element of the field" << endl;
		}
	}

	algebra_global Algebra;
	unipoly_object m, M, h1, h2;

	FX.create_object_by_rank_string(m,
			Algebra.get_primitive_polynomial(p, e, 0), verbose_level - 2);

	FX.create_object_by_rank_string(M,
			Algebra.get_primitive_polynomial(p, e, 0), verbose_level - 2);

	FX.create_object_by_rank(g, 1, __FILE__, __LINE__, verbose_level);
	FX.create_object_by_rank(h1, 0, __FILE__, __LINE__, verbose_level);
	FX.create_object_by_rank(h2, 0, __FILE__, __LINE__, verbose_level);

	if (f_vv) {
		cout << "choosing the following irreducible "
				"and primitive polynomial:" << endl;
		FX.print_object(m, cout); cout << endl;
	}

	unipoly_domain Fq(F, M, verbose_level - 1);
	unipoly_object beta, beta_i, c;
	if (f_vvv) {
		cout << "extension field created" << endl;
	}
	Fq.create_object_by_rank(c, 0, __FILE__, __LINE__, verbose_level);
	Fq.create_object_by_rank(beta, p, __FILE__, __LINE__, verbose_level); // the primitive element alpha
	Fq.create_object_by_rank(beta_i, 1, __FILE__, __LINE__, verbose_level);
	if (!b.is_one()) {
		//Fq.power_int(beta, b, 0 /* verbose_level */);
		if (f_vvv) {
			cout << "\\alpha = ";
			Fq.print_object(beta, cout);
			cout << endl;
		}
		Fq.power_longinteger(beta, b, verbose_level - 1);
#if 0
		if (b.as_int() == 11) {
			for (i = 1; i <= b.as_int(); i++) {
				Fq.create_object_by_rank(beta, p); // the element alpha
				Fq.power_int(beta, i, 0 /* verbose_level */);
				cout << "\\alpha^" << i << " = ";
				Fq.print_object(beta, cout);
				cout << endl;
			}
		}
#endif
		if (f_vvv) {
			cout << "\\beta = \\alpha^" << b << " = ";
			Fq.print_object(beta, cout);
			cout << endl;
		}
	}
	else {
		if (f_vvv) {
			cout << "this is a primitive BCH code" << endl;
		}
	}

	// now beta is a primitive n-th root of unity

#if 0
	if (1 + designed_distance - 2 >= q - 1) {
		cout << "coding_theory_domain::BCH_generator_polynomial "
				"1 + designed_distance - 2 >= q - 1" << endl;
		exit(1);
	}
#endif

	longinteger_object *beta_rk_table =
			NEW_OBJECTS(longinteger_object, n);
	longinteger_object ai, bi;


	for (i = 0; i < n; i++) {
		Fq.rank_longinteger(beta_i, beta_rk_table[i]);

		if (f_vvv) {
			cout << "\\beta^" << i << " = ";
			Fq.print_object(beta_i, cout);
			cout << " = " << beta_rk_table[i] << endl;
		}
		Fq.mult(beta, beta_i, c, verbose_level - 1);
		Fq.assign(c, beta_i, verbose_level);
	}
	if (f_vvv) {
		for (i = 0; i < n; i++) {
			cout << "\\beta^" << i << " = ";
			//Fq.print_object(beta_i, cout);
			cout << " = " << beta_rk_table[i] << endl;
		}
	}


	int *chosen = NEW_int(n);
	//int *transversal = NEW_int(n);
	//int transversal_length = 0, i0;
	int i0;

	transversal = NEW_int(n);
	transversal_length = 0;

	for (i = 0; i < n; i++) {
		chosen[i] = FALSE;
	}

	for (i = 1; i <= 1 + designed_distance - 2; i++) {
		Fq.mult(beta, beta_i, c, verbose_level - 1);
		Fq.assign(c, beta_i, verbose_level);

		Fq.rank_longinteger(beta_i, ai);
		if (f_vvv) {
			cout << "\\beta^" << i << " = ";
			Fq.print_object(beta_i, cout);
			cout << " = " << ai << endl;
		}
		if (chosen[i]) {
			continue;
		}

		transversal[transversal_length++] = i;
		if (f_vv || f_v) {
			cout << "orbit of conjugate elements "
					"(in powers of \\beta):" << endl;
			cout << "{ ";
		}
		ai.assign_to(bi);
		i0 = i;
		do {
			chosen[i] = TRUE;
			Fq.create_object_by_rank_longinteger(c, bi, __FILE__, __LINE__, verbose_level);
			if (f_vvv) {
				cout << bi << " = ";
				Fq.print_object(c, cout);
			}
			else if (f_v) {
				cout << i << " ";
			}
			//power_coefficients(c, p);
			Fq.power_int(c, p, 0 /* verbose_level */);
			Fq.rank_longinteger(c, bi);
			for (j = 0; j < n; j++) {
				if (D.compare(bi, beta_rk_table[j]) == 0) {
					break;
				}
			}
			if (j == n) {
				cout << "couldn't find rank in the table (A)" << endl;
				exit(1);
			}
			if (f_vv) {
				cout << " is \\beta^" << j << endl;
			}
			i = j;
		} while (j != i0);
		if (f_vv || f_v) {
			cout << "}" << endl;
		}
	}

	// compute the bose_distance:
	Fq.create_object_by_rank(beta_i, 1, __FILE__, __LINE__, verbose_level);
	for (i = 1; ; i++) {
		Fq.mult(beta, beta_i, c, verbose_level - 1);
		FX.assign(c, beta_i, verbose_level);
		Fq.rank_longinteger(beta_i, ai);
		for (j = 0; j < n; j++) {
			if (D.compare(ai, beta_rk_table[j]) == 0) {
				break;
			}
		}
		if (j == n) {
			cout << "couldn't find rank in the table (B)" << endl;
			exit(1);
		}
		if (!chosen[j]) {
			break;
		}
	}
	bose_distance = i;

	longinteger_object rk;

	if (f_vv || f_v) {
		cout << "taking the minimum polynomials of { ";
		for (i = 0; i < transversal_length; i++) {
			cout << transversal[i] << " ";
		}
		cout << "}" << endl;
	}

	rank_of_irreducibles = NEW_OBJECTS(
			longinteger_object, transversal_length);

	for (i = 0; i < transversal_length; i++) {

		// minimum_polynomial(h1, ai, p, f_vv);
		Fq.minimum_polynomial_factorring_longinteger(
				beta_rk_table[transversal[i]], rk, p, f_vv);
		FX.create_object_by_rank_longinteger(h1, rk, __FILE__, __LINE__, verbose_level - 2);
		if (f_vv) {
			cout << "minimal polynomial of \\beta^"
					<< transversal[i] << " is ";
			FX.print_object(h1, cout);
			cout << " of rank " << rk << endl;
		}
		rk.assign_to(rank_of_irreducibles[i]);
		FX.mult(g, h1, h2, verbose_level - 1);
		FX.assign(h2, g, verbose_level);
	}

	Fq.delete_object(c);
	Fq.delete_object(beta);
	Fq.delete_object(beta_i);
	FX.delete_object(h1);
	FX.delete_object(h2);
	FX.delete_object(m);
	FREE_OBJECTS(beta_rk_table);
	FREE_int(chosen);
	//delete [] transversal;
	if (f_v) {
		cout << "BCH(" << n << "," << p << ","
				<< designed_distance << ") = ";
		FX.print_object(g, cout);
		cout << " bose_distance = " << bose_distance << endl;
	}
}

void coding_theory_domain::compute_generator_matrix(
		unipoly_object a, int *&genma, int n, int &k,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int *r = (int *) a;
	int d = r[0];
	int *A = r + 1;

	int i, j, x;

	k = n - d;
	if (k < 0) {
		cout << "coding_theory_domain::compute_generator_matrix "
				"k < 0" << endl;
		exit(1);
	}
	genma = NEW_int(k * n);
	for (i = 0; i < k * n; i++) {
		genma[i] = 0;
	}
	for (i = 0; i < k; i++) {
		for (j = 0; j <= d; j++) {
			x = A[j];
			genma[i * n + i + j] = x;
		}
	}
	if (f_v) {
		cout << "generator matrix:" << endl;
		print_integer_matrix(cout, genma, k, n);
	}
}


void coding_theory_domain::do_make_macwilliams_system(
		int q, int n, int k, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	coding_theory_domain C;
	longinteger_object *M;
	int i, j;

	if (f_v) {
		cout << "interface_coding_theory::do_make_macwilliams_system" << endl;
	}

	C.make_mac_williams_equations(M, n, k, q, verbose_level);

	cout << "\\begin{array}{r|*{" << n << "}{r}}" << endl;
	for (i = 0; i <= n; i++) {
		for (j = 0; j <= n; j++) {
			cout << M[i * (n + 1) + j];
			if (j < n) {
				cout << " & ";
			}
		}
		cout << "\\\\" << endl;
	}
	cout << "\\end{array}" << endl;

	cout << "[";
	for (i = 0; i <= n; i++) {
		cout << "[";
		for (j = 0; j <= n; j++) {
			cout << M[i * (n + 1) + j];
			if (j < n) {
				cout << ",";
			}
		}
		cout << "]";
		if (i < n) {
			cout << ",";
		}
	}
	cout << "]" << endl;


	if (f_v) {
		cout << "coding_theory_domain::do_make_macwilliams_system done" << endl;
	}
}


void coding_theory_domain::make_BCH_codes(int n, int q, int t, int b, int f_dual, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "coding_theory_domain::make_BCH_codes" << endl;
	}

	char fname[1000];
	number_theory_domain NT;
	int *roots;
	int nb_roots;
	int i, j;

	roots = NEW_int(t - 1);
	nb_roots = t - 1;
	for (i = 0; i < t - 1; i++) {
		j = NT.mod(b + i, n);
		roots[i] = j;
		}
	snprintf(fname, 1000, "BCH_%d_%d.txt", n, t);

	cout << "roots: ";
	Orbiter->Int_vec.print(cout, roots, nb_roots);
	cout << endl;

	coding_theory_domain Codes;

	string dummy;

	dummy.assign("");

	Codes.make_cyclic_code(n, q, t, roots, nb_roots,
			FALSE /*f_poly*/, dummy /*poly*/, f_dual,
			fname, verbose_level);

	FREE_int(roots);

	if (f_v) {
		cout << "coding_theory_domain::make_BCH_codes done" << endl;
	}
}

void coding_theory_domain::make_Hamming_graph_and_write_file(int n, int q,
		int f_projective, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	int width, height;
	int *v;
	int *w;
	int *Table;
	//int *Adj = NULL;
	geometry_global Gg;
	finite_field *F = NULL;

	if (f_v) {
		cout << "coding_theory_domain::make_Hamming_graph_and_write_file" << endl;
	}

	v = NEW_int(n);
	w = NEW_int(n);

	if (f_projective) {
		width = height = Gg.nb_PG_elements(n - 1, q);
		F = NEW_OBJECT(finite_field);
		F->finite_field_init(q, 0 /* verbose_level */);
	}
	else {
		width = height = Gg.nb_AG_elements(n, q);
	}

#if 0
	int N;
	N = width;
	if (f_graph) {
		Adj = NEW_int(N * N);
		int_vec_zero(Adj, N * N);
	}
#endif

	cout << "width=" << width << endl;

	int i, j, d, h;

	Table = NEW_int(height * width);
	for (i = 0; i < height; i++) {

		if (f_projective) {
			F->PG_element_unrank_modified(v, 1 /*stride*/, n, i);
		}
		else {
			Gg.AG_element_unrank(q, v, 1, n, i);
		}

		for (j = 0; j < width; j++) {

			if (f_projective) {
				F->PG_element_unrank_modified(w, 1 /*stride*/, n, j);
			}
			else {
				Gg.AG_element_unrank(q, w, 1, n, j);
			}

			d = 0;
			for (h = 0; h < n; h++) {
				if (v[h] != w[h]) {
					d++;
				}
			}

#if 0
			if (f_graph && d == 1) {
				Adj[i * N + j] = 1;
			}
#endif

			Table[i * width + j] = d;

		}
	}

	string fname;
	char str[1000];
	file_io Fio;

	sprintf(str, "Hamming_n%d_q%d.csv", n, q);
	fname.assign(str);

	Fio.int_matrix_write_csv(fname, Table, height, width);

	if (f_v) {
		cout << "Written file " << fname << " of size " << Fio.file_size(fname) << endl;
	}

	if (f_v) {
		cout << "coding_theory_domain::make_Hamming_graph_and_write_file" << endl;
	}

}


void coding_theory_domain::compute_and_print_projective_weights(
		ostream &ost, finite_field *F, int *M, int n, int k)
{
	int i;
	int *weights;

	weights = NEW_int(n + 1);
	code_projective_weight_enumerator(F, n, k,
		M, // [k * n]
		weights, // [n + 1]
		0 /*verbose_level*/);


	ost << "projective weights: " << endl;
	for (i = 0; i <= n; i++) {
		if (weights[i] == 0) {
			continue;
		}
		ost << i << " : " << weights[i] << endl;
	}
	FREE_int(weights);
}

int coding_theory_domain::code_minimum_distance(finite_field *F, int n, int k,
		int *code, int verbose_level)
	// code[k * n]
{
	int f_v = (verbose_level >= 1);
	int *weight_enumerator;
	int i;

	if (f_v) {
		cout << "coding_theory_domain::code_minimum_distance" << endl;
	}
	weight_enumerator = NEW_int(n + 1);
	Orbiter->Int_vec.zero(weight_enumerator, n + 1);
	code_weight_enumerator_fast(F, n, k,
		code, // [k * n]
		weight_enumerator, // [n + 1]
		verbose_level);
	for (i = 1; i <= n; i++) {
		if (weight_enumerator[i]) {
			break;
		}
	}
	if (i == n + 1) {
		cout << "coding_theory_domain::code_minimum_distance "
				"the minimum weight is undefined" << endl;
		exit(1);
	}
	FREE_int(weight_enumerator);
	return i;
}

void coding_theory_domain::codewords_affine(finite_field *F, int n, int k,
	int *code, // [k * n]
	int *codewords, // q^k
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	long int N, h, rk;
	int *msg;
	int *word;
	geometry_global Gg;

	if (f_v) {
		cout << "coding_theory_domain::codewords_affine" << endl;
	}
	N = Gg.nb_AG_elements(k, F->q);
	if (f_v) {
		cout << N << " messages" << endl;
	}
	msg = NEW_int(k);
	word = NEW_int(n);

	for (h = 0; h < N; h++) {
		Gg.AG_element_unrank(F->q, msg, 1, k, h);
		F->mult_vector_from_the_left(msg, code, word, k, n);
		rk = Gg.AG_element_rank(F->q, word, 1, n);
		codewords[h] = rk;
	}
	FREE_int(msg);
	FREE_int(word);
	if (f_v) {
		cout << "coding_theory_domain::codewords_affine done" << endl;
	}
}

void coding_theory_domain::code_projective_weight_enumerator(finite_field *F,
	int n, int k,
	int *code, // [k * n]
	int *weight_enumerator, // [n + 1]
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 1);
	int N, h, wt, i;
	int *msg;
	int *word;
	int t0, t1, dt;
	geometry_global Gg;
	os_interface Os;

	t0 = Os.os_ticks();

	if (f_v) {
		cout << "coding_theory_domain::code_projective_weight_enumerator" << endl;
	}
	N = Gg.nb_AG_elements(k, F->q);
	if (f_v) {
		cout << N << " messages" << endl;
	}
	msg = NEW_int(k);
	word = NEW_int(n);

	Orbiter->Int_vec.zero(weight_enumerator, n + 1);

	for (h = 0; h < N; h++) {
		if (f_v && (h % ONE_MILLION) == 0) {
			t1 = Os.os_ticks();
			dt = t1 - t0;
			cout << setw(10) << h << " / " << setw(10) << N << " : ";
			Os.time_check_delta(cout, dt);
			cout << endl;
			if (f_vv) {
				cout << "so far, the weight enumerator is:" << endl;
				for (i = 0; i <= n; i++) {
					if (weight_enumerator[i] == 0)
						continue;
					cout << setw(5) << i << " : " << setw(10)
							<< weight_enumerator[i] << endl;
				}
			}
		}
		Gg.AG_element_unrank(F->q, msg, 1, k, h);
		F->mult_vector_from_the_left(msg, code, word, k, n);
		wt = 0;
		for (i = 0; i < n; i++) {
			if (word[i]) {
				wt++;
			}
		}
		weight_enumerator[wt]++;
	}
	if (f_v) {
		cout << "the weight enumerator is:" << endl;
		for (i = 0; i <= n; i++) {
			if (weight_enumerator[i] == 0) {
				continue;
			}
			cout << setw(5) << i << " : " << setw(10)
					<< weight_enumerator[i] << endl;
		}
	}


	FREE_int(msg);
	FREE_int(word);
}

void coding_theory_domain::code_weight_enumerator(finite_field *F,
	int n, int k,
	int *code, // [k * n]
	int *weight_enumerator, // [n + 1]
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 1);
	int N, h, wt, i;
	int *msg;
	int *word;
	int t0, t1, dt;
	geometry_global Gg;
	os_interface Os;

	t0 = Os.os_ticks();

	if (f_v) {
		cout << "coding_theory_domain::code_weight_enumerator" << endl;
	}
	N = Gg.nb_AG_elements(k, F->q);
	if (f_v) {
		cout << N << " messages" << endl;
	}
	msg = NEW_int(k);
	word = NEW_int(n);

	Orbiter->Int_vec.zero(weight_enumerator, n + 1);

	for (h = 0; h < N; h++) {
		if ((h % ONE_MILLION) == 0) {
			t1 = Os.os_ticks();
			dt = t1 - t0;
			cout << setw(10) << h << " / " << setw(10) << N << " : ";
			Os.time_check_delta(cout, dt);
			cout << endl;
			if (f_vv) {
				cout << "so far, the weight enumerator is:" << endl;
				for (i = 0; i <= n; i++) {
					if (weight_enumerator[i] == 0)
						continue;
					cout << setw(5) << i << " : " << setw(10)
							<< weight_enumerator[i] << endl;
				}
			}
		}
		Gg.AG_element_unrank(F->q, msg, 1, k, h);
		F->mult_vector_from_the_left(msg, code, word, k, n);
		wt = 0;
		for (i = 0; i < n; i++) {
			if (word[i]) {
				wt++;
			}
		}
		weight_enumerator[wt]++;
		}
	if (f_v) {
		cout << "the weight enumerator is:" << endl;
		for (i = 0; i <= n; i++) {
			if (weight_enumerator[i] == 0) {
				continue;
			}
			cout << setw(5) << i << " : " << setw(10)
					<< weight_enumerator[i] << endl;
		}
	}


	FREE_int(msg);
	FREE_int(word);
}


void coding_theory_domain::code_weight_enumerator_fast(finite_field *F,
		int n, int k,
	int *code, // [k * n]
	int *weight_enumerator, // [n + 1]
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int N, h, wt, i;
	int *msg;
	int *word;
	int t0, t1, dt;
	geometry_global Gg;
	os_interface Os;

	t0 = Os.os_ticks();

	if (f_v) {
		cout << "coding_theory_domain::code_weight_enumerator_fast" << endl;
	}
	N = Gg.nb_PG_elements(k - 1, F->q);
	if (f_v) {
		cout << N << " projective messages" << endl;
	}
	msg = NEW_int(k);
	word = NEW_int(n);


	Orbiter->Int_vec.zero(weight_enumerator, n + 1);

	for (h = 0; h < N; h++) {
		if (((h % ONE_MILLION) == 0) && h) {
			t1 = Os.os_ticks();
			dt = t1 - t0;
			cout << setw(10) << h << " / " << setw(10) << N << " : ";
			Os.time_check_delta(cout, dt);
			cout << endl;
			if (f_vv) {
				cout << "so far, the weight enumerator is:" << endl;
				for (i = 0; i <= n; i++) {
					if (weight_enumerator[i] == 0)
						continue;
					cout << setw(5) << i << " : " << setw(10)
							<< (F->q - 1) * weight_enumerator[i] << endl;
				}
			}
		}
		F->PG_element_unrank_modified(msg, 1, k, h);
		//AG_element_unrank(q, msg, 1, k, h);
		F->mult_vector_from_the_left(msg, code, word, k, n);
		wt = 0;
		for (i = 0; i < n; i++) {
			if (word[i]) {
				wt++;
			}
		}
		weight_enumerator[wt]++;
		if (f_vv) {
			cout << h << " / " << N << " msg: ";
			Orbiter->Int_vec.print(cout, msg, k);
			cout << " codeword ";
			Orbiter->Int_vec.print(cout, word, n);
			cout << " weight " << wt << endl;
		}
	}
	weight_enumerator[0] = 1;
	for (i = 1; i <= n; i++) {
		weight_enumerator[i] *= F->q - 1;
	}
	if (f_v) {
		cout << "the weight enumerator is:" << endl;
		for (i = 0; i <= n; i++) {
			if (weight_enumerator[i] == 0) {
				continue;
			}
			cout << setw(5) << i << " : " << setw(10)
					<< weight_enumerator[i] << endl;
		}
	}


	FREE_int(msg);
	FREE_int(word);
}

void coding_theory_domain::code_projective_weights(finite_field *F,
	int n, int k,
	int *code, // [k * n]
	int *&weights, // will be allocated [N]
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	//int f_vv = (verbose_level >= 1);
	int N, h, wt, i;
	int *msg;
	int *word;
	int t0, t1, dt;
	geometry_global Gg;
	os_interface Os;

	t0 = Os.os_ticks();

	if (f_v) {
		cout << "coding_theory_domain::code_projective_weights" << endl;
	}
	N = Gg.nb_PG_elements(k - 1, F->q);
	if (f_v) {
		cout << N << " projective messages" << endl;
	}
	weights = NEW_int(N);
	msg = NEW_int(k);
	word = NEW_int(n);

	for (h = 0; h < N; h++) {
		if ((h % ONE_MILLION) == 0) {
			t1 = Os.os_ticks();
			dt = t1 - t0;
			cout << setw(10) << h << " / " << setw(10) << N << " : ";
			Os.time_check_delta(cout, dt);
			cout << endl;
		}
		F->PG_element_unrank_modified(msg, 1, k, h);
		//AG_element_unrank(q, msg, 1, k, h);
		F->mult_vector_from_the_left(msg, code, word, k, n);
		wt = 0;
		for (i = 0; i < n; i++) {
			if (word[i]) {
				wt++;
			}
		}
		weights[h] = wt;
	}
	if (f_v) {
		cout << "coding_theory_domain::code_projective_weights done" << endl;
	}


	FREE_int(msg);
	FREE_int(word);
}

void coding_theory_domain::mac_williams_equations(longinteger_object *&M, int n, int k, int q)
{
	combinatorics_domain D;
	int i, j;

	M = NEW_OBJECTS(longinteger_object, (n + 1) * (n + 1));

	for (i = 0; i <= n; i++) {
		for (j = 0; j <= n; j++) {
			D.krawtchouk(M[i * (n + 1) + j], n, q, i, j);
		}
	}
}

void coding_theory_domain::determine_weight_enumerator()
{
	int n = 19, k = 7, q = 2;
	longinteger_domain D;
	longinteger_object *M, *A1, *A2, qk;
	int i;

	qk.create(q, __FILE__, __LINE__);
	D.power_int(qk, k);
	cout << q << "^" << k << " = " << qk << endl;

	mac_williams_equations(M, n, k, q);

	D.matrix_print_tex(cout, M, n + 1, n + 1);

	A1 = NEW_OBJECTS(longinteger_object, n + 1);
	A2 = NEW_OBJECTS(longinteger_object, n + 1);
	for (i = 0; i <= n; i++) {
		A1[i].create(0, __FILE__, __LINE__);
	}
	A1[0].create(1, __FILE__, __LINE__);
	A1[8].create(78, __FILE__, __LINE__);
	A1[12].create(48, __FILE__, __LINE__);
	A1[16].create(1, __FILE__, __LINE__);
	D.matrix_print_tex(cout, A1, n + 1, 1);

	D.matrix_product(M, A1, A2, n + 1, n + 1, 1);
	D.matrix_print_tex(cout, A2, n + 1, 1);

	D.matrix_entries_integral_division_exact(A2, qk, n + 1, 1);

	D.matrix_print_tex(cout, A2, n + 1, 1);

	FREE_OBJECTS(M);
	FREE_OBJECTS(A1);
	FREE_OBJECTS(A2);
}


void coding_theory_domain::do_weight_enumerator(finite_field *F,
		int m, int n, std::string &text,
		int f_normalize_from_the_left, int f_normalize_from_the_right,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int *M;
	int *A;
	int *base_cols;
	int *weight_enumerator;
	int len, rk, i;

	if (f_v) {
		cout << "do_weight_enumerator" << endl;
	}

	Orbiter->Int_vec.scan(text, M, len);
	if (len != m * n) {
		cout << "number of coordinates received differs from m * n" << endl;
		cout << "received " << len << endl;
		exit(1);
	}


	A = NEW_int(n * n);
	base_cols = NEW_int(n);
	weight_enumerator = NEW_int(n + 1);
	Orbiter->Int_vec.copy(M, A, m * n);

	rk = F->Gauss_int(A,
		FALSE /* f_special */, TRUE /* f_complete */, base_cols,
		FALSE /* f_P */, NULL /*P*/, m, n, n,
		0 /*verbose_level*/);


	if (f_v) {
		cout << "after RREF:" << endl;
		int_matrix_print(A, rk, n);
		cout << "rk=" << rk << endl;

		cout << "coefficients:" << endl;
		Orbiter->Int_vec.print(cout, A, rk * n);
		cout << endl;
	}

	code_weight_enumerator(F, n, rk,
		A /* code */, // [k * n]
		weight_enumerator, // [n + 1]
		verbose_level);

	if (f_v) {
		cout << "The weight enumerator is:" << endl;
		for (i = 0; i <= n; i++) {
			cout << i << " : " << weight_enumerator[i] << endl;
		}

		int f_first = TRUE;

		for (i = 0; i <= n; i++) {
			if (weight_enumerator[i] == 0) {
				continue;
			}
			if (f_first) {
				f_first = FALSE;
			}
			else {
				cout << " + ";
			}
			cout << weight_enumerator[i];
			if (i) {
				cout << "*";
				cout << "x";
				if (i > 1) {
					cout << "^";
					if (i < 10) {
						cout << i;
					}
					else {
						cout << "(" << i << ")";
					}
				}
			}
			if (n - i) {
				cout << "*";
				cout << "y";
				if (n - i > 1) {
					cout << "^";
					if (n - i < 10) {
						cout << n - i;
					}
					else {
						cout << "(" << n - i << ")";
					}
				}
			}

		}
		cout << endl;


		cout << "The weight enumerator is:" << endl;
		for (i = 0; i <= n; i++) {
			cout << i << " : " << weight_enumerator[i] << endl;
		}

		f_first = TRUE;

		for (i = 0; i <= n; i++) {
			if (weight_enumerator[i] == 0) {
				continue;
			}
			if (f_first) {
				f_first = FALSE;
			}
			else {
				cout << " + ";
			}
			cout << weight_enumerator[i];
			if (i) {
				//cout << "*";
				cout << "x";
				if (i > 1) {
					cout << "^";
					if (i < 10) {
						cout << i;
					}
					else {
						cout << "{" << i << "}";
					}
				}
			}
			if (n - i) {
				//cout << "*";
				cout << "y";
				if (n - i > 1) {
					cout << "^";
					if (n - i < 10) {
						cout << n - i;
					}
					else {
						cout << "{" << n - i << "}";
					}
				}
			}

		}
		cout << endl;

	}


	if (f_normalize_from_the_left) {
		if (f_v) {
			cout << "normalizing from the left" << endl;
		}
		for (i = 0; i < rk; i++) {
			F->PG_element_normalize_from_front(
					A + i * n, 1, n);
		}

		if (f_v) {
			cout << "after normalize from the left:" << endl;
			int_matrix_print(A, rk, n);
			cout << "rk=" << rk << endl;
		}
	}

	if (f_normalize_from_the_right) {
		if (f_v) {
			cout << "normalizing from the right" << endl;
		}
		for (i = 0; i < rk; i++) {
			F->PG_element_normalize(
					A + i * n, 1, n);
		}

		if (f_v) {
			cout << "after normalize from the right:" << endl;
			int_matrix_print(A, rk, n);
			cout << "rk=" << rk << endl;
		}
	}


	FREE_int(M);
	FREE_int(A);
	FREE_int(base_cols);
	FREE_int(weight_enumerator);

	if (f_v) {
		cout << "do_weight_enumerator done" << endl;
	}
}



void coding_theory_domain::do_linear_code_through_basis(
		int n,
		long int *basis_set, int k,
		int f_embellish,
		int verbose_level)
{
	cout << "coding_theory_domain::linear_code_through_basis:" << endl;

	int i;
	int *genma;
	int *word;
	int *code_word;
	long int *set;
	int sz;
	geometry_global Gg;

	genma = NEW_int(k * n);
	word = NEW_int(k);
	code_word = NEW_int(n);
	for (i = 0; i < k; i++) {

		Gg.AG_element_unrank(2, genma + i * n, 1, n, basis_set[i]);
	}
	cout << "genma:" << endl;
	int_matrix_print(genma, k, n);

	sz = 1 << k;
	set = NEW_lint(sz);

	finite_field *F;

	F = NEW_OBJECT(finite_field);
	F->finite_field_init(2, 0);

	for (i = 0; i < sz; i++) {
		Gg.AG_element_unrank(2, word, 1, k, i);
		F->mult_matrix_matrix(word, genma,
				code_word, 1, k, n, 0 /* verbose_level*/);
		set[i] = Gg.AG_element_rank(2, code_word, 1, n);

		cout << i << " : ";
		Orbiter->Int_vec.print(cout, word, k);
		cout << " : ";
		Orbiter->Int_vec.print(cout, code_word, n);
		cout << " : " << set[i] << endl;
	}
	investigate_code(set, sz, n, f_embellish, verbose_level);

	FREE_OBJECT(F);
	FREE_int(genma);
	FREE_int(word);
	FREE_int(code_word);

}

void coding_theory_domain::do_polynomial(
		int n,
		int polynomial_degree,
		int polynomial_nb_vars,
		std::string &polynomial_text,
		int f_embellish,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "reading polynomial " << polynomial_text << " of degree "
				<< polynomial_degree << " in "
				<< polynomial_nb_vars << " variables" << endl;
	}

	long int *poly_monomials;
	int poly_monomials_sz;
	homogeneous_polynomial_domain *Poly;
	finite_field *Fq;
	int *mon;
	int *coeff;
	long int a;
	int i, j, b, idx;
	monomial_ordering_type Monomial_ordering_type = t_PART;

	lint_vec_scan(polynomial_text, poly_monomials, poly_monomials_sz);
	cout << "polynomial after scan: ";
	lint_vec_print(cout, poly_monomials, poly_monomials_sz);
	cout << endl;

	Poly = NEW_OBJECT(homogeneous_polynomial_domain);
	Fq = NEW_OBJECT(finite_field);

	Fq->finite_field_init(2, 0 /* verbose_level */);

	Poly->init(Fq, polynomial_nb_vars, polynomial_degree,
				FALSE /* f_init_incidence_structure */,
				Monomial_ordering_type,
				0 /* verbose_level */);
	mon = NEW_int(polynomial_nb_vars);
	coeff = NEW_int(Poly->get_nb_monomials());

	Orbiter->Int_vec.zero(coeff, Poly->get_nb_monomials());

	for (i = 0; i < poly_monomials_sz; i++) {
		Orbiter->Int_vec.zero(mon, polynomial_nb_vars);
		a = poly_monomials[i];
		j = 0;
		while (a) {
			b = a % 10;
			mon[b]++;
			a /= 10;
			j++;
		}
		mon[0] += polynomial_degree - j;
		idx = Poly->index_of_monomial(mon);
		coeff[idx] = Fq->add(coeff[idx], 1);
	}

	Poly->print_equation(cout, coeff);
	cout << endl;

	int *v;
	int *f;
	int h;
	long int *set;
	int set_sz = 0;
	geometry_global Gg;
	sorting Sorting;

	v = NEW_int(polynomial_nb_vars);
	f = NEW_int(Poly->get_P()->N_points);
	Poly->polynomial_function(coeff, f, verbose_level);


	set = NEW_lint(Poly->get_P()->N_points);

	for (h = 0; h < Poly->get_P()->N_points; h++) {
		Poly->unrank_point(v, h);
		cout << h << " : ";
		Orbiter->Int_vec.print(cout, v, polynomial_nb_vars);
		cout << " : " << f[h] << endl;
		if (f[h] == 1 && v[polynomial_nb_vars - 1] == 1) {
			a = Gg.AG_element_rank(2, v, 1, polynomial_nb_vars - 1);
			set[set_sz++] = a;
		}
	}
	FREE_int(v);

	Sorting.lint_vec_heapsort(set, set_sz);

	cout << "We found a set of size " << set_sz << " : " << endl;
	lint_vec_print_fully(cout, set, set_sz);
	cout << endl;

	investigate_code(set, set_sz, n, f_embellish, verbose_level);

	FREE_int(f);

}

void coding_theory_domain::do_sylvester_hadamard(int n,
		int f_embellish,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "coding_theory_domain::do_sylvester_hadamard" << endl;
	}
	int i;

	if (n % 4) {
		cout << "for Hadamard matrices, n must be divisible by 4." << endl;
		exit(1);
	}
	int m = n >> 2;
	int nb_factors, sz, sz1, j, a;
	int *M1;
	int *M2;
	int H2[4] = {1,1,1,2};
	number_theory_domain NT;
	geometry_global Gg;

	nb_factors = NT.int_log2(m);

	cout << "nb_factors = " << nb_factors << endl;

	if ((2 << nb_factors) != n) {
		cout << "for Sylvester type Hadamard matrices, n must be 4 times a power of two" << endl;
		exit(1);
	}

	M1 = NEW_int(2 * n * n);
	M2 = NEW_int(2 * n * n);
	finite_field *F;

	F = NEW_OBJECT(finite_field);
	F->finite_field_init(3, 0);
	Orbiter->Int_vec.copy(H2, M1, 4);
	sz = 2;
	for (i = 0; i < nb_factors; i++) {

		cout << "M1=" << endl;
		int_matrix_print(M1, sz, sz);

		F->Kronecker_product_square_but_arbitrary(
				M1, H2,
				sz, 2, M2, sz1,
				verbose_level);
		Orbiter->Int_vec.copy(M2, M1, sz1 * sz1);

		sz = sz1;
	}
	cout << "Sylvester type Hadamard matrix:" << endl;
	int_matrix_print(M1, sz, sz);
	for (i = 0; i < sz; i++) {
		for (j = 0; j < sz; j++) {
			a = M1[i * sz + j];
			M1[(sz + i) * sz + j] = F->negate(a);
		}
	}

	for (i = 0; i < 2 * sz; i++) {
		for (j = 0; j < sz; j++) {
			a = M1[i * sz + j];
			if (a == 2) {
				M1[i * sz + j] = 0;
			}
		}
	}
	cout << "Sylvester type Hadamard code:" << endl;
	int_matrix_print(M1, 2 * sz, sz);


	long int *set;

	set = NEW_lint(2 * sz);
	for (i = 0; i < 2 * sz; i++) {
		set[i] = Gg.AG_element_rank(2, M1 + i * sz, 1, sz);
	}

	investigate_code(set, 2 * sz, n, f_embellish, verbose_level);

	FREE_lint(set);

	FREE_int(M1);
	FREE_int(M2);
	FREE_OBJECT(F);

}

void coding_theory_domain::investigate_code(long int *Words,
		int nb_words, int n, int f_embellish, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int nb_rows, nb_cols;
	int *v;
	int *M;
	int *M1;
	int *M2;
	int N;
	//int D, d;
	int h, i, j;
	file_io Fio;

	if (f_v) {
		cout << "coding_theory_domain::investigate_code" << endl;
		cout << "n=" << n << endl;
		cout << "set:" << endl;
		lint_vec_print(cout, Words, nb_words);
		cout << endl;
	}

	dimensions(n, nb_rows, nb_cols);

	if (f_v) {
		cout << "coding_theory_domain::investigate_code" << endl;
		cout << "nb_rows=" << nb_rows << endl;
		cout << "nb_cols=" << nb_cols << endl;
	}

	v = NEW_int(n);
	M1 = NEW_int(nb_rows * nb_cols);
	M2 = NEW_int(nb_rows * nb_cols);
	M = NEW_int(nb_rows * nb_cols);


	Orbiter->Int_vec.zero(M1, nb_rows * nb_cols);
	Orbiter->Int_vec.zero(M2, nb_rows * nb_cols);


	N = 1 << n;

	cout << "N=" << N << endl;

	cout << "placing codewords" << endl;
	for (h = 0; h < N; h++) {
		place_binary(h, i, j);
		M1[i * nb_cols + j] = h;
		//M2[i * nb_cols + j] = 1;
		}
	cout << "placing position values done" << endl;


#if 0
	colored_graph *C;

	C = new colored_graph;

	C->init_adjacency_no_colors(int nb_points, int *Adj, int verbose_level);
#endif


	char fname[1000];

	sprintf(fname, "code_%d_%d.tex", n, nb_words);

	{
		ofstream fp(fname);
		latex_interface L;

		L.head_easy(fp);
		fp << "$$" << endl;
		L.print_integer_matrix_tex(fp, M1, nb_rows, nb_cols);
		fp << "$$" << endl;



		cout << "placing codewords" << endl;
		Orbiter->Int_vec.zero(M, nb_rows * nb_cols);
		for (h = 0; h < nb_words; h++) {
			convert_to_binary(n, Words[h], v);
			cout << "codeword " << h + 1 << " = " << setw(5) << Words[h];
			cout << " : ";
			print_binary(n, v);
			cout << endl;
			place_binary(Words[h], i, j);
			M[i * nb_cols + j] = h + 1;
			M2[i * nb_cols + j] = 1;
			if (f_embellish) {
				embellish(M, nb_rows, nb_cols, i, j, h + 1);
				}
			}
		//int_matrix_print(M, nb_rows, nb_cols);
		cout << "placing codewords done" << endl;

		fp << "$$" << endl;
		L.print_integer_matrix_tex(fp, M, nb_rows, nb_cols);
		fp << "$$" << endl;


		L.foot(fp);
	}
	cout << "Written file " << fname << " of size " << Fio.file_size(fname) << endl;

	cout << "M2:" << endl;
	int_matrix_print(M2, nb_rows, nb_cols);

	{
		char str[1000];
		string fname;
		file_io Fio;

		sprintf(str, "code_matrix_%d_%d.csv", nb_rows, nb_cols);
		fname.assign(str);
		Fio.int_matrix_write_csv(fname, M2, nb_rows, nb_cols);

	}


#if 0
	{
	colored_graph *CG;

	CG = NEW_OBJECT(colored_graph);

	cout << "before create_Levi_graph_from_incidence_matrix" << endl;
	CG->create_Levi_graph_from_incidence_matrix(M, nb_rows, nb_cols,
		FALSE /* f_point_labels */, NULL /* *point_labels */,
		verbose_level);

	cout << "after create_Levi_graph_from_incidence_matrix" << endl;

	char fname[1000];


	sprintf(fname, "code_%d_%d_Levi_%d_%d.bin",
		n, nb_words, nb_rows, nb_cols);
	CG->save(fname, verbose_level);
	delete CG;
	}
#endif


	boolean_function_domain *BF;
	int *coeff;
	int *f;
	int *g;

	BF = NEW_OBJECT(boolean_function_domain);


	cout << "before BF->init, n=" << n << endl;
	BF->init(n, 0 /*verbose_level*/);

	cout << "BF->Poly[n].get_nb_monomials()=" << BF->Poly[n].get_nb_monomials() << endl;
	coeff = NEW_int(BF->Poly[n].get_nb_monomials());
	f = NEW_int(N);
	g = NEW_int(N);

	Orbiter->Int_vec.zero(f, N);
	for (h = 0; h < nb_words; h++) {
		f[Words[h]] = 1;
	}

	cout << "computing the polynomial representation: " << endl;


	BF->compute_polynomial_representation(
			f /* func */, coeff, 0 /*verbose_level*/);
	//BF->search_for_bent_functions(verbose_level);



	cout << "The representation as polynomial is: ";

	cout << " : ";
	BF->Poly[BF->n].print_equation(cout, coeff);
	cout << " : ";
	//evaluate_projectively(poly, f_proj);
	BF->evaluate(coeff, g);
	//int_vec_print(cout, g, BF->Q);
	cout << endl;


	for (h = 0; h < BF->Q; h++) {
		if (f[h] != g[h]) {
			cout << "f[h] != g[h], h = " << h << ", an error has occured" << endl;
		}
	}


	FREE_OBJECT(BF);
	FREE_OBJECT(coeff);
	FREE_OBJECT(f);
	FREE_OBJECT(g);


#if 0
	D = INT_MAX;
	for (i = 0; i < nb_words; i++) {
		for (j = i + 1; j < nb_words; j++) {
			d = distance(n, Words[i], Words[j]);
			//cout << "The distance between word " << i << " and word " << j << " is " << d << endl;
			D = MINIMUM(D, d);
			}
		}

	cout << "minimum distance d = " << D << endl;
	cout << "attained for:" << endl;
	for (i = 0; i < nb_words; i++) {
		for (j = i + 1; j < nb_words; j++) {
			if (distance(n, Words[i], Words[j]) == D) {
				cout << i << ", " << j << endl;
				}
			}
		}
#endif

}

void coding_theory_domain::do_long_code(
		int n,
		std::vector<std::string> &long_code_generators_text,
		int f_nearest_codeword,
		std::string &nearest_codeword_text,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "coding_theory_domain::do_long_code" << endl;
	}

	int i, j;
	int *genma;
	int k;

	k = long_code_generators_text.size();
	genma = NEW_int(k * n);
	Orbiter->Int_vec.zero(genma, k * n);
	for (i = 0; i < k; i++) {
		long int *set;
		int sz;


		lint_vec_scan(long_code_generators_text[i], set, sz);

		for (j = 0; j < sz; j++) {
			genma[i * n + set[j]] = 1;
		}
		FREE_lint(set);
	}

	cout << "genma:" << endl;
	int_matrix_print(genma, k, n);

	{
		char str[1000];
		string fname;
		file_io Fio;

		sprintf(str, "long_code_genma_n%d_k%d.csv", n, k);
		fname.assign(str);
		Fio.int_matrix_write_csv(fname, genma, k, n);
		cout << "Written file " << fname << " of size " << Fio.file_size(fname) << endl;
	}

	int sz;
	int *message;
	int *code_word;
	int *M;
	int nb_rows, nb_cols;
	int h, r, c;
	geometry_global Gg;
	int *Wt;
	int wt;
	//int N;

	//N = 1 << n;
	dimensions_N(n, nb_rows, nb_cols);

	if (f_v) {
		cout << "n=" << n << endl;
		cout << "nb_rows=" << nb_rows << endl;
		cout << "nb_cols=" << nb_cols << endl;
	}

	sz = 1 << k;
	message = NEW_int(k);
	code_word = NEW_int(n);
	M = NEW_int(nb_rows * nb_cols);

	finite_field *F;

	F = NEW_OBJECT(finite_field);
	F->finite_field_init(2, 0);

	Wt = NEW_int(sz);
	Orbiter->Int_vec.zero(Wt, sz);

	for (i = 0; i < sz; i++) {
		Gg.AG_element_unrank(2, message, 1, k, i);
		F->mult_matrix_matrix(message, genma,
				code_word, 1, k, n, 0 /* verbose_level*/);

		Orbiter->Int_vec.zero(M, nb_rows * nb_cols);
		wt = 0;
		for (h = 0; h < n; h++) {
			if (code_word[h]) {
				wt++;
			}
		}
		Wt[i] = wt;
		for (h = 0; h < n; h++) {
			if (code_word[h]) {
				place_binary(h, r, c);
				M[r * nb_cols + c] = 1;
			}
		}
		{
			char str[1000];
			string fname;
			file_io Fio;

			sprintf(str, "long_code_genma_n%d_k%d_codeword_%d.csv", n, k, i);
			fname.assign(str);
			Fio.int_matrix_write_csv(fname, M, nb_rows, nb_cols);
			cout << "Written file " << fname << " of size " << Fio.file_size(fname) << endl;
		}
	}

	{
		cout << "Weight distribution:";
		tally C;

		C.init(Wt, sz, FALSE, 0);
		C.print_first(FALSE /* f_backwards */);
		cout << endl;

		cout << "i : weight of the i-th codeword" << endl;
		for (i = 0; i < sz; i++) {
			cout << i << " : " << Wt[i] << endl;
		}
	}


	boolean_function_domain *BF;
	int *f;
	int *g;
	int ln;

	BF = NEW_OBJECT(boolean_function_domain);


	ln = log2(n);

	cout << "before BF->init, ln=" << ln << endl;
	BF->init(ln, 0 /*verbose_level*/);

	f = NEW_int(n);
	g = NEW_int(n);


	if (f_nearest_codeword) {

		cout << "nearest codeword" << endl;

		long int *nearest_codeword_set;
		int nearest_codeword_sz;
		int *word;


		lint_vec_scan(nearest_codeword_text,
				nearest_codeword_set, nearest_codeword_sz);


		word = NEW_int(n);
		Orbiter->Int_vec.zero(word, n);
		for (j = 0; j < nearest_codeword_sz; j++) {
			word[nearest_codeword_set[j]] = 1;
		}
		for (h = 0; h < n; h++) {
			if (word[h]) {
				f[h] = -1;
			}
			else {
				f[h] = 1;
			}
		}

		BF->apply_Walsh_transform(f, g);
		Orbiter->Int_vec.zero(M, nb_rows * nb_cols);
		for (h = 0; h < n; h++) {
			place_binary(h, r, c);
			M[r * nb_cols + c] = g[h];
		}
		{
			char str[1000];
			string fname;
			file_io Fio;

			sprintf(str, "long_code_genma_n%d_k%d_nearest_codeword_fourier.csv", n, k);
			fname.assign(str);
			Fio.int_matrix_write_csv(fname, M, nb_rows, nb_cols);
			cout << "Written file " << fname << " of size " << Fio.file_size(fname) << endl;
		}

		Orbiter->Int_vec.zero(M, nb_rows * nb_cols);
		for (h = 0; h < n; h++) {
			if (word[h]) {
				place_binary(h, r, c);
				M[r * nb_cols + c] = 1;
			}
		}
		{
			char str[1000];
			string fname;
			file_io Fio;

			sprintf(str, "long_code_genma_n%d_k%d_nearest_codeword.csv", n, k);
			fname.assign(str);
			Fio.int_matrix_write_csv(fname, M, nb_rows, nb_cols);
			cout << "Written file " << fname << " of size " << Fio.file_size(fname) << endl;
		}

		int d;
		int *D;

		D = NEW_int(sz);
		for (i = 0; i < sz; i++) {
			Gg.AG_element_unrank(2, message, 1, k, i);
			F->mult_matrix_matrix(message, genma,
					code_word, 1, k, n, 0 /* verbose_level*/);

			d = 0;
			for (h = 0; h < n; h++) {
				if (word[h] != code_word[h]) {
					d++;
				}
			D[i] = d;
			}
		}
		{
			cout << "distance distribution:";
			tally C;

			C.init(D, sz, FALSE, 0);
			C.print_first(FALSE /* f_backwards */);
			cout << endl;

			cout << "i : distance from the i-th codeword" << endl;
			for (i = 0; i < sz; i++) {
				cout << i << " : " << D[i] << endl;
			}
		}
		FREE_int(D);


	}
	else {
		cout << "no nearest codeword option" << endl;
	}

	FREE_int(message);
	FREE_int(code_word);
	FREE_int(M);
	FREE_OBJECT(F);


}

void coding_theory_domain::embellish(int *M, int nb_rows, int nb_cols, int i0, int j0, int a)
{
	int i, j, u, v;

#if 0
	int ij[] = {
		-1, -1,
		-1, 0,
		-1, 1,
		0, -1,
		0, 1,
		1, -1,
		1, 0,
		1, 1,
		-2,-2,
		-2,-1,
		-2,0,
		-2,1,
		-2,2,
		-2,-2,
		-2,2,
		-1,-2,
		-1,2,
		0,-2,
		0,2,
		1,-2,
		1,2,
		2,-2,
		2,-1,
		2,0,
		2,1,
		2,2,
		};
#endif
	for (u = -3; u <= 3; u++) {
		for (v = -3; v <= 3; v++) {
			i = i0 + u;
			j = j0 + v;
			place_entry(M, nb_rows, nb_cols, i, j, a);
			}
		}
#if 0
	for (h = 0; h < 8 + 18; h++) {
		i = i0 + ij[h * 2 + 0];
		j = j0 + ij[h * 2 + 1];
		place_entry(M, nb_rows, nb_cols, i, j, a);
		}
#endif
}

void coding_theory_domain::place_entry(int *M, int nb_rows, int nb_cols, int i, int j, int a)
{
	if (i < 0) {
		return;
		}
	if (j < 0) {
		return;
		}
	if (i >= nb_rows) {
		return;
		}
	if (j >= nb_cols) {
		return;
		}
	M[i * nb_cols + j] = a;
}

void coding_theory_domain::do_it(int n, int r, int a, int c, int seed, int verbose_level)
{
	int N;
	int i, j, h, s;
	int nb_rows, nb_cols;
	int *v;
	int *W;
	latex_interface L;

	N = 1 << n;

	cout << "N=" << N << endl;

	for (h = 0; h < N; h++) {
		place_binary(h, i, j);
		cout << h << " : (" << i << "," << j << ")" << endl;
		}

	dimensions(n, nb_rows, nb_cols);
	int *M;
	int D, d;

	v = NEW_int(n);
	W = NEW_int(r);
	M = NEW_int(nb_rows * nb_cols);
	Orbiter->Int_vec.zero(M, nb_rows * nb_cols);

	s = seed;
	for (h = 0; h < r; h++) {
		W[h] = s;
		convert_to_binary(n, s, v);
		cout << "s = " << setw(5) << s;
		cout << " : ";
		print_binary(n, v);
		cout << endl;
		place_binary(s, i, j);
		M[i * nb_cols + j] = 1;
		s = (a * s + c) % N;
		}

	int_matrix_print(M, nb_rows, nb_cols);

	L.print_integer_matrix_tex(cout, M, nb_rows, nb_cols);

	D = INT_MAX;
	for (i = 0; i < r; i++) {
		for (j = i + 1; j < r; j++) {
			d = distance(n, W[i], W[j]);
			cout << "The distance between word " << i << " and word " << j << " is " << d << endl;
			D = MINIMUM(D, d);
			}
		}

	cout << "minimum distance d = " << D << endl;
	cout << "attained for:" << endl;
	for (i = 0; i < r; i++) {
		for (j = i + 1; j < r; j++) {
			if (distance(n, W[i], W[j]) == D) {
				cout << i << ", " << j << endl;
				}
			}
		}
}

void coding_theory_domain::dimensions(int n, int &nb_rows, int &nb_cols)
{
	int i, j;

	place_binary((1 << n) - 1, i, j);
	nb_rows = i + 1;
	nb_cols = j + 1;
}

void coding_theory_domain::dimensions_N(int N, int &nb_rows, int &nb_cols)
{
	int i, j;
	long int a, b;
	number_theory_domain NT;

	a = NT.int_log2(N);
	b = 1 << a;
	place_binary(b - 1, i, j);
	nb_rows = i + 1;
	nb_cols = j + 1;
}

void coding_theory_domain::print_binary(int n, int *v)
{
	int c;

	for (c = n - 1; c >= 0; c--) {
		cout << v[c];
		}
}

void coding_theory_domain::convert_to_binary(int n, long int h, int *v)
{
	int c;

	for (c = 0; c < n; c++) {
		if (h % 2) {
			v[c] = 1;
			}
		else {
			v[c] = 0;
			}
		h >>= 1;
		}
}

int coding_theory_domain::distance(int n, int a, int b)
{
	int c, d = 0;

	for (c = 0; c < n; c++) {
		if (a % 2 != b % 2) {
			d++;
		}
		a >>= 1;
		b >>= 1;
	}
	return d;
}

void coding_theory_domain::place_binary(long int h, int &i, int &j)
{
	int o[2];
	int c;

	o[0] = 1;
	o[1] = 0;
	i = 0;
	j = 0;
	for (c = 0; h; c++) {
		if (h % 2) {
			i += o[0];
			j += o[1];
		}
		h >>= 1;
		if (c % 2) {
			o[0] = o[1] << 1;
			o[1] = 0;
		}
		else {
			o[1] = o[0];
			o[0] = 0;
		}
	}
}




void coding_theory_domain::field_reduction(finite_field *FQ, finite_field *Fq,
		std::string &label,
		int m, int n, std::string &genma_text,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int *M;
	int sz;
	int i;
	int *M2;

	if (f_v) {
		cout << "coding_theory_domain::field_reduction" << endl;
	}

	subfield_structure *Sub;

	Sub = NEW_OBJECT(subfield_structure);

	Sub->init(FQ, Fq, verbose_level);

	if (f_v) {
		Sub->print_embedding();
	}

	Orbiter->Int_vec.scan(genma_text, M, sz);

	if (sz != m * n) {
		cout << "sz != m * n" << endl;
		exit(1);
	}

	M2 = NEW_int(Sub->s * m * Sub->s * n);

	for (i = 0; i < m; i++) {
		Sub->field_reduction(M + i * n, n, M2 + (i * Sub->s) * Sub->s * n,
				verbose_level);
	}


	{
		char str[1000];
		string fname;
		char title[1000];
		char author[1000];

		snprintf(str, 1000, "field_reduction_Q%d_q%d_%d_%d.tex", FQ->q, Fq->q, m, n);
		fname.assign(str);
		snprintf(title, 1000, "Field Reduction");
		//strcpy(author, "");
		author[0] = 0;


		{
			ofstream ost(fname);
			latex_interface L;

			L.head(ost,
					FALSE /* f_book*/,
					TRUE /* f_title */,
					title, author,
					FALSE /* f_toc */,
					FALSE /* f_landscape */,
					TRUE /* f_12pt */,
					TRUE /* f_enlarged_page */,
					TRUE /* f_pagenumbers */,
					NULL /* extra_praeamble */);



			ost << "$$" << endl;
			ost << "\\left[" << endl;
			L.int_matrix_print_tex(ost, M2, m * Sub->s, Sub->s * n);
			ost << "\\right]" << endl;
			ost << "$$" << endl;

			Orbiter->Int_vec.print_fully(ost, M2, m * Sub->s * Sub->s * n);
			ost << "\\\\" << endl;



			L.foot(ost);

		}
		file_io Fio;

		cout << "coding_theory_domain::field_reduction written file " << fname << " of size "
				<< Fio.file_size(fname) << endl;

		string fname_csv;

		fname_csv.assign(label);
		fname_csv.append(".csv");

		Fio.int_matrix_write_csv(fname_csv, M2, m * Sub->s, Sub->s * n);
	}

	FREE_int(M2);
	FREE_OBJECT(Sub);

	if (f_v) {
		cout << "coding_theory_domain::field_reduction done" << endl;
	}
}



}}

