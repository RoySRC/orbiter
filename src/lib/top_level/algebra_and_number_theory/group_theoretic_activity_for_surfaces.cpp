/*
 * group_theoretic_activity_for_surfaces.cpp
 *
 *  Created on: Oct 19, 2020
 *      Author: betten
 */




#include "orbiter.h"

using namespace std;

namespace orbiter {
namespace top_level {




void group_theoretic_activity::do_create_surface(
		surface_create_description *Surface_Descr,
		poset_classification_control *Control_six_arcs,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface" << endl;
		cout << "group_theoretic_activity::do_create_surface verbose_level=" << verbose_level << endl;
	}

	int q;
	int i;
	finite_field *F;
	surface_domain *Surf;
	surface_with_action *Surf_A;
	number_theory_domain NT;
	sorting Sorting;
	file_io Fio;

	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface before Surface_Descr->get_q" << endl;
	}
	q = Surface_Descr->get_q();
	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface q = " << q << endl;
	}


	F = LG->F;
	if (F->q != q) {
		cout << "F->q != q" << endl;
		exit(1);
	}


	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface before Surf->init" << endl;
		}
	Surf = NEW_OBJECT(surface_domain);
	Surf->init(F, verbose_level - 1);
	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface after Surf->init" << endl;
		}

	Surf_A = NEW_OBJECT(surface_with_action);

	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface before Surf_A->init" << endl;
		}
	Surf_A->init(Surf, LG, 0 /*verbose_level*/);
	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface after Surf_A->init" << endl;
		}


	surface_create *SC;
	SC = NEW_OBJECT(surface_create);

	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface before SC->init" << endl;
	}
	SC->init(Surface_Descr, Surf_A, verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface after SC->init" << endl;
	}


	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface "
				"before SC->apply_transformations" << endl;
	}
	SC->apply_transformations(Surface_Descr->transform_coeffs,
				Surface_Descr->f_inverse_transform,
				verbose_level - 2);

	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface "
				"after SC->apply_transformations" << endl;
	}




	int coeffs_out[20];
	action *A;
	//int *Elt1;
	int *Elt2;

	A = SC->Surf_A->A;

	Elt2 = NEW_int(A->elt_size_in_int);

	//SC->F->init_symbol_for_print("\\omega");

	if (SC->F->e == 1) {
		SC->F->f_print_as_exponentials = FALSE;
	}

	SC->F->PG_element_normalize(SC->SO->eqn, 1, 20);

	cout << "group_theoretic_activity::do_create_surface "
			"We have created the following surface:" << endl;
	cout << "$$" << endl;
	SC->Surf->print_equation_tex(cout, SC->SO->eqn);
	cout << endl;
	cout << "$$" << endl;

	cout << "$$" << endl;
	int_vec_print(cout, SC->SO->eqn, 20);
	cout << endl;
	cout << "$$" << endl;


	if (SC->f_has_group) {

		// test the generators:

		for (i = 0; i < SC->Sg->gens->len; i++) {
			cout << "group_theoretic_activity::do_create_surface "
					"Testing generator " << i << " / "
					<< SC->Sg->gens->len << endl;
			A->element_invert(SC->Sg->gens->ith(i),
					Elt2, 0 /*verbose_level*/);



			matrix_group *M;

			M = A->G.matrix_grp;
			M->substitute_surface_equation(Elt2,
					SC->SO->eqn, coeffs_out, SC->Surf,
					verbose_level - 1);


			if (int_vec_compare(SC->SO->eqn, coeffs_out, 20)) {
				cout << "group_theoretic_activity::do_create_surface error, "
						"the transformation does not preserve "
						"the equation of the surface" << endl;
				exit(1);
			}
			cout << "group_theoretic_activity::do_create_surface "
					"Generator " << i << " / " << SC->Sg->gens->len
					<< " is good" << endl;
		}
	}
	else {
		cout << "group_theoretic_activity::do_create_surface "
				"We do not have information about "
				"the automorphism group" << endl;
	}


	cout << "group_theoretic_activity::do_create_surface We have created "
			"the surface " << SC->label_txt << ":" << endl;
	cout << "$$" << endl;
	SC->Surf->print_equation_tex(cout, SC->SO->eqn);
	cout << endl;
	cout << "$$" << endl;

	if (SC->f_has_group) {
		cout << "group_theoretic_activity::do_create_surface "
				"The stabilizer is generated by:" << endl;
		SC->Sg->print_generators_tex(cout);

		if (SC->f_has_nice_gens) {
			cout << "group_theoretic_activity::do_create_surface "
					"The stabilizer is generated by the following nice generators:" << endl;
			SC->nice_gens->print_tex(cout);

		}
	}

#if 0
	if (SC->f_has_lines) {
		if (f_v) {
			cout << "group_theoretic_activity::do_create_surface "
					"The lines are:" << endl;
			SC->Surf->Gr->print_set_tex(cout, SC->SO->Lines, SC->SO->nb_lines);
		}


		surface_object *SO;

		SO = NEW_OBJECT(surface_object);
		if (f_v) {
			cout << "group_theoretic_activity::do_create_surface before SO->init_with_27_lines" << endl;
			}
		SO->init_with_27_lines(SC->Surf, SC->Lines, SC->coeffs,
				FALSE /*f_find_double_six_and_rearrange_lines */, verbose_level);
		if (f_v) {
			cout << "group_theoretic_activity::do_create_surface after SO->init_with_27_lines" << endl;
			}

		string fname_points;

		fname_points.assign("surface_");
		fname_points.append(SC->label_txt);
		fname_points.append("_points.txt");
		Fio.write_set_to_file(fname_points, SO->Pts, SO->nb_pts, 0 /*verbose_level*/);
		cout << "group_theoretic_activity::do_create_surface "
				"Written file " << fname_points << " of size "
				<< Fio.file_size(fname_points) << endl;
	}
	else {
		cout << "group_theoretic_activity::do_create_surface "
				"The surface " << SC->label_txt
				<< " does not come with lines" << endl;
	}
#else
	string fname_points;

	fname_points.assign("surface_");
	fname_points.append(SC->label_txt);
	fname_points.append("_points.txt");
	Fio.write_set_to_file(fname_points, SC->SO->Pts, SC->SO->nb_pts, 0 /*verbose_level*/);
	cout << "group_theoretic_activity::do_create_surface "
			"Written file " << fname_points << " of size "
			<< Fio.file_size(fname_points) << endl;

#endif

	{
		string fname_report;

		fname_report.assign("surface_");
		fname_report.append(SC->label_txt);
		fname_report.append("_report.tex");

		{
			ofstream ost(fname_report);


			char title[1000];
			char author[1000];
			snprintf(title, 1000, "Cubic Surface over GF(%d)", F->q);
			strcpy(author, "");

			latex_interface L;

			//latex_head_easy(fp);
			L.head(ost,
				FALSE /* f_book */,
				TRUE /* f_title */,
				title, author,
				FALSE /*f_toc */,
				FALSE /* f_landscape */,
				FALSE /* f_12pt */,
				TRUE /*f_enlarged_page */,
				TRUE /* f_pagenumbers*/,
				NULL /* extra_praeamble */);




			ost << "\\subsection*{The surface $" << SC->label_tex << "$}" << endl;


			if (SC->SO->SOP == NULL) {
				cout << "group_theoretic_activity::do_create_surface SC->SO->SOP == NULL" << endl;
				exit(1);
			}

			if (f_v) {
				cout << "group_theoretic_activity::do_create_surface "
						"before SC->SO->SOP->print_everything" << endl;
			}
			SC->SO->SOP->print_everything(ost, verbose_level);
			if (f_v) {
				cout << "group_theoretic_activity::do_create_surface "
						"after SC->SO->SOP->print_everything" << endl;
			}

			L.foot(ost);
		}
		file_io Fio;

		cout << "Written file " << fname_report << " of size "
			<< Fio.file_size(fname_report) << endl;


	}






	if (SC->f_has_group) {

		if (f_v) {
			cout << "group_theoretic_activity::do_create_surface creating "
					"surface_object_with_action object" << endl;
		}

		surface_object_with_action *SoA;

		SoA = NEW_OBJECT(surface_object_with_action);

		if (f_v) {
			cout << "group_theoretic_activity::do_create_surface before SoA->init_with_group" << endl;
		}
		SoA->init_with_group(
			SC->Surf_A,
			SC->SO->Lines, SC->SO->nb_lines,
			SC->SO->eqn,
			SC->Sg,
			FALSE /*f_find_double_six_and_rearrange_lines*/,
			SC->f_has_nice_gens, SC->nice_gens,
			verbose_level - 1);
		if (f_v) {
			cout << "group_theoretic_activity::do_create_surface after SoA->init_with_group" << endl;
		}

		if (f_v) {
			cout << "group_theoretic_activity::do_create_surface "
					"The surface has been created." << endl;
		}



		if (f_v) {
			cout << "group_theoretic_activity::do_create_surface "
					"Classifying non-conical six-arcs." << endl;
		}

		six_arcs_not_on_a_conic *Six_arcs;
		arc_generator_description *Six_arc_descr;

		int *transporter;

		Six_arcs = NEW_OBJECT(six_arcs_not_on_a_conic);

		Six_arc_descr = NEW_OBJECT(arc_generator_description);
		Six_arc_descr->F = F;
		Six_arc_descr->f_q = TRUE;
		Six_arc_descr->q = F->q;
		Six_arc_descr->f_n = TRUE;
		Six_arc_descr->n = 3;
		Six_arc_descr->f_target_size = TRUE;
		Six_arc_descr->target_size = 6;
		Six_arc_descr->Control = Control_six_arcs;



		// classify six arcs not on a conic:

		if (f_v) {
			cout << "group_theoretic_activity::do_create_surface "
					"Setting up the group of the plane:" << endl;
		}

		action *A;

		A = NEW_OBJECT(action);


		int f_semilinear = TRUE;
		number_theory_domain NT;

		if (NT.is_prime(F->q)) {
			f_semilinear = FALSE;
		}

		{
			vector_ge *nice_gens;
			A->init_projective_group(3, F,
					f_semilinear, TRUE /*f_basis*/, TRUE /* f_init_sims */,
					nice_gens,
					0 /*verbose_level*/);
			FREE_OBJECT(nice_gens);
		}


		if (f_v) {
			cout << "group_theoretic_activity::do_create_surface "
					"before Six_arcs->init:" << endl;
		}


		Six_arcs->init(
				Six_arc_descr,
				A,
				SC->Surf->P2,
				FALSE, 0, NULL,
				verbose_level);

		transporter = NEW_int(Six_arcs->Gen->A->elt_size_in_int);


		if (f_v) {
			cout << "group_theoretic_activity::do_create_surface "
					"before SoA->investigate_surface_and_write_report:" << endl;
		}

		if (Descr->f_draw_options) {
			SoA->investigate_surface_and_write_report(
					Descr->draw_options,
					A,
					SC,
					Six_arcs,
					Descr->f_surface_clebsch,
					Descr->f_surface_codes,
					Descr->f_surface_quartic,
					verbose_level);
		}
		else {
			cout << "use -draw_options to specify the drawing option for the report" << endl;
			exit(1);
		}

		FREE_OBJECT(SoA);
		FREE_OBJECT(Six_arcs);
		FREE_OBJECT(Six_arc_descr);
		FREE_int(transporter);


		}
	else {
		cout << "We don't have the group of the surface" << endl;
	}



	FREE_int(Elt2);

	FREE_OBJECT(SC);


	if (f_v) {
		cout << "group_theoretic_activity::do_create_surface done" << endl;
	}
}



void group_theoretic_activity::do_surface_classify(int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_classify" << endl;
	}

	algebra_global_with_action Algebra;
	surface_domain *Surf;
	surface_with_action *Surf_A;
	surface_classify_wedge *SCW;

	poset_classification_control *Control;

	if (Descr->f_poset_classification_control) {
		Control = Descr->Control;
	}
	else {
		Control = NEW_OBJECT(poset_classification_control);
	}


	if (f_v) {
		cout << "group_theoretic_activity::do_surface_classify "
				"before Algebra.classify_surfaces, control=" << endl;
		Control->print();
	}
	Algebra.classify_surfaces(
			F, LG,
			Control,
			Surf, Surf_A,
			SCW,
			verbose_level - 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_classify "
				"after Algebra.classify_surfaces" << endl;
	}


	if (f_v) {
		cout << "group_theoretic_activity::do_surface_classify "
				"before SCW->generate_source_code" << endl;
	}
	SCW->generate_source_code(verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_classify "
				"after SCW->generate_source_code" << endl;
	}


	FREE_OBJECT(SCW);
	FREE_OBJECT(Surf_A);
	FREE_OBJECT(Surf);
	if (f_v) {
		cout << "interface_algebra::do_surface_classify done" << endl;
	}
}

void group_theoretic_activity::do_surface_report(int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_report" << endl;
	}

	algebra_global_with_action Algebra;
	surface_domain *Surf;
	surface_with_action *Surf_A;
	surface_classify_wedge *SCW;
	poset_classification_control *Control;

	if (Descr->f_poset_classification_control) {
		Control = Descr->Control;
	}
	else {
		Control = NEW_OBJECT(poset_classification_control);
	}


	if (f_v) {
		cout << "group_theoretic_activity::do_surface_report "
				"before Algebra.classify_surfaces" << endl;
	}
	Algebra.classify_surfaces(
			F, LG,
			Control,
			Surf, Surf_A,
			SCW,
			verbose_level - 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_report "
				"after Algebra.classify_surfaces" << endl;
	}

	int f_with_stabilizers = TRUE;

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_report "
				"before SCW->create_report" << endl;
	}
	SCW->create_report(f_with_stabilizers, Control->draw_options, verbose_level - 1);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_report "
				"after SCW->create_report" << endl;
	}


	FREE_OBJECT(SCW);
	FREE_OBJECT(Surf_A);
	FREE_OBJECT(Surf);
	if (f_v) {
		cout << "interface_algebra::do_surface_report done" << endl;
	}
}

void group_theoretic_activity::do_surface_identify_HCV(int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_HCV" << endl;
	}

	algebra_global_with_action Algebra;
	surface_domain *Surf;
	surface_with_action *Surf_A;
	surface_classify_wedge *SCW;
	poset_classification_control *Control;

	if (Descr->f_poset_classification_control) {
		Control = Descr->Control;
	}
	else {
		Control = NEW_OBJECT(poset_classification_control);
	}


	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_HCV "
				"before Algebra.classify_surfaces" << endl;
	}
	Algebra.classify_surfaces(
			F, LG,
			Control,
			Surf, Surf_A,
			SCW,
			verbose_level - 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_HCV "
				"after Algebra.classify_surfaces" << endl;
	}

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_HCV "
				"before SCW->identify_HCV_and_print_table" << endl;
	}
	SCW->identify_HCV_and_print_table(verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_HCV "
				"after SCW->identify_HCV_and_print_table" << endl;
	}


	FREE_OBJECT(SCW);
	FREE_OBJECT(Surf_A);
	FREE_OBJECT(Surf);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_HCV done" << endl;
	}
}

void group_theoretic_activity::do_surface_identify_F13(int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_F13" << endl;
	}

	algebra_global_with_action Algebra;
	surface_domain *Surf;
	surface_with_action *Surf_A;
	surface_classify_wedge *SCW;
	poset_classification_control *Control;

	if (Descr->f_poset_classification_control) {
		Control = Descr->Control;
	}
	else {
		Control = NEW_OBJECT(poset_classification_control);
	}


	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_F13 "
				"before Algebra.classify_surfaces" << endl;
	}
	Algebra.classify_surfaces(
			F, LG,
			Control,
			Surf, Surf_A,
			SCW,
			verbose_level - 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_F13 "
				"after Algebra.classify_surfaces" << endl;
	}

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_F13 "
				"before SCW->identify_HCV_and_print_table" << endl;
	}
	SCW->identify_F13_and_print_table(verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_F13 "
				"after SCW->identify_HCV_and_print_table" << endl;
	}


	FREE_OBJECT(SCW);
	FREE_OBJECT(Surf_A);
	FREE_OBJECT(Surf);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_F13 done" << endl;
	}
}

void group_theoretic_activity::do_surface_identify_Bes(int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_Bes" << endl;
	}

	algebra_global_with_action Algebra;
	surface_domain *Surf;
	surface_with_action *Surf_A;
	surface_classify_wedge *SCW;
	poset_classification_control *Control;

	if (Descr->f_poset_classification_control) {
		Control = Descr->Control;
	}
	else {
		Control = NEW_OBJECT(poset_classification_control);
	}


	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_Bes "
				"before Algebra.classify_surfaces" << endl;
	}
	Algebra.classify_surfaces(
			F, LG,
			Control,
			Surf, Surf_A,
			SCW,
			verbose_level - 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_Bes "
				"after Algebra.classify_surfaces" << endl;
	}

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_Bes "
				"before SCW->identify_Bes_and_print_table" << endl;
	}
	SCW->identify_Bes_and_print_table(verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_Bes "
				"after SCW->identify_Bes_and_print_table" << endl;
	}


	FREE_OBJECT(SCW);
	FREE_OBJECT(Surf_A);
	FREE_OBJECT(Surf);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_Bes done" << endl;
	}
}

void group_theoretic_activity::do_surface_identify_general_abcd(int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_general_abcd" << endl;
	}

	algebra_global_with_action Algebra;
	surface_domain *Surf;
	surface_with_action *Surf_A;
	surface_classify_wedge *SCW;
	poset_classification_control *Control;

	if (Descr->f_poset_classification_control) {
		Control = Descr->Control;
	}
	else {
		Control = NEW_OBJECT(poset_classification_control);
	}


	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_general_abcd "
				"before Algebra.classify_surfaces" << endl;
	}
	Algebra.classify_surfaces(
			F, LG,
			Control,
			Surf, Surf_A,
			SCW,
			verbose_level - 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_general_abcd "
				"after Algebra.classify_surfaces" << endl;
	}

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_general_abcd "
				"before SCW->identify_general_abcd_and_print_table" << endl;
	}
	SCW->identify_general_abcd_and_print_table(verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_general_abcd "
				"after SCW->identify_general_abcd_and_print_table" << endl;
	}


	FREE_OBJECT(SCW);
	FREE_OBJECT(Surf_A);
	FREE_OBJECT(Surf);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_identify_general_abcd done" << endl;
	}
}

void group_theoretic_activity::do_surface_isomorphism_testing(
		surface_create_description *surface_descr_isomorph1,
		surface_create_description *surface_descr_isomorph2,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_isomorphism_testing" << endl;
	}

	algebra_global_with_action Algebra;
	surface_domain *Surf;
	surface_with_action *Surf_A;
	surface_classify_wedge *SCW;
	poset_classification_control *Control;

	if (Descr->f_poset_classification_control) {
		Control = Descr->Control;
	}
	else {
		Control = NEW_OBJECT(poset_classification_control);
	}


	if (f_v) {
		cout << "group_theoretic_activity::do_surface_isomorphism_testing "
				"before Algebra.classify_surfaces" << endl;
	}
	Algebra.classify_surfaces(
			F, LG,
			Control,
			Surf, Surf_A,
			SCW,
			verbose_level - 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_isomorphism_testing "
				"after Algebra.classify_surfaces" << endl;
	}

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_isomorphism_testing "
				"before SCW->test_isomorphism" << endl;
	}
	SCW->test_isomorphism(
			surface_descr_isomorph1,
			surface_descr_isomorph2,
			verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_isomorphism_testing "
				"after SCW->test_isomorphism" << endl;
	}


	FREE_OBJECT(SCW);
	FREE_OBJECT(Surf_A);
	FREE_OBJECT(Surf);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_isomorphism_testing done" << endl;
	}
}

void group_theoretic_activity::do_surface_recognize(
		surface_create_description *surface_descr,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_recognize" << endl;
	}

	algebra_global_with_action Algebra;
	surface_domain *Surf;
	surface_with_action *Surf_A;
	surface_classify_wedge *SCW;
	poset_classification_control *Control;

	if (Descr->f_poset_classification_control) {
		Control = Descr->Control;
	}
	else {
		Control = NEW_OBJECT(poset_classification_control);
	}


	if (f_v) {
		cout << "group_theoretic_activity::do_surface_recognize "
				"before Algebra.classify_surfaces" << endl;
	}
	Algebra.classify_surfaces(
			F, LG,
			Control,
			Surf, Surf_A,
			SCW,
			verbose_level - 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_recognize "
				"after Algebra.classify_surfaces" << endl;
	}

	if (f_v) {
		cout << "group_theoretic_activity::do_surface_recognize "
				"before SCW->recognition" << endl;
	}
	SCW->recognition(
			surface_descr,
			verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_recognize "
				"after SCW->recognition" << endl;
	}

	FREE_OBJECT(SCW);
	FREE_OBJECT(Surf_A);
	FREE_OBJECT(Surf);
	if (f_v) {
		cout << "group_theoretic_activity::do_surface_recognize done" << endl;
	}
}





void group_theoretic_activity::do_classify_surfaces_through_arcs_and_two_lines(
		poset_classification_control *Control_six_arcs,
		int f_test_nb_Eckardt_points, int nb_E,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_two_lines" << endl;
	}

	surface_with_action *Surf_A;
	surface_domain *Surf;
	number_theory_domain NT;



	Surf = NEW_OBJECT(surface_domain);
	Surf_A = NEW_OBJECT(surface_with_action);


	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_two_lines "
				"before Surf->init" << endl;
	}
	Surf->init(F, 0 /*verbose_level*/);
	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_two_lines "
				"after Surf->init" << endl;
	}


#if 0
	if (f_v) {
		cout << "before Surf->init_large_polynomial_domains" << endl;
	}
	Surf->init_large_polynomial_domains(0 /*verbose_level*/);
	if (f_v) {
		cout << "after Surf->init_large_polynomial_domains" << endl;
	}
#endif


	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_two_lines "
				"before Surf_A->init" << endl;
	}
	Surf_A->init(Surf, LG, 0 /*verbose_level - 1*/);
	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_two_lines "
				"after Surf_A->init" << endl;
	}


	surfaces_arc_lifting *SAL;

	SAL = NEW_OBJECT(surfaces_arc_lifting);

	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_two_lines "
				"before SAL->init" << endl;
	}
	SAL->init(
		LG->F, LG /* LG4 */,
		Surf_A,
		Control_six_arcs,
		f_test_nb_Eckardt_points, nb_E,
		verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_two_lines "
				"after SAL->init" << endl;
	}

	if (Descr->f_report) {
		if (f_v) {
			cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_two_lines "
					"before SAL->report" << endl;
		}
		SAL->report(Control_six_arcs->draw_options, verbose_level);
		if (f_v) {
			cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_two_lines "
					"after SAL->report" << endl;
		}

	}
	FREE_OBJECT(SAL);


	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_two_lines done" << endl;
	}

}

void group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs(
		poset_classification_control *Control1,
		poset_classification_control *Control2,
		poset_classification_control *Control_six_arcs,
		int f_test_nb_Eckardt_points, int nb_E,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs" << endl;
	}

	surface_with_action *Surf_A;
	surface_domain *Surf;
	number_theory_domain NT;



	Surf = NEW_OBJECT(surface_domain);
	Surf_A = NEW_OBJECT(surface_with_action);


	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs "
				"before Surf->init" << endl;
	}
	Surf->init(F, verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs "
				"after Surf->init" << endl;
	}


#if 0
	if (f_v) {
		cout << "before Surf->init_large_polynomial_domains" << endl;
	}
	Surf->init_large_polynomial_domains(0 /*verbose_level*/);
	if (f_v) {
		cout << "after Surf->init_large_polynomial_domains" << endl;
	}
#endif


	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs "
				"before Surf_A->init" << endl;
	}
	Surf_A->init(Surf, LG, verbose_level - 1);
	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs "
				"after Surf_A->init" << endl;
	}



	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs "
				"before Surf_A->Classify_trihedral_pairs->classify" << endl;
	}
	Surf_A->Classify_trihedral_pairs->classify(Control1, Control2, verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs "
				"after Surf_A->Classify_trihedral_pairs->classify" << endl;
	}

	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs "
				"before Surf_arc->classify_surfaces_through_arcs_and_trihedral_pairs" << endl;
	}

	surface_classify_using_arc *Surf_arc;

	Surf_arc = NEW_OBJECT(surface_classify_using_arc);


	Surf_arc->classify_surfaces_through_arcs_and_trihedral_pairs(
			Control_six_arcs,
			Surf_A,
			f_test_nb_Eckardt_points, nb_E,
			verbose_level);

	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs "
				"after Surf_arc->classify_surfaces_through_arcs_and_trihedral_pairs" << endl;
	}

	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs "
				"before Surf_arc->report" << endl;
	}


	if (Descr->f_draw_options) {
		Surf_arc->report(Descr->draw_options, verbose_level);
	}
	else {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs "
				"please use -draw_option for a report" << endl;
	}

	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs "
				"after Surf_arc->report" << endl;
	}

	FREE_OBJECT(Surf_arc);

	if (f_v) {
		cout << "group_theoretic_activity::do_classify_surfaces_through_arcs_and_trihedral_pairs done" << endl;
	}

}

void group_theoretic_activity::do_six_arcs(
		poset_classification_control *Control_six_arcs,
		int f_filter_by_nb_Eckardt_points, int nb_Eckardt_points,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_six_arcs" << endl;
	}

	finite_field *F;

	F = LG->F;


	surface_domain *Surf;

	if (f_v) {
			cout << "group_theoretic_activity::do_six_arcs before Surf->init" << endl;
	}
	Surf = NEW_OBJECT(surface_domain);
	Surf->init(F, 0/*verbose_level - 1*/);
	if (f_v) {
		cout << "group_theoretic_activity::do_six_arcs after Surf->init" << endl;
	}



	six_arcs_not_on_a_conic *Six_arcs;
	arc_generator_description *Six_arc_descr;

	int *transporter;

	Six_arcs = NEW_OBJECT(six_arcs_not_on_a_conic);

	Six_arc_descr = NEW_OBJECT(arc_generator_description);
	Six_arc_descr->F = F;
	Six_arc_descr->f_q = TRUE;
	Six_arc_descr->q = F->q;
	Six_arc_descr->f_n = TRUE;
	Six_arc_descr->n = 3;
	Six_arc_descr->f_target_size = TRUE;
	Six_arc_descr->target_size = 6;
	Six_arc_descr->Control = Control_six_arcs;



	// classify six arcs not on a conic:

	if (f_v) {
		cout << "group_theoretic_activity::do_six_arcs "
				"Setting up the group of the plane:" << endl;
	}



	if (f_v) {
		cout << "group_theoretic_activity::do_six_arcs "
				"before Six_arcs->init:" << endl;
	}


	Six_arcs->init(
			Six_arc_descr,
			LG->A_linear,
			Surf->P2,
			FALSE, 0, NULL,
			verbose_level);

	transporter = NEW_int(Six_arcs->Gen->A->elt_size_in_int);

	int nb_orbits;
	int level = 6;

	nb_orbits = Six_arcs->Gen->gen->nb_orbits_at_level(level);

	if (f_v) {
		cout << "group_theoretic_activity::do_six_arcs "
				"We found " << nb_orbits << " isomorphism types "
				"of 6-arcs" << endl;
	}



	long int Arc6[6];
	int h, a, b, c, d;
	int v1[3];
	int v2[3];


	if (f_v) {
		cout << "group_theoretic_activity::do_six_arcs "
				"testing the arcs" << endl;
	}

	longinteger_object ago;
	int *Abcd;
	int *Nb_E;
	int *Ago;

	Abcd = NEW_int(nb_orbits * 4);
	Nb_E = NEW_int(nb_orbits);
	Ago = NEW_int(nb_orbits);

	for (h = 0; h < nb_orbits; h++) {

		if (f_v) {
			cout << "group_theoretic_activity::do_six_arcs "
					"testing arc " << h << " / " << nb_orbits << endl;
		}


		Six_arcs->Gen->gen->get_set_by_level(level, h, Arc6);

		Six_arcs->Gen->gen->get_stabilizer_order(level, h, ago);

		if (Arc6[0] != 0) {
			cout << "Arc6[0] != 0" << endl;
			exit(1);
		}
		if (Arc6[1] != 1) {
			cout << "Arc6[1] != 1" << endl;
			exit(1);
		}
		if (Arc6[2] != 2) {
			cout << "Arc6[2] != 2" << endl;
			exit(1);
		}
		if (Arc6[3] != 3) {
			cout << "Arc6[3] != 3" << endl;
			exit(1);
		}
		Surf->P2->unrank_point(v1, Arc6[4]);
		Surf->P2->unrank_point(v2, Arc6[5]);
		if (v1[2] != 1) {
			cout << "v1[2] != 1" << endl;
			exit(1);
		}
		if (v2[2] != 1) {
			cout << "v2[2] != 1" << endl;
			exit(1);
		}
		a = v1[0];
		b = v1[1];
		c = v2[0];
		d = v2[1];

		Abcd[h * 4 + 0] = a;
		Abcd[h * 4 + 1] = b;
		Abcd[h * 4 + 2] = c;
		Abcd[h * 4 + 3] = d;

		eckardt_point_info *E;

		E = Surf->P2->compute_eckardt_point_info(Surf, Arc6, 0/*verbose_level*/);


		Nb_E[h] = E->nb_E;
		Ago[h] = ago.as_int();

		//cout << h << " : " << a << "," << b << "," << c << "," << d << " : " << E->nb_E << " : " << ago << endl;

		FREE_OBJECT(E);
	}

#if 0
	cout << "Summary of " << nb_orbits << " arcs:" << endl;
	for (h = 0; h < nb_orbits; h++) {
		a = Abcd[h * 4 + 0];
		b = Abcd[h * 4 + 1];
		c = Abcd[h * 4 + 2];
		d = Abcd[h * 4 + 3];

		cout << h << " : " << a << "," << b << "," << c << "," << d << " : " << Nb_E[h] << " : " << Ago[h] << endl;
	}
#endif

	tally C;

	C.init(Nb_E, nb_orbits, FALSE, 0);

	cout << "nb_E distribution: ";
	C.print_naked_tex(cout, FALSE);
	cout << endl;


	if (f_filter_by_nb_Eckardt_points) {
		cout << "Nonconical six-arcs associated with surfaces with " << nb_Eckardt_points << " Eckardt points in PG(2," << F->q << "):" << endl;

	}
	else {
		cout << "Nonconical six-arcs associated in PG(2," << F->q << "):" << endl;

	}
	int nb_E;
	int cnt = 0;

	cout << "$$" << endl;
	cout << "\\begin{array}{|r|c|r|}" << endl;
	cout << "\\hline" << endl;
	cout << "\\mbox{Orbit} & a,b,c,d & \\mbox{Ago} \\\\" << endl;
	cout << "\\hline" << endl;

	for (h = 0; h < nb_orbits; h++) {
		a = Abcd[h * 4 + 0];
		b = Abcd[h * 4 + 1];
		c = Abcd[h * 4 + 2];
		d = Abcd[h * 4 + 3];

		nb_E = Nb_E[h];

		if (f_filter_by_nb_Eckardt_points) {
			if (nb_E != nb_Eckardt_points) {
				continue;
			}
		}
		cout << h << " & " << a << "," << b << "," << c << "," << d << " & ";
		//<< Nb_E[h] << " & "
		cout << Ago[h] << "\\\\" << endl;

		cnt++;
	}
	cout << "\\hline" << endl;
	cout << "\\end{array}" << endl;
	cout << "$$" << endl;
	cout << "There are " << cnt << " such arcs.\\\\" << endl;


	FREE_int(Abcd);
	FREE_int(Nb_E);
	FREE_int(Ago);


	FREE_OBJECT(Six_arcs);
	FREE_OBJECT(Six_arc_descr);
	FREE_int(transporter);


	if (f_v) {
		cout << "group_theoretic_activity::do_six_arcs done" << endl;
	}

}

void group_theoretic_activity::do_cubic_surface_properties(
		std::string fname_csv, int defining_q,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties" << endl;
	}

	int i;
	finite_field *F0;
	finite_field *F;
	surface_domain *Surf;
	surface_with_action *Surf_A;
	projective_space_with_action *PA;
	number_theory_domain NT;
	sorting Sorting;
	file_io Fio;
	int f_semilinear;



	F0 = NEW_OBJECT(finite_field);
	F0->init(defining_q, 0);

	F = LG->F;

	f_semilinear = LG->A_linear->is_semilinear_matrix_group();


	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties before Surf->init" << endl;
	}
	Surf = NEW_OBJECT(surface_domain);
	Surf->init(F, verbose_level - 1);
	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties after Surf->init" << endl;
	}

	Surf_A = NEW_OBJECT(surface_with_action);

	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties before Surf_A->init" << endl;
	}
	Surf_A->init(Surf, LG, 0 /*verbose_level*/);
	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties after Surf_A->init" << endl;
	}

	PA = NEW_OBJECT(projective_space_with_action);

	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties before PA->init" << endl;
	}
	PA->init(
		F, 3 /*n*/, f_semilinear,
		TRUE /* f_init_incidence_structure */,
		verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties after PA->init" << endl;
	}



	long int *M;
	int nb_orbits, n;

	Fio.lint_matrix_read_csv(fname_csv, M, nb_orbits, n, verbose_level);

	if (n != 3) {
		cout << "group_theoretic_activity::do_cubic_surface_properties n != 3" << endl;
		exit(1);
	}

	int orbit_idx;

	long int *Rep;
	long int *Stab_order;
	long int *Orbit_length;
	long int *Nb_pts;
	long int *Nb_lines;
	long int *Nb_Eckardt_points;
	long int *Nb_singular_pts;
	long int *Nb_Double_points;
	long int *Ago;

	Rep = NEW_lint(nb_orbits);
	Stab_order = NEW_lint(nb_orbits);
	Orbit_length = NEW_lint(nb_orbits);
	Nb_pts = NEW_lint(nb_orbits);
	Nb_lines = NEW_lint(nb_orbits);
	Nb_Eckardt_points = NEW_lint(nb_orbits);
	Nb_singular_pts = NEW_lint(nb_orbits);
	Nb_Double_points = NEW_lint(nb_orbits);
	Ago = NEW_lint(nb_orbits);

	for (orbit_idx = 0; orbit_idx < nb_orbits; orbit_idx++) {
		if (f_v) {
			cout << "group_theoretic_activity::do_cubic_surface_properties orbit_idx = " << orbit_idx << " / " << nb_orbits << endl;
		}
		int coeff20[20];
		char str[1000];


		Rep[orbit_idx] = M[orbit_idx * 3 + 0];
		Stab_order[orbit_idx] = M[orbit_idx * 3 + 1];
		Orbit_length[orbit_idx] = M[orbit_idx * 3 + 2];

		cout << "Rep=" << Rep[orbit_idx] << endl;
		F0->PG_element_unrank_modified_lint(coeff20, 1, 20, Rep[orbit_idx]);
		cout << "coeff20=";
		int_vec_print(cout, coeff20, 20);
		cout << endl;

		surface_create_description *Descr;

		Descr = NEW_OBJECT(surface_create_description);
		Descr->f_q = TRUE;
		Descr->q = F->q;
		Descr->f_by_coefficients = TRUE;
		sprintf(str, "%d,0", coeff20[0]);
		Descr->coefficients_text.assign(str);
		for (i = 1; i < 20; i++) {
			sprintf(str, ",%d,%d", coeff20[i], i);
			Descr->coefficients_text.append(str);
		}
		cout << "Descr->coefficients_text = " << Descr->coefficients_text << endl;


		surface_create *SC;
		SC = NEW_OBJECT(surface_create);

		if (f_v) {
			cout << "group_theoretic_activity::do_cubic_surface_properties before SC->init" << endl;
		}
		SC->init(Descr, Surf_A, verbose_level);
		if (f_v) {
			cout << "group_theoretic_activity::do_cubic_surface_properties after SC->init" << endl;
		}


		if (SC->F->e == 1) {
			SC->F->f_print_as_exponentials = FALSE;
		}

		SC->F->PG_element_normalize(SC->SO->eqn, 1, 20);

		if (f_v) {
			cout << "group_theoretic_activity::do_cubic_surface_properties "
					"We have created the following surface:" << endl;
			cout << "$$" << endl;
			SC->Surf->print_equation_tex(cout, SC->SO->eqn);
			cout << endl;
			cout << "$$" << endl;

			cout << "$$" << endl;
			int_vec_print(cout, SC->SO->eqn, 20);
			cout << endl;
			cout << "$$" << endl;
		}


		// compute the group of the surface:

		if (f_v) {
			cout << "group_theoretic_activity::do_cubic_surface_properties "
					"before SC->compute_group" << endl;
		}
		SC->compute_group(PA, verbose_level);
		if (f_v) {
			cout << "group_theoretic_activity::do_cubic_surface_properties "
					"after SC->compute_group" << endl;
		}


		Nb_pts[orbit_idx] = SC->SO->nb_pts;
		Nb_lines[orbit_idx] = SC->SO->nb_lines;
		Nb_Eckardt_points[orbit_idx] = SC->SO->SOP->nb_Eckardt_points;
		Nb_singular_pts[orbit_idx] = SC->SO->SOP->nb_singular_pts;
		Nb_Double_points[orbit_idx] = SC->SO->SOP->nb_Double_points;
		Ago[orbit_idx] = SC->Sg->group_order_as_lint();

		//SC->SO->SOP->print_everything(ost, verbose_level);






		FREE_OBJECT(SC);
		FREE_OBJECT(Descr);


	}


	string fname_data;

	fname_data.assign(fname_csv);
	chop_off_extension(fname_data);

	char str[1000];
	sprintf(str, "_F%d.csv", F->q);
	fname_data.append(str);

	long int *Vec[9];
	char str_A[1000];
	char str_P[1000];
	char str_L[1000];
	char str_E[1000];
	char str_S[1000];
	char str_D[1000];
	sprintf(str_A, "Ago-%d", F->q);
	sprintf(str_P, "Nb_P-%d", F->q);
	sprintf(str_L, "Nb_L-%d", F->q);
	sprintf(str_E, "Nb_E-%d", F->q);
	sprintf(str_S, "Nb_S-%d", F->q);
	sprintf(str_D, "Nb_D-%d", F->q);
	const char *column_label[] = {
			"Rep",
			"StabOrder",
			"OrbitLength",
			str_A,
			str_P,
			str_L,
			str_E,
			str_S,
			str_D,
	};

	Vec[0] = Rep;
	Vec[1] = Stab_order;
	Vec[2] = Orbit_length;
	Vec[3] = Ago;
	Vec[4] = Nb_pts;
	Vec[5] = Nb_lines;
	Vec[6] = Nb_Eckardt_points;
	Vec[7] = Nb_singular_pts;
	Vec[8] = Nb_Double_points;

	Fio.lint_vec_array_write_csv(9 /* nb_vecs */, Vec, nb_orbits,
			fname_data, column_label);

	if (f_v) {
		cout << "Written file " << fname_data << " of size " << Fio.file_size(fname_data) << endl;
	}



	FREE_lint(M);
	FREE_OBJECT(PA);
	FREE_OBJECT(F0);

	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties done" << endl;
	}
}

struct cubic_surface_data_set {

	int orbit_idx;
	long int Rep;
	long int Stab_order;
	long int Orbit_length;
	long int Ago;
	long int Nb_pts;
	long int Nb_lines;
	long int Nb_Eckardt_points;
	long int Nb_singular_pts;
	long int Nb_Double_points;

};

void group_theoretic_activity::do_cubic_surface_properties_analyze(
		std::string fname_csv, int defining_q,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties_analyze" << endl;
	}

	//int i;
	finite_field *F0;
	finite_field *F;
	surface_domain *Surf;
	surface_with_action *Surf_A;
	projective_space_with_action *PA;
	number_theory_domain NT;
	sorting Sorting;
	file_io Fio;
	int f_semilinear;



	F0 = NEW_OBJECT(finite_field);
	F0->init(defining_q, 0);

	F = LG->F;

	f_semilinear = LG->A_linear->is_semilinear_matrix_group();


	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties_analyze before Surf->init" << endl;
	}
	Surf = NEW_OBJECT(surface_domain);
	Surf->init(F, verbose_level - 1);
	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties_analyze after Surf->init" << endl;
	}

	Surf_A = NEW_OBJECT(surface_with_action);

	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties_analyze before Surf_A->init" << endl;
	}
	Surf_A->init(Surf, LG, 0 /*verbose_level*/);
	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties_analyze after Surf_A->init" << endl;
	}

	PA = NEW_OBJECT(projective_space_with_action);

	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties_analyze before PA->init" << endl;
	}
	PA->init(
		F, 3 /*n*/, f_semilinear,
		TRUE /* f_init_incidence_structure */,
		verbose_level);
	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties_analyze after PA->init" << endl;
	}

	int nb_orbits, n;
	int orbit_idx;
	struct cubic_surface_data_set *Data;

	{
		long int *M;

		Fio.lint_matrix_read_csv(fname_csv, M, nb_orbits, n, verbose_level);

		if (n != 9) {
			cout << "group_theoretic_activity::do_cubic_surface_properties_analyze n != 9" << endl;
			exit(1);
		}





		Data = new struct cubic_surface_data_set [nb_orbits];

		for (orbit_idx = 0; orbit_idx < nb_orbits; orbit_idx++) {
			Data[orbit_idx].orbit_idx = orbit_idx;
			Data[orbit_idx].Rep = M[orbit_idx * n + 0];
			Data[orbit_idx].Stab_order = M[orbit_idx * n + 1];
			Data[orbit_idx].Orbit_length = M[orbit_idx * n + 2];
			Data[orbit_idx].Ago = M[orbit_idx * n + 3];
			Data[orbit_idx].Nb_pts = M[orbit_idx * n + 4];
			Data[orbit_idx].Nb_lines = M[orbit_idx * n + 5];
			Data[orbit_idx].Nb_Eckardt_points = M[orbit_idx * n + 6];
			Data[orbit_idx].Nb_singular_pts = M[orbit_idx * n + 7];
			Data[orbit_idx].Nb_Double_points = M[orbit_idx * n + 8];
		}
		FREE_lint(M);
	}
	long int *Nb_singular_pts;

	Nb_singular_pts = NEW_lint(nb_orbits);
	for (orbit_idx = 0; orbit_idx < nb_orbits; orbit_idx++) {
		Nb_singular_pts[orbit_idx] = Data[orbit_idx].Nb_singular_pts;
	}


	tally T_S;

	T_S.init_lint(Nb_singular_pts, nb_orbits, FALSE, 0);

	cout << "Classification by the number of singular points:" << endl;
	T_S.print(TRUE /* f_backwards */);

	{
		string fname_report;
		fname_report.assign(fname_csv);
		chop_off_extension(fname_report);
		fname_report.append("_report.tex");
		latex_interface L;
		file_io Fio;

		{
			ofstream ost(fname_report);
			L.head_easy(ost);

#if 0
			if (f_v) {
				cout << "group_theoretic_activity::do_cubic_surface_properties_analyze "
						"before get_A()->report" << endl;
			}

			if (!Descr->f_draw_options) {
				cout << "please use -draw_options" << endl;
				exit(1);
			}
			PA->A->report(ost,
					FALSE /* f_sims */,
					NULL, //A1/*LG->A_linear*/->Sims,
					FALSE /* f_strong_gens */,
					NULL,
					Descr->draw_options,
					verbose_level - 1);

			if (f_v) {
				cout << "group_theoretic_activity::do_cubic_surface_properties_analyze "
						"after LG->A_linear->report" << endl;
			}
#endif

			if (f_v) {
				cout << "group_theoretic_activity::do_cubic_surface_properties_analyze "
						"before report" << endl;
			}


			ost << "\\section{Surfaces over ${\\mathbb F}_{" << F->q << "}$}" << endl;


			ost << "Number of surfaces: " << nb_orbits << "\\\\" << endl;
			ost << "Classification by the number of singular points:" << endl;
			ost << "$$" << endl;
			T_S.print_file_tex_we_are_in_math_mode(ost, TRUE /* f_backwards */);
			ost << "$$" << endl;


			ost << "\\section{Singular Surfaces}" << endl;

			report_singular_surfaces(ost, Data, nb_orbits, verbose_level);

			ost << "\\section{Nonsingular Surfaces}" << endl;

			report_non_singular_surfaces(ost, Data, nb_orbits, verbose_level);



			if (f_v) {
				cout << "group_theoretic_activity::do_cubic_surface_properties_analyze "
						"after report" << endl;
			}

			L.foot(ost);
		}
		cout << "Written file " << fname_report << " of size "
				<< Fio.file_size(fname_report) << endl;
	}





	FREE_OBJECT(PA);
	FREE_OBJECT(F0);

	if (f_v) {
		cout << "group_theoretic_activity::do_cubic_surface_properties_analyze done" << endl;
	}
}

void group_theoretic_activity::report_singular_surfaces(std::ostream &ost,
		struct cubic_surface_data_set *Data, int nb_orbits, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::report_singular_surfaces" << endl;
	}

	struct cubic_surface_data_set *Data_S;
	int nb_S, h, orbit_idx;


	nb_S = 0;
	for (orbit_idx = 0; orbit_idx < nb_orbits; orbit_idx++) {
		if (Data[orbit_idx].Nb_singular_pts) {
			nb_S++;
		}
	}


	Data_S = new struct cubic_surface_data_set [nb_S];

	h = 0;
	for (orbit_idx = 0; orbit_idx < nb_orbits; orbit_idx++) {
		if (Data[orbit_idx].Nb_singular_pts) {
			Data_S[h] = Data[orbit_idx];
			h++;
		}
	}
	if (h != nb_S) {
		cout << "h != nb_S" << endl;
		exit(1);
	}

	long int *Selected_Nb_lines;


	Selected_Nb_lines = NEW_lint(nb_S);


	for (h = 0; h < nb_S; h++) {
		Selected_Nb_lines[h] = Data_S[h].Nb_lines;
	}

	tally T_L;

	T_L.init_lint(Selected_Nb_lines, nb_S, FALSE, 0);

	ost << "Number of surfaces: " << nb_S << "\\\\" << endl;
	ost << "Classification by the number of lines:" << endl;
	ost << "$$" << endl;
	T_L.print_file_tex_we_are_in_math_mode(ost, TRUE /* f_backwards */);
	ost << "$$" << endl;

	report_surfaces_by_lines(ost, Data_S, T_L, verbose_level);



	FREE_lint(Selected_Nb_lines);
	delete [] Data_S;

	if (f_v) {
		cout << "group_theoretic_activity::report_singular_surfaces done" << endl;
	}
}


void group_theoretic_activity::report_non_singular_surfaces(std::ostream &ost,
		struct cubic_surface_data_set *Data, int nb_orbits, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::report_non_singular_surfaces" << endl;
	}

	struct cubic_surface_data_set *Data_NS;
	int nb_NS, h, orbit_idx;


	nb_NS = 0;
	for (orbit_idx = 0; orbit_idx < nb_orbits; orbit_idx++) {
		if (Data[orbit_idx].Nb_singular_pts == 0) {
			nb_NS++;
		}
	}


	Data_NS = new struct cubic_surface_data_set [nb_NS];

	h = 0;
	for (orbit_idx = 0; orbit_idx < nb_orbits; orbit_idx++) {
		if (Data[orbit_idx].Nb_singular_pts == 0) {
			Data_NS[h] = Data[orbit_idx];
			h++;
		}
	}
	if (h != nb_NS) {
		cout << "h != nb_NS" << endl;
		exit(1);
	}

	long int *Selected_Nb_lines;


	Selected_Nb_lines = NEW_lint(nb_NS);


	for (h = 0; h < nb_NS; h++) {
		Selected_Nb_lines[h] = Data_NS[h].Nb_lines;
	}

	for (h = 0; h < nb_NS; h++) {
		cout << h << " : " << Data_NS[h].orbit_idx << " : " << Data_NS[h].Nb_lines << endl;
	}

	tally T_L;

	T_L.init_lint(Selected_Nb_lines, nb_NS, FALSE, 0);

	ost << "Number of surfaces: " << nb_NS << "\\\\" << endl;
	ost << "Classification by the number of lines:" << endl;
	ost << "$$" << endl;
	T_L.print_file_tex_we_are_in_math_mode(ost, TRUE /* f_backwards */);
	ost << "$$" << endl;


	report_surfaces_by_lines(ost, Data_NS, T_L, verbose_level);


	FREE_lint(Selected_Nb_lines);
	delete [] Data_NS;

	if (f_v) {
		cout << "group_theoretic_activity::report_non_singular_surfaces done" << endl;
	}
}

void group_theoretic_activity::report_surfaces_by_lines(std::ostream &ost,
		struct cubic_surface_data_set *Data, tally &T, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "group_theoretic_activity::report_non_singular_surfaces" << endl;
	}

	int i, j, f, l, a, idx;

	for (i = T.nb_types - 1; i >= 0; i--) {
		f = T.type_first[i];
		l = T.type_len[i];
		a = T.data_sorted[f];

		int nb_L;
		struct cubic_surface_data_set *Data_L;

		nb_L = l;

		Data_L = new struct cubic_surface_data_set [nb_L];

		ost << "The number of surfaces with exactly " << a << " lines is " << nb_L << ": \\\\" << endl;

		for (j = 0; j < l; j++) {
			idx = T.sorting_perm_inv[f + j];
			Data_L[j] = Data[idx];

		}


		for (j = 0; j < l; j++) {
			ost << j
					<< " : id=" << Data_L[j].orbit_idx
					<< " : P=" << Data_L[j].Nb_pts
					<< " : S=" << Data_L[j].Nb_singular_pts
					<< " : E=" << Data_L[j].Nb_Eckardt_points
					<< " : D=" << Data_L[j].Nb_Double_points
					<< " : ago=" << Data_L[j].Ago
					<< " : Rep=" << Data_L[j].Rep
				<< "\\\\" << endl;
		}

		delete [] Data_L;
	}

}
}}

