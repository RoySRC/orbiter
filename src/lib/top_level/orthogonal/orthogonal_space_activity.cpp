/*
 * orthogonal_space_activity.cpp
 *
 *  Created on: Jan 12, 2021
 *      Author: betten
 */




#include "orbiter.h"

using namespace std;

namespace orbiter {
namespace top_level {
namespace orthogonal_geometry {


orthogonal_space_activity::orthogonal_space_activity()
{
	Descr = NULL;
	OA = NULL;
	Blt_set_domain = NULL;

}

orthogonal_space_activity::~orthogonal_space_activity()
{
	if (Blt_set_domain) {
		FREE_OBJECT(Blt_set_domain);
	}
	if (OA) {
		FREE_OBJECT(OA);
	}
}

void orthogonal_space_activity::init(orthogonal_space_activity_description *Descr,
		orthogonal_space_with_action *OA,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "orthogonal_space_activity::init" << endl;
	}

	orthogonal_space_activity::Descr = Descr;
	orthogonal_space_activity::OA = OA;



	if (f_v) {
		cout << "orthogonal_space_activity::init done" << endl;
	}
}


void orthogonal_space_activity::perform_activity(int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "orthogonal_space_activity::perform_activity" << endl;
	}

	if (Descr->f_create_BLT_set) {

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_create_BLT_set" << endl;
		}


		Blt_set_domain = NEW_OBJECT(blt_set_domain);

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity before Blt_set_domain->init" << endl;
		}
		Blt_set_domain->init(OA->O, verbose_level);
		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity after Blt_set_domain->init" << endl;
		}

		BLT_set_create *BC;

		BC = NEW_OBJECT(BLT_set_create);

		BC->init(Blt_set_domain, Descr->BLT_Set_create_description, OA, verbose_level);

		latex_interface L;


		cout << "We have created the following BLT-set:" << endl;
		cout << "$$" << endl;
		L.lint_set_print_tex(cout, BC->set, OA->Descr->F->q + 1);
		cout << endl;
		cout << "$$" << endl;

		if (BC->f_has_group) {
			cout << "The stabilizer is generated by:" << endl;
			BC->Sg->print_generators_tex(cout);
		}

		BC->report(verbose_level);

		FREE_OBJECT(BC);


		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_create_BLT_set done" << endl;
		}

	}
	else if (Descr->f_BLT_set_starter) {

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_BLT_set_starter" << endl;
		}


		Blt_set_domain = NEW_OBJECT(blt_set_domain);

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity before Blt_set_domain->init" << endl;
		}
		Blt_set_domain->init(OA->O, verbose_level);
		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity after Blt_set_domain->init" << endl;
		}


		blt_set_classify *BLT_classify;

		BLT_classify = NEW_OBJECT(blt_set_classify);

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity before BLT_classify->init_basic" << endl;
		}
		BLT_classify->init_basic(OA->A,
				OA->A->Strong_gens,
				Descr->BLT_set_starter_size,
				verbose_level);
		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity after BLT_classify->init_basic" << endl;
		}

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity before BLT_classify->compute_starter" << endl;
		}
		BLT_classify->compute_starter(
				Descr->BLT_set_starter_control,
				verbose_level);
		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity after BLT_classify->compute_starter" << endl;
		}

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_BLT_set_starter done" << endl;
		}

	}

	else if (Descr->f_BLT_set_graphs) {

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_BLT_set_graphs" << endl;
		}


		Blt_set_domain = NEW_OBJECT(blt_set_domain);

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity before Blt_set_domain->init" << endl;
		}
		Blt_set_domain->init(OA->O, verbose_level);
		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity after Blt_set_domain->init" << endl;
		}


		blt_set_classify *BLT_classify;

		BLT_classify = NEW_OBJECT(blt_set_classify);

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity before BLT_classify->init_basic" << endl;
		}
		BLT_classify->init_basic(OA->A,
				OA->A->Strong_gens,
				Descr->BLT_set_graphs_starter_size,
				verbose_level);
		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity after BLT_classify->init_basic" << endl;
		}


		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity before BLT_classify->create_graphs" << endl;
		}


		BLT_classify->create_graphs(
				Descr->BLT_set_graphs_r,
				Descr->BLT_set_graphs_m,
				Descr->BLT_set_graphs_starter_size - 1,
				TRUE /* f_lexorder_test */, FALSE /* f_eliminate_graphs_if_possible */,
				verbose_level);

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity after BLT_classify->create_graphs" << endl;
		}

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_BLT_set_graphs done" << endl;
		}

	}


	else if (Descr->f_cheat_sheet_orthogonal) {

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity before OA->report" << endl;
		}

		if (!Orbiter->f_draw_options) {
			cout << "please use -draw_options ... -end" << endl;
			exit(1);
		}

		OA->report(Orbiter->draw_options,
				verbose_level);


		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity after OA->report" << endl;
		}

	}

	else if (Descr->f_unrank_line_through_two_points) {

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_unrank_line_through_two_points" << endl;
		}

		long int p1;
		long int p2;
		long int rk;
		data_structures::string_tools ST;

		p1 = ST.strtolint(Descr->unrank_line_through_two_points_p1);
		p2 = ST.strtolint(Descr->unrank_line_through_two_points_p2);

		if (f_v) {
			cout << "point rank p1 = " << p1 << endl;
			cout << "point rank p2 = " << p2 << endl;
		}

		rk = OA->O->rank_line(p1, p2, verbose_level);

		if (TRUE) {
			cout << "line rank = " << rk << endl;
		}

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_unrank_line_through_two_points done" << endl;
		}

	}

	else if (Descr->f_lines_on_point) {

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_lines_on_point" << endl;
		}

		long int *line_pencil_line_ranks;

		line_pencil_line_ranks = NEW_lint(OA->O->alpha);

		if (f_v) {
			cout << "point rank = " << Descr->lines_on_point_rank << endl;
		}

		OA->O->lines_on_point_by_line_rank(Descr->lines_on_point_rank,
				line_pencil_line_ranks, verbose_level);

		if (TRUE) {
			cout << "There are " << OA->O->alpha << " lines on point = "
					<< Descr->lines_on_point_rank << ". They are: ";
			Orbiter->Lint_vec->print_fully(cout, line_pencil_line_ranks, OA->O->alpha);
			cout << endl;
		}

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_lines_on_point done" << endl;
		}

	}

	else if (Descr->f_perp) {

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_perp" << endl;
		}

		long int *pts;
		int nb_pts;

		Orbiter->Lint_vec->scan(Descr->perp_text.c_str(), pts, nb_pts);

		if (f_v) {
			cout << "Computing the common perp of the set ";
			Orbiter->Lint_vec->print(cout, pts, nb_pts);
			cout << endl;
		}

		long int *Perp;
		int sz;


		OA->O->perp_of_k_points(pts, nb_pts, Perp, sz, verbose_level);

		cout << "The common perp of the set has size " << sz << " and is ";
		Orbiter->Lint_vec->print_fully(cout, Perp, sz);
		cout << endl;

		FREE_lint(Perp);
		FREE_lint(pts);

		if (f_v) {
			cout << "orthogonal_space_activity::perform_activity f_perp done" << endl;
		}

	}

	else if (Descr->f_set_stabilizer) {

		set_stabilizer(OA,
				Descr->set_stabilizer_intermediate_set_size,
				Descr->set_stabilizer_fname_mask,
				Descr->set_stabilizer_nb,
				Descr->set_stabilizer_column_label,
				Descr->set_stabilizer_fname_out,
				verbose_level);
	}
	if (Descr->f_export_point_line_incidence_matrix) {

		OA->O->export_incidence_matrix_to_csv(verbose_level);
	}




	if (f_v) {
		cout << "orthogonal_space_activity::perform_activity done" << endl;
	}

}


void orthogonal_space_activity::set_stabilizer(
		orthogonal_space_with_action *OA,
		int intermediate_subset_size,
		std::string &fname_mask, int nb, std::string &column_label,
		std::string &fname_out,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);


	if (f_v) {
		cout << "orthogonal_space_activity::set_stabilizer" << endl;
	}


	substructure_classifier SubC;

	SubC.set_stabilizer_in_any_space(
			OA->A, OA->A, OA->A->Strong_gens,
			intermediate_subset_size,
			fname_mask, nb, column_label,
			fname_out,
			verbose_level);



#if 0
	top_level_geometry_global T;

	T.set_stabilizer_orthogonal_space(
				OA,
				intermediate_subset_size,
				fname_mask, nb, column_label,
				verbose_level);
#endif

	if (f_v) {
		cout << "orthogonal_space_activity::set_stabilizer done" << endl;
	}

}



}}}

