/*
 * design_create_main.cpp
 *
 *  Created on: Sep 19, 2019
 *      Author: betten
 */


#include "orbiter.h"

using namespace std;


using namespace orbiter;
using namespace orbiter::top_level;

// global data:

int t0; // the system time when the program started

int main(int argc, const char **argv);

int main(int argc, const char **argv)
{
	int verbose_level = 0;
	int i;
	int f_design = FALSE;
	design_create_description *Descr;
	int f_depth = FALSE;
	int depth = 0;
	int f_output_prefix = FALSE;
	const char *output_prefix = "";
	int f_read_classification = FALSE;
	int read_classification_level = 0;
	int f_lift_this = FALSE;
	const char *lift_this_set = NULL;
	int f_lift_this_with_group = FALSE;
	const char *lift_this_with_group_set = NULL;
	const char *lift_this_with_group_order = NULL;
	const char *lift_this_with_group_prefix = NULL;
	const char *lift_this_with_group_label = NULL;
	const char *lift_this_with_group_generator = NULL;
	int f_lift_case = FALSE;
	int lift_case_level = 0;
	int lift_case = 0;
	int f_sylow_select = FALSE;
	int sylow_select_prime = 0;
	int f_cyclic_subgroup_with_n_fixpoints = FALSE;
	int cyclic_subgroup_with_n_fixpoints = 0;
	int f_read_solution_file = FALSE;
	const char *solution_file_name = NULL;
	os_interface Os;

	t0 = Os.os_ticks();


	for (i = 1; i < argc; i++) {
		if (strcmp(argv[i], "-v") == 0) {
			verbose_level = atoi(argv[++i]);
			cout << "-v " << verbose_level << endl;
		}
		else if (strcmp(argv[i], "-design") == 0) {
			f_design = TRUE;
			Descr = NEW_OBJECT(design_create_description);
			i += Descr->read_arguments(argc - (i - 1),
					argv + i, verbose_level) - 1;

			cout << "-design" << endl;
		}
		else if (strcmp(argv[i], "-depth") == 0) {
			f_depth = TRUE;
			depth = atoi(argv[++i]);
			cout << "-depth " << depth << endl;
		}
		else if (strcmp(argv[i], "-output_prefix") == 0) {
			f_output_prefix = TRUE;
			output_prefix = argv[++i];
			cout << "-output_prefix " << output_prefix << endl;
		}
		else if (strcmp(argv[i], "-read_classification") == 0) {
			f_read_classification = TRUE;
			read_classification_level = atoi(argv[++i]);
			cout << "-read_classification " << read_classification_level << endl;
		}
		else if (strcmp(argv[i], "-lift_this") == 0) {
			f_lift_this = TRUE;
			lift_this_set = argv[++i];
			cout << "-lift_this " << lift_this_set << endl;
		}
		else if (strcmp(argv[i], "-lift_this_with_group") == 0) {
			f_lift_this_with_group = TRUE;
			lift_this_with_group_set = argv[++i];
			lift_this_with_group_order = argv[++i];
			lift_this_with_group_prefix = argv[++i];
			lift_this_with_group_label = argv[++i];
			lift_this_with_group_generator = argv[++i];
			cout << "-lift_this_with_group " << lift_this_with_group_set
					<< " " << lift_this_with_group_order
					<< " " << lift_this_with_group_prefix
					<< " " << lift_this_with_group_label
					<< " " << lift_this_with_group_generator << endl;
		}
		else if (strcmp(argv[i], "-lift_case") == 0) {
			f_lift_case = TRUE;
			lift_case_level = atoi(argv[++i]);
			lift_case = atoi(argv[++i]);
			cout << "-lift_case " << lift_case_level << " " << lift_case << endl;
		}
		else if (strcmp(argv[i], "-read_solution_file") == 0) {
			f_read_solution_file = TRUE;
			solution_file_name = argv[++i];
			cout << "-read_solution_file " << solution_file_name << endl;
		}
		else if (strcmp(argv[i], "-sylow_select") == 0) {
			f_sylow_select = TRUE;
			sylow_select_prime = atoi(argv[++i]);
			cout << "-sylow_select " << sylow_select_prime << endl;
		}
		else if (strcmp(argv[i], "-cyclic_subgroup_with_n_fixpoints") == 0) {
			f_cyclic_subgroup_with_n_fixpoints = TRUE;
			cyclic_subgroup_with_n_fixpoints = atoi(argv[++i]);
			cout << "-cyclic_subgroup_with_n_fixpoints "
					<< cyclic_subgroup_with_n_fixpoints << endl;
		}
	}
	if (!f_design) {
		cout << "please use option -design ... "
				"to enter a description of the design" << endl;
		exit(1);
	}

	design_create *DC;
	latex_interface L;
	//int j;

	DC = NEW_OBJECT(design_create);

	cout << "before DC->init" << endl;
	DC->init(Descr, verbose_level);
	cout << "after DC->init" << endl;



	action *A;
	//int *Elt1;
	int *Elt2;

	A = DC->A;

	Elt2 = NEW_int(A->elt_size_in_int);



#if 0
	if (DC->f_has_group) {
		for (i = 0; i < BC->Sg->gens->len; i++) {
			cout << "Testing generator " << i << " / "
					<< BC->Sg->gens->len << endl;
			A->element_invert(BC->Sg->gens->ith(i),
					Elt2, 0 /*verbose_level*/);


			cout << "Generator " << i << " / " << SC->Sg->gens->len
					<< " is good" << endl;
			}
		}
	else {
		cout << "We do not have information about the "
				"automorphism group" << endl;
		}
#endif


	cout << "We have created the following design:" << endl;
	cout << "$$" << endl;
	L.lint_set_print_tex(cout, DC->set, DC->sz);
	cout << endl;
	cout << "$$" << endl;

	if (DC->f_has_group) {
		cout << "The stabilizer is generated by:" << endl;
		DC->Sg->print_generators_tex(cout);
		}


	orbit_of_sets *SetOrb;

	SetOrb = NEW_OBJECT(orbit_of_sets);

	cout << "computing orbit:" << endl;
	SetOrb->init(DC->A, DC->A2,
			DC->set, DC->sz, DC->A->Strong_gens->gens,
			verbose_level);
	cout << "computing orbit done" << endl;


	large_set_classify *LS;

	LS = NEW_OBJECT(large_set_classify);

	int f_lexorder_test = TRUE;
	char base_fname[1000];
	const char *design_tables_prefix = "";

	sprintf(base_fname, "LS_%s", DC->prefix);
	LS->init(DC,
			output_prefix, base_fname,
			depth,
			f_lexorder_test,
			design_tables_prefix,
			verbose_level);

	LS->init_designs(SetOrb, verbose_level);

	if (f_read_classification) {
		cout << "reading classification at level "
				<< read_classification_level << endl;

		orbit_transversal *T;

		LS->read_classification(T,
				read_classification_level, verbose_level);

		cout << "computing and reporting ago distribution:" << endl;

		T->report_ago_distribution(cout);

		FREE_OBJECT(T);
	}
	else if (f_lift_this) {
		cout << "lifting a given set" << endl;
		int *lift_starter;
		int lift_starter_sz;


		int_vec_scan(lift_this_set, lift_starter, lift_starter_sz);
		cout << "lift_starter = ";
		int_vec_print(cout, lift_starter, lift_starter_sz);
		cout << endl;


	}
	else if (f_lift_this_with_group) {
		cout << "lifting a given set with a given group" << endl;

		long int *lift_starter;
		int lift_starter_sz;


		lint_vec_scan(lift_this_with_group_set, lift_starter, lift_starter_sz);

		cout << "lift_starter = ";
		lint_vec_print(cout, lift_starter, lift_starter_sz);
		cout << endl;


		int *gens_data;
		int gens_data_sz;
		int nb_elements;

		int_vec_scan(lift_this_with_group_generator, gens_data, gens_data_sz);
		cout << "gens_data = ";
		int_vec_print(cout, gens_data, gens_data_sz);
		cout << endl;


		nb_elements = gens_data_sz / A->make_element_size;

		strong_generators *SG;
		vector_ge *nice_gens;
		int orbit_length;

		SG = NEW_OBJECT(strong_generators);

		cout << "before SG->init_from_data_with_target_go_ascii" << endl;
		SG->init_from_data_with_target_go_ascii(A,
				gens_data,
				nb_elements, A->make_element_size,
				lift_this_with_group_order,
				nice_gens,
				verbose_level);

		// computing the normalizer:
		strong_generators *gens_N;
		{
			sims *G;
			sims *H;
			char fname_magma_prefix[1000];

			sprintf(fname_magma_prefix, "%s_normalizer", A->label);

			if (!A->f_has_sims) {
				cout << "A does not have sims" << endl;
				exit(1);
			}
			G = A->Sims;
			H = SG->create_sims(verbose_level - 2);
			A->normalizer_using_MAGMA(fname_magma_prefix,
					G, H, gens_N, verbose_level);
			cout << "generators for the normalizer are:" << endl;
			gens_N->print_generators_tex(cout);
			FREE_OBJECT(H);
		}

		orbit_length = SG->group_order_as_lint();

		cout << "The group is generated by the following strong generating set:" << endl;
		SG->print_elements_latex_ost(cout);

		long int *Large_sets;
		int nb_large_sets;

		LS->process_starter_case(lift_starter, lift_starter_sz,
				SG, lift_this_with_group_prefix,
				lift_this_with_group_label, orbit_length,
				f_read_solution_file, solution_file_name,
				Large_sets, nb_large_sets,
				TRUE /* f_compute_normalizer_orbits */, gens_N,
				verbose_level);
		cout << "processing starter case done" << endl;

		FREE_OBJECT(SG);
		FREE_OBJECT(nice_gens);

		cout << "lifting a given set with a given group done" << endl;
	}
	else if (f_lift_case) {
		cout << "lifting a single case" << endl;

		set_and_stabilizer *Rep;

		LS->read_classification_single_case(Rep,
				lift_case_level, lift_case, verbose_level);

		cout << "the set in case " << lift_case << " is:" << endl;
		Rep->print_set_tex(cout);
		cout << endl;

		cout << "The designs are:" << endl;
		for (i = 0; i < Rep->sz; i++) {
			int a;

			a = Rep->data[i];
			cout << i << " & " << a << " & ";
			lint_vec_print(cout, LS->Design_table + a * LS->design_size, LS->design_size);
			cout << endl;
		}

		cout << "The blocks of the designs are:" << endl;
		int *block;

		block = NEW_int(LS->DC->k);

		for (i = 0; i < Rep->sz; i++) {
			int a, b, j;

			a = Rep->data[i];
			cout << "design " << i << " is " << a << " has the following blocks:" << endl;
			for (j = 0; j < LS->design_size; j++) {
				b = LS->Design_table[a * LS->design_size + j];
				LS->DC->unrank_block_in_PG_2_q(block,
						b, 0 /*verbose_level*/);
				cout << "block " << j << " is " << b << " : ";
				int_vec_print(cout, block, LS->DC->k);
				cout << endl;
			}
		}

		FREE_int(block);


		cout << "strong generators are:" << endl;
		Rep->Strong_gens->print_generators_tex();

		cout << "The elements are:" << endl;
		Rep->Strong_gens->print_elements_ost(cout);

		sylow_structure *Syl;
		sims *S;

		cout << "creating Sims:" << endl;
		S = Rep->Strong_gens->create_sims(0 /* verbose_level */);
		Syl = NEW_OBJECT(sylow_structure);

		cout << "creating Sylow structure:" << endl;
		Syl->init(S, 0 /*verbose_level*/);
		Syl->report(cout);

#if 0
		cout << "processing starter case with full stabilizer:" << endl;
		LS->process_starter_case(Rep, Rep->Strong_gens, verbose_level);
		cout << "processing starter case done" << endl;
#else
		int sylow_select;

		for (sylow_select = 0; sylow_select < Syl->nb_primes; sylow_select++) {

			if (f_sylow_select) {
				if (Syl->primes[sylow_select] != sylow_select_prime) {
					cout << "skipping this prime because of -sylow_select" << endl;
					continue;
				}
			}
			cout << "processing starter case with Sylow subgroup "
					<< sylow_select << " / " << Syl->nb_primes << " of stabilizer, "
					"for p=" << Syl->primes[sylow_select] << endl;
			char prefix[1000];
			char group_label[1000];
			int orbit_length;

			orbit_length = Syl->primes[sylow_select];
			sprintf(prefix, "Case_%d_", lift_case);
			sprintf(group_label, "Syl_%d", Syl->primes[sylow_select]);

			long int *Large_sets;
			int nb_large_sets;

			strong_generators *SG1;

			if (f_cyclic_subgroup_with_n_fixpoints) {
				cout << "finding cyclic subgroup with n fixpoints, for n = "
						<< cyclic_subgroup_with_n_fixpoints << endl;
				SG1 = Syl->Sub[sylow_select].SG->find_cyclic_subgroup_with_exactly_n_fixpoints(
						cyclic_subgroup_with_n_fixpoints, A, verbose_level);
			}
			else {
				SG1 = Syl->Sub[sylow_select].SG;
			}
			cout << "considering the group generated by:" << endl;
			SG1->print_generators_tex();
			LS->process_starter_case(Rep->data, Rep->sz, SG1,
					prefix, group_label, orbit_length,
					f_read_solution_file, solution_file_name,
					Large_sets, nb_large_sets,
					FALSE /* f_compute_normalizer_orbits */, NULL /* gens_N */,
					verbose_level);
			cout << "processing starter case done" << endl;
			if (f_read_solution_file) {
				cout << "We found " << nb_large_sets << " large sets" << endl;
				lint_matrix_print(Large_sets, nb_large_sets, LS->size_of_large_set);
			}
		}
#endif
	}
	else {
		if (f_depth) {
			cout << "classification of subsets of size " << depth << endl;
			LS->gen->depth = depth;

			LS->compute(verbose_level);
		}
	}

	FREE_int(Elt2);

	FREE_OBJECT(DC);

	the_end(t0);
	//the_end_quietly(t0);
}

