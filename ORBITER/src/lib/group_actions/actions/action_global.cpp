// action_global.C
//
// Anton Betten
// October 10, 2013

#include "foundations/foundations.h"
#include "group_actions.h"

using namespace std;


namespace orbiter {
namespace group_actions {

//static void print_from_to(int d, int i, int j, int *v1, int *v2);

action *create_automorphism_group_from_group_table(
	const char *fname_base,
	int *Table, int group_order, int *gens, int nb_gens, 
	strong_generators *&Aut_gens, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int *N_gens;
	int N_nb_gens;
	int N_go;
	longinteger_object go;
	//int i;

	if (f_v) {
		cout << "create_automorphism_group_from_group_table" << endl;
		}
	
	magma_normalizer_in_Sym_n(fname_base,
		group_order, Table, gens, nb_gens,
		N_gens, N_nb_gens, N_go, verbose_level);

	cout << "The holomorph has order " << N_go
			<< " and is generated by " << N_nb_gens << " elements" << endl;
	go.create(N_go);

#if 0
	for (i = 0; i < N_nb_gens; i++) {
		cout << "holomorph generator " << i << " / "
				<< N_nb_gens << ":" << endl;

		ord = perm_order(N_gens + i * H->group_order, H->group_order);
		cout << "an element of order " << ord << endl;
		for (j = 0; j < nb_gens; j++) {
			a = gens[j];
			b = N_gens[i * H->group_order + a];
			cout << a << " -> " << b << " : ";
			H->unrank_element(H->Elt1, a);
			H->unrank_element(H->Elt2, b);
			int_vec_print(cout, H->Elt1, H->len);
			cout << " -> ";
			int_vec_print(cout, H->Elt2, H->len);
			cout << endl;
			}
		}
	given_base_length = H->len;
	given_base = NEW_int(given_base_length);
	for (i = 0; i < given_base_length; i++) {
		given_base[i] = i_power_j(q, i);
		}
	cout << "given base: ";
	int_vec_print(cout, given_base, given_base_length);
	cout << endl;
#endif

	action *A;
	
	A = NEW_OBJECT(action);


	cout << "creating holomorph" << endl;
	A->init_permutation_group_from_generators(
		group_order /* degree */,
		TRUE, go, 
		N_nb_gens, N_gens, 
		nb_gens /* given_base_length */, gens /* given_base */,
		verbose_level);
	{
	longinteger_object go;
	A->group_order(go);
	cout << "The order of the holomorph is " << go << endl;
	}

	longinteger_object Aut_order;
	cout << "creating automorphism group" << endl;
	Aut_gens = A->Strong_gens->point_stabilizer(0 /* pt */, verbose_level);
	Aut_gens->group_order(Aut_order);
	cout << "The automorphism group has order " << Aut_order << endl;

	return A;
}

void create_linear_group(sims *&S, action *&A, 
	finite_field *F, int m, 
	int f_projective, int f_general, int f_affine, 
	int f_semilinear, int f_special, 
	vector_ge *&nice_gens,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	//int f_vv = (verbose_level >= 2);
	int f_basis = TRUE;
	
	if (f_v) {
		cout << "action_global.C create_linear_group "
				"m=" << m << " q=" << F->q << endl;
		}

	A = NEW_OBJECT(action);

	if (f_projective) {
		if (f_v) {
			cout << "action_global.C before init_projective_group "
					"m=" << m << " q=" << F->q
					<< " f_semilinear=" << f_semilinear << endl;
			}
		A->init_projective_group(m, F, f_semilinear, 
			f_basis,
			nice_gens,
			verbose_level);
		}
	else if (f_general) {
		if (f_v) {
			cout << "action_global.C before init_general_linear_group "
					"m=" << m << " q=" << F->q
					<< " f_semilinear=" << f_semilinear << endl;
			}
		A->init_general_linear_group(m, F, f_semilinear, 
			f_basis,
			nice_gens,
			verbose_level);
		}
	else if (f_affine) {
		if (f_v) {
			cout << "action_global.C before init_affine_group "
					"m=" << m << " q=" << F->q
					<< " f_semilinear=" << f_semilinear << endl;
			}
		A->init_affine_group(m, F, f_semilinear, 
			f_basis,
			nice_gens,
			verbose_level);
		}
	else {
		cout << "action_global.C create_linear_group "
				"the type of group is not specified" << endl;
		exit(1);
		}


	if (!A->f_has_strong_generators) {
		cout << "action_global.C create_linear_group "
				"fatal: !A->f_has_strong_generators" << endl;
		}



	if (f_special) {


		if (f_v) {
			cout << "action_global.C create_linear_group "
					"computing intersection with "
					"special linear group" << endl;
			}


		action A_on_det;
		longinteger_object go;
		
		A_on_det.induced_action_on_determinant(A->Sims, verbose_level);
		if (f_v) {
			cout << "action_global.C create_linear_group "
					"induced_action_on_determinant finished" << endl;
			}
		A_on_det.Kernel->group_order(go);
		if (f_v) {
			cout << "action_global.C create_linear_group "
					"intersection has order " << go << endl;
			}
		

		strong_generators *SG;

		SG = NEW_OBJECT(strong_generators);
		if (f_v) {
			cout << "action_global.C creating strong generators "
					"for the kernel n the action "
					"on the determinant" << endl;
			}
		
		SG->init_from_sims(A_on_det.Kernel, 0 /* verbose_level */);
		S = SG->create_sims(0 /* verbose_level */);
		FREE_OBJECT(SG);
		}
	else {

		S = A->Strong_gens->create_sims(0 /* verbose_level */);
		}

	if (f_v) {
		cout << "action_global.C create_linear_group "
				"sims object has been created" << endl;
		}


	
	


	
	if (f_v) {
		A->print_base();
#if 0
		if (f_projective) {
			display_all_PG_elements(m - 1, *F);
			}
#endif
		}
	
	

	if (f_v) {
		cout << "action_global.C create_linear_group finished" << endl;
		}
}



action *create_induced_action_by_restriction(action *A,
		sims *S, int size, int *set, int f_induce,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	action *A2;

	if (f_v) {
		cout << "create_induced_action_by_restriction" << endl;
		}
	A2 = NEW_OBJECT(action);
	A2->induced_action_by_restriction(*A,
			f_induce,  S, size, set, verbose_level - 1);
	if (f_v) {
		cout << "create_induced_action_by_restriction done" << endl;
		}
	return A2;
}

action *create_induced_action_on_sets(action *A,
		sims *S, int nb_sets, int set_size, int *sets, int f_induce,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	action *A2;

	if (f_v) {
		cout << "create_induced_action_on_sets" << endl;
		}
	A2 = NEW_OBJECT(action);
	A2->induced_action_on_sets(*A,
			S, nb_sets, set_size, sets, f_induce, verbose_level - 1);
	if (f_v) {
		cout << "create_induced_action_on_sets done" << endl;
		}
	return A2;
}


void create_orbits_on_subset_using_restricted_action(
		action *&A_by_restriction,
		schreier *&Orbits, action *A, sims *S,
		int size, int *set,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_induce = FALSE;

	if (f_v) {
		cout << "create_orbits_on_subset_using_restricted_action" << endl;
		}
	A_by_restriction = create_induced_action_by_restriction(A,
			S, size, set, f_induce, verbose_level - 1);
	Orbits = NEW_OBJECT(schreier);

	A_by_restriction->compute_all_point_orbits(*Orbits,
			S->gens, verbose_level - 2);
	if (f_v) {
		cout << "create_orbits_on_subset_using_restricted_action done" << endl;
		}
	
}

void create_orbits_on_sets_using_action_on_sets(
		action *&A_on_sets,
		schreier *&Orbits, action *A, sims *S,
		int nb_sets, int set_size, int *sets,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_induce = FALSE;

	if (f_v) {
		cout << "create_orbits_on_sets_using_action_on_sets" << endl;
		}
	A_on_sets = create_induced_action_on_sets(A,
			S, nb_sets, set_size, sets, f_induce, verbose_level - 1);
	Orbits = NEW_OBJECT(schreier);

	A_on_sets->compute_all_point_orbits(*Orbits, S->gens, verbose_level - 2);
	if (f_v) {
		cout << "create_orbits_on_sets_using_action_on_sets done" << endl;
		}
	
}


action *new_action_by_right_multiplication(
		sims *group_we_act_on,
		int f_transfer_ownership,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	action *A;

	if (f_v) {
		cout << "new_action_by_right_multiplication" << endl;
		}
	A = NEW_OBJECT(action);
	A->induced_action_by_right_multiplication(FALSE /* f_basis */,
		NULL /* sims *old_G */,
		group_we_act_on, f_transfer_ownership /* f_ownership */,
		verbose_level - 1);
	if (f_v) {
		cout << "new_action_by_right_multiplication done" << endl;
		}
	return A;
}

void action_print_symmetry_group_type(ostream &ost,
		symmetry_group_type a)
{
	if (a == unknown_symmetry_group_t) {
		ost << "unknown_symmetry_group_t";
		}
	else if (a == matrix_group_t) {
		ost << "matrix_group_t";
		}
	else if (a == perm_group_t) {
		ost << "perm_group_t";
		}
	else if (a == wreath_product_t) {
		ost << "wreath_product_t";
		}
	else if (a == direct_product_t) {
		ost << "direct_product_t";
		}
	else if (a == action_on_sets_t) {
		ost << "action_on_sets_t";
		}
	else if (a == action_on_set_partitions_t) {
		ost << "action_on_set_partitions_t";
		}
	else if (a == action_on_subgroups_t) {
		ost << "action_on_subgroups_t";
		}
	else if (a == action_on_pairs_t) {
		ost << "action_on_pairs_t";
		}
	else if (a == action_on_ordered_pairs_t) {
		ost << "action_on_ordered_pairs_t";
		}
	else if (a == base_change_t) {
		ost << "base_change_t";
		}
	else if (a == product_action_t) {
		ost << "product_action_t";
		}
	else if (a == action_by_right_multiplication_t) {
		ost << "action_by_right_multiplication_t";
		}
	else if (a == action_by_restriction_t) {
		ost << "action_by_restriction_t";
		}
	else if (a == action_by_conjugation_t) {
		ost << "action_by_conjugation_t";
		}
	else if (a == action_by_representation_t) {
		ost << "action_by_representation_t";
		}
	else if (a == action_by_subfield_structure_t) {
		ost << "action_by_subfield_structure_t";
		}
	else if (a == action_on_determinant_t) {
		ost << "action_on_determinant_t";
		}
	else if (a == action_on_sign_t) {
		ost << "action_on_sign_t";
		}
	else if (a == action_on_grassmannian_t) {
		ost << "action_on_grassmannian_t";
		}
	else if (a == action_on_spread_set_t) {
		ost << "action_on_spread_set_t";
		}
	else if (a == action_on_cosets_t) {
		ost << "action_on_cosets_t";
		}
	else if (a == action_on_factor_space_t) {
		ost << "action_on_factor_space_t";
		}
	else if (a == action_on_wedge_product_t) {
		ost << "action_on_wedge_product_t";
		}
	else if (a == action_on_bricks_t) {
		ost << "action_on_bricks_t";
		}
	else if (a == action_on_andre_t) {
		ost << "action_on_andre_t";
		}
	else if (a == action_on_orthogonal_t) {
		ost << "action_on_orthogonal_t";
		}
	else if (a == action_on_orbits_t) {
		ost << "action_on_orbits_t";
		}
	else if (a == action_on_flags_t) {
		ost << "action_on_flags_t";
		}
	else if (a == action_on_homogeneous_polynomials_t) {
		ost << "action_on_homogeneous_polynomials_t";
		}
	else {
		ost << "unknown symmetry_group_type" << endl;
		}
}

int choose_next_base_point_default_method(action *A,
		int *Elt, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int b;
	
	if (f_v) {
		cout << "choose_next_base_point_default_method" << endl;
		cout << "calling A->find_non_fixed_point" << endl;
		}
	b = A->find_non_fixed_point(Elt, verbose_level - 1);
	if (b == -1) {
		if (f_v) {
			cout << "cannot find another base point" << endl;
			}
		return -1;
		}
	if (f_v) {
		cout << "choose_next_base_point_default_method current base: ";
		int_vec_print(cout, A->base, A->base_len);
		cout << " choosing next base point to be " << b << endl;
		}
	return b;
}

void make_generators_stabilizer_of_two_components(
	action *A_PGL_n_q, action *A_PGL_k_q,
	int k, vector_ge *gens, int verbose_level)
// used in semifield.C
// does not include the swap
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int *Q;
	int *Elt1;
	int *Zero;
	int *Id;
	int *Center;
	int *minusId;
	int n, i, len;
	int *P;
	matrix_group *Mtx;
	finite_field *Fq;
	int minus_one, alpha;
	strong_generators *gens_PGL_k;
	//vector_ge *gens_PGL_k;


	if (f_v) {
		cout << "make_generators_stabilizer_of_two_components" << endl;
		}
	n = 2 * k;

	Zero = NEW_int(k * k);
	Id = NEW_int(k * k);
	Center = NEW_int(k * k);
	minusId = NEW_int(k * k);
	Q = NEW_int(n * n + 1);
	Elt1 = NEW_int(A_PGL_n_q->elt_size_in_int);


	Mtx = A_PGL_k_q->G.matrix_grp;
	Fq = Mtx->GFq;
	minus_one = Fq->negate(1);
	alpha = Fq->primitive_root();

	int_vec_zero(Zero, k * k);
	int_vec_zero(Id, k * k);
	int_vec_zero(Center, k * k);
	int_vec_zero(minusId, k * k);
	for (i = 0; i < k; i++) {
		Id[i * k + i] = 1;
		}
	for (i = 0; i < k; i++) {
		Center[i * k + i] = alpha;
		}
	for (i = 0; i < k; i++) {
		minusId[i * k + i] = minus_one;
		}

	gens_PGL_k = A_PGL_k_q->Strong_gens;
	//gens_PGL_k = A_PGL_k_q->strong_generators;
	
	len = gens_PGL_k->gens->len;
	//len = gens_PGL_k->len;

	int *Data;
	int new_len, sz, idx, h;

	new_len = 2 * len + 2;
	sz = n * n;
	if (Mtx->f_semilinear) {
		sz++;
		}
	

	Data = NEW_int(new_len * sz);
	idx = 0;
	for (h = 0; h < 2 * len; h++) {

		P = gens_PGL_k->gens->ith(h / 2);
		//P = gens_PGL_k->ith(h / 2);

		if (EVEN(h)) {
			// Q := diag(P,Id)
			int_matrix_make_block_matrix_2x2(Q, k, P, Zero, Zero, Id);
			}
		else {
			// Q := diag(Id,P)
			int_matrix_make_block_matrix_2x2(Q, k, Id, Zero, Zero, P);
			}
		if (Mtx->f_semilinear) {
			Q[n * n] = P[k * k];
			}
		int_vec_copy(Q, Data + idx * sz, sz);
		idx++;
		}

#if 0
	// Q := matrix(0,I,I,0):
	int_matrix_make_block_matrix_2x2(Q, k, Zero, Id, Id, Zero);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	int_vec_copy(Q, Data + idx * sz, sz);
	idx++;
#endif

	// Q := matrix(Center,0,0,I):
	int_matrix_make_block_matrix_2x2(Q, k, Center, Zero, Zero, Id);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	int_vec_copy(Q, Data + idx * sz, sz);
	idx++;

	// Q := matrix(I,0,0,Center):
	int_matrix_make_block_matrix_2x2(Q, k, Id, Zero, Zero, Center);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	int_vec_copy(Q, Data + idx * sz, sz);
	idx++;


	if (idx != new_len) {
		cout << "make_generators_stabilizer_of_two_components "
				"idx != new_len" << endl;
		exit(1);
		}



	gens->init(A_PGL_n_q);
	gens->allocate(new_len);
	for (h = 0; h < new_len; h++) {
		A_PGL_n_q->make_element(Elt1, Data + h * sz, 0);
		if (f_vv) {
			cout << "make_generators_stabilizer_of_two_components "
					"after make_element generator " << h << " : " << endl;
			A_PGL_n_q->print_quick(cout, Elt1);
			}
		A_PGL_n_q->move(Elt1, gens->ith(h));
		}
	

	FREE_int(Data);

	FREE_int(Zero);
	FREE_int(Id);
	FREE_int(Center);
	FREE_int(minusId);
	FREE_int(Q);
	FREE_int(Elt1);
	if (f_v) {
		cout << "make_generators_stabilizer_of_two_components done" << endl;
		}
}


void make_generators_stabilizer_of_three_components(
	action *A_PGL_n_q, action *A_PGL_k_q,
	int k, vector_ge *gens, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int *Q;
	int *Elt1;
	int *Zero;
	int *Id;
	int *minusId;
	int n, i, len;
	int *P;
	matrix_group *Mtx;
	finite_field *Fq;
	int minus_one;
	strong_generators *gens_PGL_k;

	if (f_v) {
		cout << "make_generators_stabilizer_of_three_components" << endl;
		}
	n = 2 * k;

	Zero = NEW_int(k * k);
	Id = NEW_int(k * k);
	minusId = NEW_int(k * k);
	Q = NEW_int(n * n + 1);
	Elt1 = NEW_int(A_PGL_n_q->elt_size_in_int);


	Mtx = A_PGL_k_q->G.matrix_grp;
	Fq = Mtx->GFq;
	minus_one = Fq->negate(1);


	int_vec_zero(Zero, k * k);
	int_vec_zero(Id, k * k);
	int_vec_zero(minusId, k * k);
	for (i = 0; i < k; i++) {
		Id[i * k + i] = 1;
		}
	for (i = 0; i < k; i++) {
		minusId[i * k + i] = minus_one;
		}

	gens_PGL_k = A_PGL_k_q->Strong_gens;
	//gens_PGL_k = A_PGL_k_q->strong_generators;
	
	len = gens_PGL_k->gens->len;
	//len = gens_PGL_k->len;

	int *Data;
	int new_len, sz, idx, h;

	new_len = len + 2;
	sz = n * n;
	if (Mtx->f_semilinear) {
		sz++;
		}
	

	Data = NEW_int(new_len * sz);
	idx = 0;
	for (h = 0; h < len; h++) {

		P = gens_PGL_k->gens->ith(h);
		//P = gens_PGL_k->ith(h);

		// Q := diag(P,P)
		int_matrix_make_block_matrix_2x2(Q, k, P, Zero, Zero, P);
		if (Mtx->f_semilinear) {
			Q[n * n] = P[k * k];
			}
		int_vec_copy(Q, Data + idx * sz, sz);
		idx++;
		}

	// Q := matrix(0,I,I,0):
	int_matrix_make_block_matrix_2x2(Q, k, Zero, Id, Id, Zero);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	int_vec_copy(Q, Data + idx * sz, sz);
	idx++;

	// Q := matrix(0,I,-I,-I):
	int_matrix_make_block_matrix_2x2(Q, k, Zero, Id, minusId, minusId);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	int_vec_copy(Q, Data + idx * sz, sz);
	idx++;


	if (idx != new_len) {
		cout << "make_generators_stabilizer_of_three_components "
				"idx != new_len" << endl;
		exit(1);
		}



	gens->init(A_PGL_n_q);
	gens->allocate(new_len);
	for (h = 0; h < new_len; h++) {
		A_PGL_n_q->make_element(Elt1, Data + h * sz, 0);
		if (f_vv) {
			cout << "make_generators_stabilizer_of_three_components "
					"after make_element generator " << h << " : " << endl;
			A_PGL_n_q->print_quick(cout, Elt1);
			}
		A_PGL_n_q->move(Elt1, gens->ith(h));
		}
	

	FREE_int(Data);

	FREE_int(Zero);
	FREE_int(Id);
	FREE_int(minusId);
	FREE_int(Q);
	FREE_int(Elt1);
	if (f_v) {
		cout << "make_generators_stabilizer_of_three_components done" << endl;
		}
}

void generators_to_strong_generators(action *A, 
	int f_target_go, longinteger_object &target_go, 
	vector_ge *gens, strong_generators *&Strong_gens, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "generators_to_strong_generators" << endl;
		if (f_target_go) {
			cout << "trying to create a group of order " << target_go << endl;
			}
		}

	sims *S;
	
	if (f_v) {
		cout << "generators_to_strong_generators "
				"before create_sims_from_generators_randomized" << endl;
		}

	S = A->create_sims_from_generators_randomized(
		gens, f_target_go, 
		target_go, verbose_level - 2);

	if (f_v) {
		cout << "generators_to_strong_generators "
				"after create_sims_from_generators_randomized" << endl;
		}

	Strong_gens = NEW_OBJECT(strong_generators);
	Strong_gens->init_from_sims(S, 0);

	FREE_OBJECT(S);

	if (f_v) {
		cout << "generators_to_strong_generators done" << endl;
		}
}

void compute_generators_GL_n_q(int *&Gens,
		int &nb_gens, int &elt_size, int n, finite_field *F,
		vector_ge *&nice_gens,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	action *A;
	vector_ge *gens;
	int *Elt;
	int h, i, l, alpha;

	if (f_v) {
		cout << "compute_generators_GL_n_q" << endl;
		}
	A = NEW_OBJECT(action);

	A->init_projective_group(n, F,
			FALSE /* f_semilinear */,
			TRUE /* f_basis */,
			nice_gens,
			verbose_level - 2);

	gens = A->Strong_gens->gens;

	l = gens->len;
	nb_gens = l + 1;
	elt_size = n * n;
	Gens = NEW_int(nb_gens * elt_size);
	for (h = 0; h < nb_gens; h++) {
		if (h < l) {
			Elt = gens->ith(h);
			for (i = 0; i < n * n; i++) {
				Gens[h * elt_size + i] = Elt[i];
				}
			}
		else {
			for (i = 0; i < n * n; i++) {
				Gens[h * elt_size + i] = 0;
				}
			alpha = F->primitive_root();
			for (i = 0; i < n; i++) {
				Gens[h * elt_size + i * n + i] = alpha;
				}
			}
		}
	if (f_vv) {
		for (h = 0; h < nb_gens; h++) {
			cout << "Generator " << h << ":" << endl;
			int_matrix_print(Gens + h * elt_size, n, n);
			}
		
		}
	FREE_OBJECT(A);
	if (f_v) {
		cout << "compute_generators_GL_n_q done" << endl;
		}
}

void order_of_PGGL_n_q(longinteger_object &go,
		int n, int q, int f_semilinear)
{
	int verbose_level = 0;
	action *A;
	finite_field *F;
	vector_ge *nice_gens;

	F = NEW_OBJECT(finite_field);
	A = NEW_OBJECT(action);

	F->init(q, 0);
	A->init_projective_group(n, F, 
		f_semilinear, 
		TRUE /* f_basis */,
		nice_gens,
		verbose_level - 2);
	A->group_order(go);
	
	FREE_OBJECT(nice_gens);
	FREE_OBJECT(F);
	FREE_OBJECT(A);
}


// callbacks for Schreier Sims:


	int f_generator_orthogonal_siegel = TRUE;
	int f_generator_orthogonal_reflection = TRUE;
	int f_generator_orthogonal_similarity = TRUE;
	int f_generator_orthogonal_semisimilarity = TRUE;


void set_orthogonal_group_type(int f_siegel,
		int f_reflection,
		int f_similarity,
		int f_semisimilarity)
{
	f_generator_orthogonal_siegel = f_siegel;
	f_generator_orthogonal_reflection = f_reflection;
	f_generator_orthogonal_similarity = f_similarity;
	f_generator_orthogonal_semisimilarity = f_semisimilarity;
}

int get_orthogonal_group_type_f_reflection()
{
	return f_generator_orthogonal_reflection;
}

void callback_choose_random_generator_orthogonal(int iteration, 
	int *Elt, void *data, int verbose_level)
{
	//verbose_level += 5;
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "callback_choose_random_generator_orthogonal "
				"iteration=" << iteration << endl;
		}

	schreier_sims *ss = (schreier_sims *) data;
	action *A = ss->GA;
	action *subaction = ss->KA;
	matrix_group *M;
#if 0
	int f_siegel = TRUE;
	int f_reflection = TRUE;
	int f_similarity = TRUE;
	int f_semisimilarity = TRUE;
#endif

	action_on_orthogonal *AO;
	orthogonal *O;
	
	AO = A->G.AO;
	O = AO->O;
	
	M = subaction->G.matrix_grp;
	if (f_v) {
		cout << "callback_choose_random_generator_orthogonal "
				"iteration=" << iteration
				<< " before M->orthogonal_group_random_generator"
				<< endl;
		}
	M->orthogonal_group_random_generator(ss->GA, O, 
		f_generator_orthogonal_siegel, 
		f_generator_orthogonal_reflection, 
		f_generator_orthogonal_similarity, 
		f_generator_orthogonal_semisimilarity, 
		Elt, verbose_level - 2);
	//M->GL_invert_internal(Elt, Elt + M->elt_size_int_half, 0);
	if (f_v) {
		cout << "callback_choose_random_generator_orthogonal "
				"iteration=" << iteration
				<< " after M->orthogonal_group_random_generator"
				<< endl;
		}

	if (f_v) {
		cout << "callback_choose_random_generator_orthogonal "
				"iteration=" << iteration << " done" << endl;
		}
}



void test_matrix_group(int k, int q, int f_semilinear, int verbose_level)
{
	action A;
	finite_field *F;
	int f_basis = TRUE;
	vector_ge *nice_gens;

	F = NEW_OBJECT(finite_field);
	F->init(q, 0);
	A.init_projective_group(k, F, f_semilinear, f_basis,
			nice_gens,
			verbose_level);
	FREE_OBJECT(nice_gens);
	FREE_OBJECT(F);
}

void lift_generators(vector_ge *gens_in, vector_ge *&gens_out, 
	action *Aq, subfield_structure *S, int n, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int *EltQ;
	int *Eltq;
	int *Mtx;
	int nb_gens, m, t;


	if (f_v) {
		cout << "lift_generators" << endl;
		}

	nb_gens = gens_in->len;

	m = n / S->s;

	gens_out = NEW_OBJECT(vector_ge);

	Eltq = NEW_int(Aq->elt_size_in_int);
	Mtx = NEW_int(n * n);

	if (f_v) {
		cout << "lift_generators lifting generators" << endl;
		}
	gens_out->init(Aq);
	gens_out->allocate(nb_gens);
	for (t = 0; t < nb_gens; t++) {
		if (f_vv) {
			cout << "lift_generators " << t << " / " << nb_gens << endl;
			}
		EltQ = gens_in->ith(t);
		S->lift_matrix(EltQ, m, Mtx, 0 /* verbose_level */);
		if (f_vv) {
			cout << "lift_generators lifted matrix:" << endl;
			int_matrix_print(Mtx, n, n);
			}
		Aq->make_element(Eltq, Mtx, 0 /*verbose_level - 4 */);
		if (f_vv) {
			cout << "lift_generators after make_element:" << endl;
			Aq->element_print_quick(Eltq, cout);
			}
		Aq->element_move(Eltq, gens_out->ith(t), 0);
		if (f_vv) {
			cout << "lift_generators " << t << " / "
					<< nb_gens << " done" << endl;
			}
		}
	FREE_int(Eltq);
	FREE_int(Mtx);
	if (f_v) {
		cout << "lift_generators done" << endl;
		}

}

void retract_generators(vector_ge *gens_in,
	vector_ge *&gens_out,
	action *AQ, subfield_structure *S, int n, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int *EltQ;
	int *Eltq;
	int *Mtx;
	int nb_gens, m, t;


	if (f_v) {
		cout << "retract_generators" << endl;
		}

	nb_gens = gens_in->len;

	m = n / S->s;

	gens_out = NEW_OBJECT(vector_ge);

	EltQ = NEW_int(AQ->elt_size_in_int);
	Mtx = NEW_int(m * m);

	if (f_v) {
		cout << "retract_generators retracting generators" << endl;
		}
	gens_out->init(AQ);
	gens_out->allocate(nb_gens);
	for (t = 0; t < nb_gens; t++) {
		if (f_vv) {
			cout << "retract_generators " << t
					<< " / " << nb_gens << endl;
			}
		Eltq = gens_in->ith(t);
		S->retract_matrix(Eltq, n, Mtx, m, 0 /* verbose_level */);
		if (f_vv) {
			cout << "retract_generators retracted matrix:" << endl;
			int_matrix_print(Mtx, m, m);
			}
		AQ->make_element(EltQ, Mtx, 0 /*verbose_level - 4*/);
		if (f_vv) {
			cout << "retract_generators after make_element:" << endl;
			AQ->element_print_quick(EltQ, cout);
			}
		AQ->element_move(EltQ, gens_out->ith(t), 0);
		if (f_vv) {
			cout << "retract_generators " << t
					<< " / " << nb_gens << " done" << endl;
			}
		}
	FREE_int(EltQ);
	FREE_int(Mtx);
	if (f_v) {
		cout << "retract_generators done" << endl;
		}

}

void lift_generators_to_subfield_structure(
	int n, int s, 
	subfield_structure *S, 
	action *Aq, action *AQ, 
	strong_generators *&Strong_gens, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int q, Q, m;
	finite_field *Fq;
	//finite_field *FQ;
	sims *Sims;

	if (f_v) {
		cout << "lift_generators_to_subfield_structure" << endl;
		}
	Fq = S->Fq;
	//FQ = S->FQ;
	q = Fq->q;
	Q = i_power_j(q, s);
	m = n / s;
	if (m * s != n) {
		cout << "lift_generators_to_subfield_structure "
				"s must divide n" << endl;
		exit(1);
		}
	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"creating subfield structure" << endl;
		}
	if (f_v) {
		cout << "n=" << n << endl;
		cout << "s=" << s << endl;
		cout << "m=" << m << endl;
		cout << "q=" << q << endl;
		cout << "Q=" << Q << endl;
		}

	longinteger_object order_GLmQ;
	longinteger_object target_go;
	longinteger_domain D;
	int r;

	AQ->group_order(order_GLmQ);
	

	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"order of GL(m,Q) = " << order_GLmQ << endl;
		}
	D.integral_division_by_int(order_GLmQ, 
		q - 1, target_go, r);
	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"target_go = " << target_go << endl;
		}



	vector_ge *gens;
	vector_ge *gens1;


	gens = AQ->Strong_gens->gens;


	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"before lift_generators" << endl;
		}
	lift_generators(gens, gens1, Aq, S, n, verbose_level);
		// ACTION/action_global.C
	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"after lift_generators" << endl;
		}


	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"creating lifted group:" << endl;
		}
	//Aq->group_order(target_go);
	Sims = Aq->create_sims_from_generators_with_target_group_order(
		gens1, 
		target_go, 
		0 /* verbose_level */);

#if 0
	Sims = A1->create_sims_from_generators_without_target_group_order(
		gens1, MINIMUM(2, verbose_level - 3));
#endif

	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"creating lifted group done" << endl;
		}

	longinteger_object go;

	Sims->group_order(go);

	if (f_v) {
		cout << "go=" << go << endl;
		}


	Strong_gens = NEW_OBJECT(strong_generators);

	Strong_gens->init_from_sims(Sims, 0 /* verbose_level */);
	if (f_vv) {
		cout << "lift_generators_to_subfield_structure "
				"strong generators are:" << endl;
		Strong_gens->print_generators();
		}


	FREE_OBJECT(gens1);
	FREE_OBJECT(Sims);
	if (f_v) {
		cout << "lift_generators_to_subfield_structure done" << endl;
		}

}

// O4_model:

void O4_isomorphism_2to4_embedded(action *A4, action *A5, finite_field *Fq, 
	int f_switch, int *mtx2x2_T, int *mtx2x2_S, int *Elt,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int mtx4x4[16];
	int mtx5x5[25];
	int *E1;
	
	if (f_v) {
		cout << "O4_isomorphism_2to4_embedded" << endl;
		}
	E1 = NEW_int(A4->elt_size_in_int);
	if (f_v) {
		cout << "input in 2x2, 2x2:" << endl;
		cout << "f_switch=" << f_switch << endl;
		print_integer_matrix_width(cout, mtx2x2_T, 2, 2, 2, 3);
		cout << "," << endl;
		print_integer_matrix_width(cout, mtx2x2_S, 2, 2, 2, 3);
		}
	
	Fq->O4_isomorphism_2to4(mtx2x2_T, mtx2x2_S, f_switch, mtx4x4);
	
	A4->make_element(E1, mtx4x4, 0);
	if (f_v) {
		cout << "in 4x4:" << endl;
		A4->element_print_quick(E1, cout);
		}
	
	O4_to_O5(A4, A5, Fq, E1, mtx5x5, verbose_level - 2);
	if (f_v) {
		cout << "in 5x5:" << endl;
		print_integer_matrix_width(cout, mtx5x5, 5, 5, 5, 3);
		}
	A5->make_element(Elt, mtx5x5, 0);
	if (f_v) {
		cout << "as group element:" << endl;
		A5->element_print_quick(Elt, cout);
		}
	FREE_int(E1);
}

void O5_to_O4(action *A4, action *A5, finite_field *Fq, 
	int *mtx4x4, int *mtx5x5, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int Data[25];
	int h, u, v;

	for (h = 0; h < 25; h++) {
		Data[h] = mtx5x5[h];
		}
	Fq->PG_element_normalize_from_front(Data, 1, 25);
	if (f_v) {
		cout << "as 5 x 5:" << endl;
		print_integer_matrix_width(cout, Data, 5, 5, 5, 3);
		}

	for (u = 0; u < 4; u++) {
		for (v = 0; v < 4; v++) {
			mtx4x4[u * 4 + v] = Data[(u + 1) * 5 + v + 1];
			}
		}
	if (f_v) {
		cout << "as 4 x 4:" << endl;
		print_integer_matrix_width(cout, mtx4x4, 4, 4, 4, 3);
		}
}

void O4_to_O5(action *A4, action *A5, finite_field *Fq, 
	int *mtx4x4, int *mtx5x5, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int ord;
	int i, j;
	int value;
	int sqrt_value;
	int discrete_log;
	int *A4_Elt1;
	int *A5_Elt1;
	int gram[16];	
	int mtx_tr[16];
	int mtx_tmp1[16];
	int mtx_tmp2[16];
	int mtx5[25];
	
	A4_Elt1 = NEW_int(A4->elt_size_in_int);
	A5_Elt1 = NEW_int(A5->elt_size_in_int);
	
	A4->make_element(A4_Elt1, mtx4x4, 0);
	if (f_v) {
		cout << "A4_Elt1:" << endl;
		A4->element_print_quick(A4_Elt1, cout);
		}
	ord = A4->element_order(A4_Elt1);
	if (f_v) {
		cout << "A4_Elt1 has order " << ord << endl;
		}


	for (i = 0; i < 16; i++) {
		gram[i] = 0;
		}
	gram[0 * 4 + 1] = 1;
	gram[1 * 4 + 0] = 1;
	gram[2 * 4 + 3] = 1;
	gram[3 * 4 + 2] = 1;
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			mtx_tr[i * 4 + j] = mtx4x4[j * 4 + i];
			}
		}
	if (f_v) {
		cout << "Gram matrix:" << endl;
		print_integer_matrix_width(cout, gram, 4, 4, 4, 3);
		cout << "mtx4x4:" << endl;
		print_integer_matrix_width(cout, mtx4x4, 4, 4, 4, 3);
		cout << "mtx_tr:" << endl;
		print_integer_matrix_width(cout, mtx_tr, 4, 4, 4, 3);
		}
	Fq->mult_matrix_matrix(mtx4x4, gram, mtx_tmp1, 4, 4, 4,
			0 /* verbose_level */);
	Fq->mult_matrix_matrix(mtx_tmp1, mtx_tr, mtx_tmp2, 4, 4, 4,
			0 /* verbose_level */);
	if (f_v) {
		cout << "transformed Gram matrix:" << endl;
		print_integer_matrix_width(cout, mtx_tmp2, 4, 4, 4, 3);
		}
	
	value = 0;
	for (i = 0; i < 16; i++) {
		if (!mtx_tmp2[i]) {
			continue;
			}
		if (value == 0) {
			value = mtx_tmp2[i];
			continue;
			}
		if (value != mtx_tmp2[i]) {
			cout << "the transformed gram matrix has several values" << endl;
			exit(1);
			}
		value = mtx_tmp2[i];
		}

	if (f_v) {
		cout << "value=" << value << endl;
		}
	discrete_log = Fq->log_alpha(value);

	if (f_v) {
		cout << "discrete_log=" << discrete_log << endl;
		}
	if (ODD(discrete_log)) {
		cout << "value is not a square" << endl;
		exit(1);
		}
	sqrt_value = Fq->alpha_power(discrete_log >> 1);
	
	
	for (i = 0 ; i < 25; i++) {
		mtx5[i] = 0;
		}
	mtx5[0] = sqrt_value;
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			mtx5[(i + 1) * 5 + j + 1] = mtx4x4[i * 4 + j];
			}
		}

	
	A5->make_element(A5_Elt1, mtx5, 0);
	if (f_v) {
		cout << "A5_Elt1:" << endl;
		A5->element_print_quick(A5_Elt1, cout);
		}
	ord = A5->element_order_verbose(A5_Elt1, 0);
	if (f_v) {
		cout << "A5_Elt1 has order " << ord << endl;
		}
	for (i = 0; i < 25; i++) {
		mtx5x5[i] = A5_Elt1[i];
		}

	FREE_int(A4_Elt1);
	FREE_int(A5_Elt1);
}

void print_4x4_as_2x2(action *A2, finite_field *Fq, int *mtx4x4)
{
	int small[8], f_switch, r, order;
	int *elt1;
		
	elt1 = NEW_int(A2->elt_size_in_int);	
	Fq->O4_isomorphism_4to2(small, small + 4,
			f_switch, mtx4x4, 0/*verbose_level*/);
	cout << "after isomorphism:" << endl;
	cout << "f_switch=" << f_switch << endl;
	for (r = 0; r < 2; r++) {
		cout << "component " << r << ":" << endl;
		Fq->PG_element_normalize_from_front(small + r * 4, 1, 4);
		print_integer_matrix_width(cout, small + r * 4, 2, 2, 2, 3);
		A2->make_element(elt1, small + r * 4, 0);
		order = A2->element_order(elt1);
		cout << "has order " << order << endl;
		A2->element_print_as_permutation(elt1, cout);
		cout << endl;
		A2->element_print_quick(elt1, cout);
		cout << endl;
		
		}
	FREE_int(elt1);
}

#if 0
static void print_from_to(int d, int i, int j, int *v1, int *v2)
{
	cout << i << "=";
	int_vec_print(cout, v1, d);
	cout << " -> " << j << " = ";
	int_vec_print(cout, v2, d);
	cout << endl;
}
#endif



void projective_space_init_line_action(projective_space *P,
		action *A_points, action *&A_on_lines, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	action_on_grassmannian *AoL;

	if (f_v) {
		cout << "projective_space_init_line_action" << endl;
		}
	A_on_lines = NEW_OBJECT(action);

	AoL = NEW_OBJECT(action_on_grassmannian);

	AoL->init(*A_points, P->Grass_lines, verbose_level - 5);
	
	
	if (f_v) {
		cout << "projective_space_init_line_action "
				"action on grassmannian established" << endl;
		}

	if (f_v) {
		cout << "projective_space_init_line_action "
				"initializing A_on_lines" << endl;
		}
	int f_induce_action = TRUE;
	sims S;
	longinteger_object go1;

	S.init(A_points);
	S.init_generators(*A_points->Strong_gens->gens,
			0/*verbose_level*/);
	S.compute_base_orbits_known_length(A_points->transversal_length,
			0/*verbose_level - 1*/);
	S.group_order(go1);
	if (f_v) {
		cout << "projective_space_init_line_action "
				"group order " << go1 << endl;
		}
	
	if (f_v) {
		cout << "projective_space_init_line_action "
				"initializing action on grassmannian" << endl;
		}
	A_on_lines->induced_action_on_grassmannian(A_points, AoL, 
		f_induce_action, &S, verbose_level);
	if (f_v) {
		cout << "projective_space_init_line_action "
				"initializing A_on_lines done" << endl;
		A_on_lines->print_info();
		}

	if (f_v) {
		cout << "projective_space_init_line_action "
				"computing strong generators" << endl;
		}
	if (!A_on_lines->f_has_strong_generators) {
		cout << "projective_space_init_line_action "
				"induced action does not have strong generators" << endl;
		}
	if (f_v) {
		cout << "projective_space_init_line_action done" << endl;
		}
}

void color_distribution_matrix(action *A,
	int *Elt, int n, uchar *Adj, int *colors, classify *C,
	int *&Mtx, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int i, j, ci, cj;

	if (f_v) {
		cout << "color_distribution_matrix" << endl;
		}
	
	Mtx = NEW_int(C->nb_types * C->nb_types);
	int_vec_zero(Mtx, C->nb_types * C->nb_types);
	
	for (i = 0; i < n; i++) {
		ci = C->class_of(i);
		j = A->element_image_of(i, Elt,
				0 /* verbose_level */);
		cj = C->class_of(j);
		Mtx[ci * C->nb_types + cj]++;
		}
	
	if (f_v) {
		cout << "color_distribution_matrix done" << endl;
		}
}

void test_color_distribution(action *A,
	vector_ge *gens, int n,
	uchar *Adj, int *colors, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = FALSE; //(verbose_level >= 1);
	int *Elt;
	int *Mtx;
	int l, h;

	if (f_v) {
		cout << "test_color_distribution" << endl;
		}

	classify C;

	C.init(colors, n, FALSE, 0);
	
	l = gens->len;
	for (h = 0; h < l; h++) {
		Elt = gens->ith(h);
		color_distribution_matrix(A,
			Elt, n, Adj, colors, &C,
			Mtx, verbose_level - 2);
		if (f_vv) {
			cout << "generator " << h
					<< " has the following color distribution matrix:"
					<< endl;
			int_matrix_print(Mtx, C.nb_types, C.nb_types);
			}
		
		FREE_int(Mtx);
		}

	if (f_v) {
		cout << "test_color_distribution done" << endl;
		}
}

void color_preserving_subgroup(action *A,
	int n, uchar *Adj, int *colors, sims *&Subgroup,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = FALSE; //(verbose_level >= 2);
	sims *S;
	int *Elt;
	int *Subgrp;
	sims *K;
	int sz;
	int h, go;
	longinteger_object Go;
	vector_ge *gens;

	if (f_v) {
		cout << "color_preserving_subgroup" << endl;
		}

	classify C;

	C.init(colors, n, FALSE, 0);
	
	S = A->Sims;
	Elt = NEW_int(A->elt_size_in_int);
	
	go = S->group_order_int();
	Subgrp = NEW_int(go);
	sz = 0;

	for (h = 0; h < go; h++) {
		int *Mtx;
		
		S->element_unrank_int(h, Elt);
		color_distribution_matrix(A, Elt, n, Adj, colors, &C, 
			Mtx, verbose_level - 2);

		if (f_vv) {
			cout << "element " << h << " / " << go
					<< " has the following color distribution matrix:" << endl;
			int_matrix_print(Mtx, C.nb_types, C.nb_types);
			}
		if (is_diagonal_matrix(Mtx, C.nb_types)) {
			Subgrp[sz++] = h;
			}
		FREE_int(Mtx);
		}


	if (f_v) {
		cout << "The subgroup has order " << sz << endl;
		cout << "and consists of the elements: ";
		int_vec_print(cout, Subgrp, sz);
		cout << endl;
		}
	
	gens = NEW_OBJECT(vector_ge);
	gens->init(A);
	gens->allocate(sz);
	for (h = 0; h < sz; h++) {
		S->element_unrank_int(Subgrp[h], gens->ith(h));
		}
	
	Subgroup = NEW_OBJECT(sims);
	K = NEW_OBJECT(sims);
	Go.create(sz);
	Subgroup->init(A);
	K->init(A);
	Subgroup->init_trivial_group(verbose_level);
	K->init_trivial_group(verbose_level);
	Subgroup->build_up_group_from_generators(K, gens, 
		TRUE /* f_target_go */, &Go, 
		FALSE /* f_override_choose_next_base_point */,
		NULL, 
		verbose_level);
	

	FREE_int(Elt);
	FREE_int(Subgrp);
	FREE_OBJECT(gens);
	FREE_OBJECT(K);

	if (f_v) {
		cout << "color_preserving_subgroup done" << endl;
		}
}

int test_automorphism_group_of_graph_bitvec(action *A,
	int n, uchar *Adj, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	strong_generators *SG;
	int *Elt;
	int h, i, j, ii, jj, iii, jjj, k, kk, l, a, b;

	if (f_v) {
		cout << "test_automorphism_group_of_graph_bitvec" << endl;
		}

	SG = A->Strong_gens;
	l = SG->gens->len;
	for (h = 0; h < l; h++) {
		Elt = SG->gens->ith(h);
		for (i = 0; i < n; i++) {
			ii = A->element_image_of(i, Elt, 0 /* verbose_level */);
			for (j = i + 1; j < n; j++) {
				jj = A->element_image_of(j, Elt, 0 /* verbose_level */);
				if (ii < jj) {
					iii = ii;
					jjj = jj;
					}
				else {
					iii = jj;
					jjj = ii;
					}
				k = ij2k(i, j, n);
				kk = ij2k(iii, jjj, n);
				a = bitvector_s_i(Adj, k);
				b = bitvector_s_i(Adj, kk);
				if (a && !b) {
					cout << "automorphism does not preserve adjacency"
							<< endl;
					return FALSE;
					}
				if (!a && b) {
					cout << "automorphism does not preserve adjacency"
							<< endl;
					return FALSE;
					}
				}
			}
		}
	if (f_v) {
		cout << "test_automorphism_group_of_graph_bitvec done" << endl;
		}
	return TRUE;
}

void compute_conjugacy_classes(sims *S,
	action *&Aconj, action_by_conjugation *&ABC, schreier *&Sch,
	strong_generators *&SG, int &nb_classes,
	int *&class_size, int *&class_rep,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int i, f;

	if (f_v) {
		cout << "compute_conjugacy_classes" << endl;
		}
	Aconj = NEW_OBJECT(action);

	if (f_v) {
		cout << "Creating action by conjugation" << endl;
		}
	
	Aconj->induced_action_by_conjugation(S, 
		S,
		FALSE /* f_ownership */,
		FALSE /* f_basis */,
		verbose_level - 1);

	if (f_v) {
		cout << "Creating action by conjugation done" << endl;
		}	

	ABC = Aconj->G.ABC;


	Sch = NEW_OBJECT(schreier);

	Sch->init(Aconj);


	SG = NEW_OBJECT(strong_generators);

	SG->init_from_sims(S, 0);
	

	Sch->init_generators(*SG->gens);

	if (f_v) {
		cout << "Computing conjugacy classes:" << endl;
		}
	Sch->compute_all_point_orbits(verbose_level);
	

	nb_classes = Sch->nb_orbits;

	class_size = NEW_int(nb_classes);
	class_rep = NEW_int(nb_classes);
	
	for (i = 0; i < nb_classes; i++) {
		class_size[i] = Sch->orbit_len[i];
		f = Sch->orbit_first[i];
		class_rep[i] = Sch->orbit[f];
		}

	if (f_v) {
		cout << "class size : ";
		int_vec_print(cout, class_size, nb_classes);
		cout << endl;
		cout << "class rep : ";
		int_vec_print(cout, class_rep, nb_classes);
		cout << endl;
		}


	if (f_v) {
		cout << "compute_conjugacy_classes done" << endl;
		}

}

int group_ring_element_size(action *A, sims *S)
{
	int goi;

	goi = S->group_order_int();
	return goi;
}

void group_ring_element_create(action *A, sims *S, int *&elt)
{
	int goi;

	goi = S->group_order_int();
	elt = NEW_int(goi);
	group_ring_element_zero(A, S, elt);
}

void group_ring_element_free(action *A, sims *S, int *elt)
{
	FREE_int(elt);
}

void group_ring_element_print(action *A, sims *S, int *elt)
{
	int goi;

	goi = S->group_order_int();
	int_vec_print(cout, elt, goi);
}

void group_ring_element_copy(action *A, sims *S,
		int *elt_from, int *elt_to)
{
	int goi;

	goi = S->group_order_int();
	int_vec_copy(elt_from, elt_to, goi);
}

void group_ring_element_zero(action *A, sims *S, int *elt)
{
	int goi;

	goi = S->group_order_int();
	int_vec_zero(elt, goi);
}

void group_ring_element_mult(action *A,
		sims *S, int *elt1, int *elt2, int *elt3)
{
	int goi;
	int i, j, k;
	int a, b, c;

	goi = S->group_order_int();
	int_vec_zero(elt3, goi);
	for (i = 0; i < goi; i++) {
		a = elt1[i];
		for (j = 0; j < goi; j++) {
			b = elt2[j];
			c = a * b;
			k = S->mult_by_rank(i, j, 0 /* verbose_level */);
			elt3[k] += c;
			}
		}
}


void perm_print_cycles_sorted_by_length(ostream &ost,
		int degree, int *perm, int verbose_level)
{
	perm_print_cycles_sorted_by_length_offset(ost,
			degree, perm, 0, FALSE, TRUE, verbose_level);
}

void perm_print_cycles_sorted_by_length_offset(ostream &ost, 
	int degree, int *perm, int offset,
	int f_do_it_anyway_even_for_big_degree,
	int f_print_cycles_of_length_one, int verbose_level)
{
	int nb_gens = 1;
	int i;
	vector_ge Gens;
	action *A;
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int f_big = FALSE;
	int f_doit = TRUE;
	
	if (f_v) {
		cout << "perm_print_cycles_sorted_by_length, "
				"degree=" << degree << endl;
		}
	
	if (degree > 500) {
		f_big = TRUE;
		}
	A = NEW_OBJECT(action);
	
	A->init_permutation_group(degree, 0/*verbose_level*/);
	Gens.init(A);
	Gens.allocate(nb_gens);
	for (i = 0; i < nb_gens; i++) {
		Gens.copy_in(i, perm + i * degree);
		}
	if (f_vv) {
		Gens.print(cout);
		}
	
	schreier S;
	
	S.init(A);
	S.init_generators(Gens);
	S.compute_all_point_orbits(verbose_level);
	if (f_v) {
		cout << "after S.compute_all_point_orbits, "
				"nb_orbits=" << S.nb_orbits << endl;
		}
	//S.print_orbit_lengths(cout);
	//S.print_orbit_length_distribution(ost);

	int j, f, l, length, F, L, h, a, b, m, orbit_idx;
	int *orbit_len_sorted;
	int *sorting_perm;
	int *sorting_perm_inv;
	int nb_types;
	int *type_first;
	int *type_len;
	
	int_vec_classify(S.nb_orbits, S.orbit_len, orbit_len_sorted, 
		sorting_perm, sorting_perm_inv, 
		nb_types, type_first, type_len);

#if 0
	ost << "permutation of degree " << degree << " with "
			<< S.nb_orbits << " orbits: " << endl;
	for (i = 0; i < nb_types; i++) {
		f = type_first[i];
		l = type_len[i];
		length = orbit_len_sorted[f];
		if (l > 1) {
			ost << l << " \\times ";
			}
		ost << length;
		if (i < nb_types - 1)
			ost << ", ";
		}
	ost << endl;
	ost << "cycles in increasing length:" << endl;
#endif
	if (f_big) {
		for (i = 0; i < nb_types; i++) {
			f = type_first[i];
			l = type_len[i];
			length = orbit_len_sorted[f];
			ost << l << " cycles of length " << length << endl;
			}
		}
	if (f_big && !f_do_it_anyway_even_for_big_degree) {
		f_doit = FALSE;
		}
	if (f_doit) {
		for (i = 0; i < nb_types; i++) {
			f = type_first[i];
			l = type_len[i];
			length = orbit_len_sorted[f];
			if (length == 1 && !f_print_cycles_of_length_one) {
				continue;
				}
			for (j = 0; j < l; j++) {
				orbit_idx = sorting_perm_inv[f + j];
				//ost << "orbit " << orbit_idx << ": ";
				F = S.orbit_first[orbit_idx];
				L = S.orbit_len[orbit_idx];
				m = S.orbit[F];
				for (h = 1; h < L; h++) {
					if (S.orbit[F + h] < m)
						m = S.orbit[F + h];
					}
				// now m is the least lement in the orbit
				ost << "(";
				a = m;
				ost << (a + offset);
				while (TRUE) {
					b = perm[a];
					if (b == m)
						break;
					ost << ", " << (b + offset);
					a = b;
					}
				ost << ")";
				if (length > 20) {
					//ost << endl;
					}
				} // next j
			//ost << endl;
			} // next i
		} // if
	//ost << "done" << endl;

#if 0
	classify C;

	C.init(S.orbit_len, S.nb_orbits, FALSE, 0);
	ost << " cycle type: ";
	C.print_file(ost, TRUE /* f_backwards */);
#endif

	FREE_int(orbit_len_sorted);
	FREE_int(sorting_perm);
	FREE_int(sorting_perm_inv);
	FREE_int(type_first);
	FREE_int(type_len);
	
	FREE_OBJECT(A);
}


void do_canonical_form(int n, finite_field *F, 
	int *set, int set_size, int f_semilinear, 
	const char *fname_base, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	//int f_vv = (verbose_level >= 2);
	projective_space *P;
	int canonical_pt;
	
	if (f_v) {
		cout << "do_canonical_form" << endl;
		}

	P = NEW_OBJECT(projective_space);
	
	if (f_v) {
		cout << "do_canonical_form before P->init" << endl;
		}
	
	P->init(n, F, 
		TRUE /* f_init_incidence_structure */, 
		verbose_level);

	if (f_v) {
		cout << "do_canonical_form after P->init" << endl;
		}

	strong_generators *SG;
	action *A_linear;
	vector_ge *nice_gens;

	A_linear = NEW_OBJECT(action);
	A_linear->init_projective_group(n + 1, F, f_semilinear, 
			TRUE /* f_basis */,
			nice_gens,
			verbose_level);

	if (f_v) {
		cout << "do_canonical_form before "
				"set_stabilizer_in_projective_space" << endl;
		}
	SG = A_linear->set_stabilizer_in_projective_space(
		P,
		set, set_size, canonical_pt, NULL /* canonical_set_or_NULL */, 
		FALSE, NULL, 
		verbose_level);
	//P->draw_point_set_in_plane(fname_base, set, set_size,
	// TRUE /*f_with_points*/, 0 /* verbose_level */);
	FREE_OBJECT(nice_gens);
	FREE_OBJECT(SG);
	FREE_OBJECT(A_linear);
	FREE_OBJECT(P);

	if (f_v) {
		cout << "do_canonical_form done" << endl;
		}

}

void create_action_and_compute_orbits_on_equations(
	action *A, homogeneous_polynomial_domain *HPD,
	int *The_equations, int nb_equations, strong_generators *gens, 
	action *&A_on_equations, schreier *&Orb, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	
	if (f_v) {
		cout << "create_action_and_compute_orbits_on_equations" << endl;
		}

	A_on_equations = NEW_OBJECT(action);

	if (f_v) {
		cout << "creating the induced action on the equations:" << endl;
		}
	A_on_equations->induced_action_on_homogeneous_polynomials_given_by_equations(A, 
		HPD, 
		The_equations, nb_equations, 
		FALSE /* f_induce_action */, NULL /* sims *old_G */, 
		0 /*verbose_level */);
	if (f_v) {
		cout << "The induced action on the equations has been created, "
				"degree = " << A_on_equations->degree << endl;
		}
	
	if (f_v) {
		cout << "computing orbits on the equations:" << endl;
		}
	Orb = gens->orbits_on_points_schreier(A_on_equations,
			0 /* verbose_level + 10 */);

	if (f_v) {
		cout << "We found " << Orb->nb_orbits
				<< " orbits on the equations:" << endl;
		Orb->print_and_list_orbits_tex(cout);
		}

	if (f_v) {
		cout << "create_action_and_compute_orbits_on_equations done" << endl;
		}
}


}}
