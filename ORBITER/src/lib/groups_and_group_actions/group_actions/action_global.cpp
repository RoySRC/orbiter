// action_global.C
//
// Anton Betten
// October 10, 2013

#include "foundations/foundations.h"
#include "groups_and_group_actions.h"

namespace orbiter {

static void print_from_to(int d, int i, int j, int *v1, int *v2);

action *create_automorphism_group_from_group_table(
	const char *fname_base,
	int *Table, int group_order, int *gens, int nb_gens, 
	strong_generators *&Aut_gens, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int *N_gens;
	int N_nb_gens;
	int N_go;
	longinteger_object go;
	//int i;

	if (f_v) {
		cout << "create_automorphism_group_from_group_table" << endl;
		}
	
	magma_normalizer_in_Sym_n(fname_base,
		group_order, Table, gens, nb_gens,
		N_gens, N_nb_gens, N_go, verbose_level);

	cout << "The holomorph has order " << N_go
			<< " and is generated by " << N_nb_gens << " elements" << endl;
	go.create(N_go);

#if 0
	for (i = 0; i < N_nb_gens; i++) {
		cout << "holomorph generator " << i << " / "
				<< N_nb_gens << ":" << endl;

		ord = perm_order(N_gens + i * H->group_order, H->group_order);
		cout << "an element of order " << ord << endl;
		for (j = 0; j < nb_gens; j++) {
			a = gens[j];
			b = N_gens[i * H->group_order + a];
			cout << a << " -> " << b << " : ";
			H->unrank_element(H->Elt1, a);
			H->unrank_element(H->Elt2, b);
			int_vec_print(cout, H->Elt1, H->len);
			cout << " -> ";
			int_vec_print(cout, H->Elt2, H->len);
			cout << endl;
			}
		}
	given_base_length = H->len;
	given_base = NEW_int(given_base_length);
	for (i = 0; i < given_base_length; i++) {
		given_base[i] = i_power_j(q, i);
		}
	cout << "given base: ";
	int_vec_print(cout, given_base, given_base_length);
	cout << endl;
#endif

	action *A;
	
	A = NEW_OBJECT(action);


	cout << "creating holomorph" << endl;
	A->init_permutation_group_from_generators(
		group_order /* degree */,
		TRUE, go, 
		N_nb_gens, N_gens, 
		nb_gens /* given_base_length */, gens /* given_base */,
		verbose_level);
	{
	longinteger_object go;
	A->group_order(go);
	cout << "The order of the holomorph is " << go << endl;
	}

	longinteger_object Aut_order;
	cout << "creating automorphism group" << endl;
	Aut_gens = A->Strong_gens->point_stabilizer(0 /* pt */, verbose_level);
	Aut_gens->group_order(Aut_order);
	cout << "The automorphism group has order " << Aut_order << endl;

	return A;
}

void create_linear_group(sims *&S, action *&A, 
	finite_field *F, int m, 
	int f_projective, int f_general, int f_affine, 
	int f_semilinear, int f_special, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	//int f_vv = (verbose_level >= 2);
	int f_basis = TRUE;
	
	if (f_v) {
		cout << "action_global.C create_linear_group "
				"m=" << m << " q=" << F->q << endl;
		}

	A = NEW_OBJECT(action);

	if (f_projective) {
		if (f_v) {
			cout << "action_global.C before init_projective_group "
					"m=" << m << " q=" << F->q
					<< " f_semilinear=" << f_semilinear << endl;
			}
		A->init_projective_group(m, F, f_semilinear, 
			f_basis, verbose_level);
		}
	else if (f_general) {
		if (f_v) {
			cout << "action_global.C before init_general_linear_group "
					"m=" << m << " q=" << F->q
					<< " f_semilinear=" << f_semilinear << endl;
			}
		A->init_general_linear_group(m, F, f_semilinear, 
			f_basis, verbose_level);
		}
	else if (f_affine) {
		if (f_v) {
			cout << "action_global.C before init_affine_group "
					"m=" << m << " q=" << F->q
					<< " f_semilinear=" << f_semilinear << endl;
			}
		A->init_affine_group(m, F, f_semilinear, 
			f_basis, verbose_level);
		}
	else {
		cout << "action_global.C create_linear_group "
				"the type of group is not specified" << endl;
		exit(1);
		}


	if (!A->f_has_strong_generators) {
		cout << "action_global.C create_linear_group "
				"fatal: !A->f_has_strong_generators" << endl;
		}



	if (f_special) {


		if (f_v) {
			cout << "action_global.C create_linear_group "
					"computing intersection with "
					"special linear group" << endl;
			}


		action A_on_det;
		longinteger_object go;
		
		A_on_det.induced_action_on_determinant(A->Sims, verbose_level);
		if (f_v) {
			cout << "action_global.C create_linear_group "
					"induced_action_on_determinant finished" << endl;
			}
		A_on_det.Kernel->group_order(go);
		if (f_v) {
			cout << "action_global.C create_linear_group "
					"intersection has order " << go << endl;
			}
		

		strong_generators *SG;

		SG = NEW_OBJECT(strong_generators);
		if (f_v) {
			cout << "action_global.C creating strong generators "
					"for the kernel n the action "
					"on the determinant" << endl;
			}
		
		SG->init_from_sims(A_on_det.Kernel, 0 /* verbose_level */);
		S = SG->create_sims(0 /* verbose_level */);
		FREE_OBJECT(SG);
		}
	else {

		S = A->Strong_gens->create_sims(0 /* verbose_level */);
		}

	if (f_v) {
		cout << "action_global.C create_linear_group "
				"sims object has been created" << endl;
		}


	
	


	
	if (f_v) {
		A->print_base();
#if 0
		if (f_projective) {
			display_all_PG_elements(m - 1, *F);
			}
#endif
		}
	
	

	if (f_v) {
		cout << "action_global.C create_linear_group finished" << endl;
		}
}



action *create_induced_action_by_restriction(action *A,
		sims *S, int size, int *set, int f_induce,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	action *A2;

	if (f_v) {
		cout << "create_induced_action_by_restriction" << endl;
		}
	A2 = NEW_OBJECT(action);
	A2->induced_action_by_restriction(*A,
			f_induce,  S, size, set, verbose_level - 1);
	if (f_v) {
		cout << "create_induced_action_by_restriction done" << endl;
		}
	return A2;
}

action *create_induced_action_on_sets(action *A,
		sims *S, int nb_sets, int set_size, int *sets, int f_induce,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	action *A2;

	if (f_v) {
		cout << "create_induced_action_on_sets" << endl;
		}
	A2 = NEW_OBJECT(action);
	A2->induced_action_on_sets(*A,
			S, nb_sets, set_size, sets, f_induce, verbose_level - 1);
	if (f_v) {
		cout << "create_induced_action_on_sets done" << endl;
		}
	return A2;
}


void create_orbits_on_subset_using_restricted_action(
		action *&A_by_restriction,
		schreier *&Orbits, action *A, sims *S,
		int size, int *set,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_induce = FALSE;

	if (f_v) {
		cout << "create_orbits_on_subset_using_restricted_action" << endl;
		}
	A_by_restriction = create_induced_action_by_restriction(A,
			S, size, set, f_induce, verbose_level - 1);
	Orbits = NEW_OBJECT(schreier);

	A_by_restriction->compute_all_point_orbits(*Orbits,
			S->gens, verbose_level - 2);
	if (f_v) {
		cout << "create_orbits_on_subset_using_restricted_action done" << endl;
		}
	
}

void create_orbits_on_sets_using_action_on_sets(
		action *&A_on_sets,
		schreier *&Orbits, action *A, sims *S,
		int nb_sets, int set_size, int *sets,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_induce = FALSE;

	if (f_v) {
		cout << "create_orbits_on_sets_using_action_on_sets" << endl;
		}
	A_on_sets = create_induced_action_on_sets(A,
			S, nb_sets, set_size, sets, f_induce, verbose_level - 1);
	Orbits = NEW_OBJECT(schreier);

	A_on_sets->compute_all_point_orbits(*Orbits, S->gens, verbose_level - 2);
	if (f_v) {
		cout << "create_orbits_on_sets_using_action_on_sets done" << endl;
		}
	
}


action *new_action_by_right_multiplication(
		sims *group_we_act_on,
		int f_transfer_ownership,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	action *A;

	if (f_v) {
		cout << "new_action_by_right_multiplication" << endl;
		}
	A = NEW_OBJECT(action);
	A->induced_action_by_right_multiplication(FALSE /* f_basis */,
		NULL /* sims *old_G */,
		group_we_act_on, f_transfer_ownership /* f_ownership */,
		verbose_level - 1);
	if (f_v) {
		cout << "new_action_by_right_multiplication done" << endl;
		}
	return A;
}

void action_print_symmetry_group_type(ostream &ost,
		symmetry_group_type a)
{
	if (a == unknown_symmetry_group_t) {
		ost << "unknown_symmetry_group_t";
		}
	else if (a == matrix_group_t) {
		ost << "matrix_group_t";
		}
	else if (a == perm_group_t) {
		ost << "perm_group_t";
		}
	else if (a == wreath_product_t) {
		ost << "wreath_product_t";
		}
	else if (a == direct_product_t) {
		ost << "direct_product_t";
		}
	else if (a == action_on_sets_t) {
		ost << "action_on_sets_t";
		}
	else if (a == action_on_set_partitions_t) {
		ost << "action_on_set_partitions_t";
		}
	else if (a == action_on_subgroups_t) {
		ost << "action_on_subgroups_t";
		}
	else if (a == action_on_pairs_t) {
		ost << "action_on_pairs_t";
		}
	else if (a == action_on_ordered_pairs_t) {
		ost << "action_on_ordered_pairs_t";
		}
	else if (a == base_change_t) {
		ost << "base_change_t";
		}
	else if (a == product_action_t) {
		ost << "product_action_t";
		}
	else if (a == action_by_right_multiplication_t) {
		ost << "action_by_right_multiplication_t";
		}
	else if (a == action_by_restriction_t) {
		ost << "action_by_restriction_t";
		}
	else if (a == action_by_conjugation_t) {
		ost << "action_by_conjugation_t";
		}
	else if (a == action_by_representation_t) {
		ost << "action_by_representation_t";
		}
	else if (a == action_by_subfield_structure_t) {
		ost << "action_by_subfield_structure_t";
		}
	else if (a == action_on_determinant_t) {
		ost << "action_on_determinant_t";
		}
	else if (a == action_on_sign_t) {
		ost << "action_on_sign_t";
		}
	else if (a == action_on_grassmannian_t) {
		ost << "action_on_grassmannian_t";
		}
	else if (a == action_on_spread_set_t) {
		ost << "action_on_spread_set_t";
		}
	else if (a == action_on_cosets_t) {
		ost << "action_on_cosets_t";
		}
	else if (a == action_on_factor_space_t) {
		ost << "action_on_factor_space_t";
		}
	else if (a == action_on_wedge_product_t) {
		ost << "action_on_wedge_product_t";
		}
	else if (a == action_on_bricks_t) {
		ost << "action_on_bricks_t";
		}
	else if (a == action_on_andre_t) {
		ost << "action_on_andre_t";
		}
	else if (a == action_on_orthogonal_t) {
		ost << "action_on_orthogonal_t";
		}
	else if (a == action_on_orbits_t) {
		ost << "action_on_orbits_t";
		}
	else if (a == action_on_flags_t) {
		ost << "action_on_flags_t";
		}
	else if (a == action_on_homogeneous_polynomials_t) {
		ost << "action_on_homogeneous_polynomials_t";
		}
	else {
		ost << "unknown symmetry_group_type" << endl;
		}
}

int choose_next_base_point_default_method(action *A,
		int *Elt, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int b;
	
	if (f_v) {
		cout << "choose_next_base_point_default_method" << endl;
		cout << "calling A->find_non_fixed_point" << endl;
		}
	b = A->find_non_fixed_point(Elt, verbose_level - 1);
	if (b == -1) {
		if (f_v) {
			cout << "cannot find another base point" << endl;
			}
		return -1;
		}
	if (f_v) {
		cout << "choose_next_base_point_default_method current base: ";
		int_vec_print(cout, A->base, A->base_len);
		cout << " choosing next base point to be " << b << endl;
		}
	return b;
}

void make_generators_stabilizer_of_two_components(
	action *A_PGL_n_q, action *A_PGL_k_q,
	int k, vector_ge *gens, int verbose_level)
// used in semifield.C
// does not include the swap
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int *Q;
	int *Elt1;
	int *Zero;
	int *Id;
	int *Center;
	int *minusId;
	int n, i, len;
	int *P;
	matrix_group *Mtx;
	finite_field *Fq;
	int minus_one, alpha;
	strong_generators *gens_PGL_k;
	//vector_ge *gens_PGL_k;


	if (f_v) {
		cout << "make_generators_stabilizer_of_two_components" << endl;
		}
	n = 2 * k;

	Zero = NEW_int(k * k);
	Id = NEW_int(k * k);
	Center = NEW_int(k * k);
	minusId = NEW_int(k * k);
	Q = NEW_int(n * n + 1);
	Elt1 = NEW_int(A_PGL_n_q->elt_size_in_int);


	Mtx = A_PGL_k_q->G.matrix_grp;
	Fq = Mtx->GFq;
	minus_one = Fq->negate(1);
	alpha = Fq->primitive_root();

	int_vec_zero(Zero, k * k);
	int_vec_zero(Id, k * k);
	int_vec_zero(Center, k * k);
	int_vec_zero(minusId, k * k);
	for (i = 0; i < k; i++) {
		Id[i * k + i] = 1;
		}
	for (i = 0; i < k; i++) {
		Center[i * k + i] = alpha;
		}
	for (i = 0; i < k; i++) {
		minusId[i * k + i] = minus_one;
		}

	gens_PGL_k = A_PGL_k_q->Strong_gens;
	//gens_PGL_k = A_PGL_k_q->strong_generators;
	
	len = gens_PGL_k->gens->len;
	//len = gens_PGL_k->len;

	int *Data;
	int new_len, sz, idx, h;

	new_len = 2 * len + 2;
	sz = n * n;
	if (Mtx->f_semilinear) {
		sz++;
		}
	

	Data = NEW_int(new_len * sz);
	idx = 0;
	for (h = 0; h < 2 * len; h++) {

		P = gens_PGL_k->gens->ith(h / 2);
		//P = gens_PGL_k->ith(h / 2);

		if (EVEN(h)) {
			// Q := diag(P,Id)
			int_matrix_make_block_matrix_2x2(Q, k, P, Zero, Zero, Id);
			}
		else {
			// Q := diag(Id,P)
			int_matrix_make_block_matrix_2x2(Q, k, Id, Zero, Zero, P);
			}
		if (Mtx->f_semilinear) {
			Q[n * n] = P[k * k];
			}
		int_vec_copy(Q, Data + idx * sz, sz);
		idx++;
		}

#if 0
	// Q := matrix(0,I,I,0):
	int_matrix_make_block_matrix_2x2(Q, k, Zero, Id, Id, Zero);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	int_vec_copy(Q, Data + idx * sz, sz);
	idx++;
#endif

	// Q := matrix(Center,0,0,I):
	int_matrix_make_block_matrix_2x2(Q, k, Center, Zero, Zero, Id);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	int_vec_copy(Q, Data + idx * sz, sz);
	idx++;

	// Q := matrix(I,0,0,Center):
	int_matrix_make_block_matrix_2x2(Q, k, Id, Zero, Zero, Center);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	int_vec_copy(Q, Data + idx * sz, sz);
	idx++;


	if (idx != new_len) {
		cout << "make_generators_stabilizer_of_two_components "
				"idx != new_len" << endl;
		exit(1);
		}



	gens->init(A_PGL_n_q);
	gens->allocate(new_len);
	for (h = 0; h < new_len; h++) {
		A_PGL_n_q->make_element(Elt1, Data + h * sz, 0);
		if (f_vv) {
			cout << "make_generators_stabilizer_of_two_components "
					"after make_element generator " << h << " : " << endl;
			A_PGL_n_q->print_quick(cout, Elt1);
			}
		A_PGL_n_q->move(Elt1, gens->ith(h));
		}
	

	FREE_int(Data);

	FREE_int(Zero);
	FREE_int(Id);
	FREE_int(Center);
	FREE_int(minusId);
	FREE_int(Q);
	FREE_int(Elt1);
	if (f_v) {
		cout << "make_generators_stabilizer_of_two_components done" << endl;
		}
}


void make_generators_stabilizer_of_three_components(
	action *A_PGL_n_q, action *A_PGL_k_q,
	int k, vector_ge *gens, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int *Q;
	int *Elt1;
	int *Zero;
	int *Id;
	int *minusId;
	int n, i, len;
	int *P;
	matrix_group *Mtx;
	finite_field *Fq;
	int minus_one;
	strong_generators *gens_PGL_k;

	if (f_v) {
		cout << "make_generators_stabilizer_of_three_components" << endl;
		}
	n = 2 * k;

	Zero = NEW_int(k * k);
	Id = NEW_int(k * k);
	minusId = NEW_int(k * k);
	Q = NEW_int(n * n + 1);
	Elt1 = NEW_int(A_PGL_n_q->elt_size_in_int);


	Mtx = A_PGL_k_q->G.matrix_grp;
	Fq = Mtx->GFq;
	minus_one = Fq->negate(1);


	int_vec_zero(Zero, k * k);
	int_vec_zero(Id, k * k);
	int_vec_zero(minusId, k * k);
	for (i = 0; i < k; i++) {
		Id[i * k + i] = 1;
		}
	for (i = 0; i < k; i++) {
		minusId[i * k + i] = minus_one;
		}

	gens_PGL_k = A_PGL_k_q->Strong_gens;
	//gens_PGL_k = A_PGL_k_q->strong_generators;
	
	len = gens_PGL_k->gens->len;
	//len = gens_PGL_k->len;

	int *Data;
	int new_len, sz, idx, h;

	new_len = len + 2;
	sz = n * n;
	if (Mtx->f_semilinear) {
		sz++;
		}
	

	Data = NEW_int(new_len * sz);
	idx = 0;
	for (h = 0; h < len; h++) {

		P = gens_PGL_k->gens->ith(h);
		//P = gens_PGL_k->ith(h);

		// Q := diag(P,P)
		int_matrix_make_block_matrix_2x2(Q, k, P, Zero, Zero, P);
		if (Mtx->f_semilinear) {
			Q[n * n] = P[k * k];
			}
		int_vec_copy(Q, Data + idx * sz, sz);
		idx++;
		}

	// Q := matrix(0,I,I,0):
	int_matrix_make_block_matrix_2x2(Q, k, Zero, Id, Id, Zero);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	int_vec_copy(Q, Data + idx * sz, sz);
	idx++;

	// Q := matrix(0,I,-I,-I):
	int_matrix_make_block_matrix_2x2(Q, k, Zero, Id, minusId, minusId);
	if (Mtx->f_semilinear) {
		Q[n * n] = 0;
		}
	int_vec_copy(Q, Data + idx * sz, sz);
	idx++;


	if (idx != new_len) {
		cout << "make_generators_stabilizer_of_three_components "
				"idx != new_len" << endl;
		exit(1);
		}



	gens->init(A_PGL_n_q);
	gens->allocate(new_len);
	for (h = 0; h < new_len; h++) {
		A_PGL_n_q->make_element(Elt1, Data + h * sz, 0);
		if (f_vv) {
			cout << "make_generators_stabilizer_of_three_components "
					"after make_element generator " << h << " : " << endl;
			A_PGL_n_q->print_quick(cout, Elt1);
			}
		A_PGL_n_q->move(Elt1, gens->ith(h));
		}
	

	FREE_int(Data);

	FREE_int(Zero);
	FREE_int(Id);
	FREE_int(minusId);
	FREE_int(Q);
	FREE_int(Elt1);
	if (f_v) {
		cout << "make_generators_stabilizer_of_three_components done" << endl;
		}
}

void generators_to_strong_generators(action *A, 
	int f_target_go, longinteger_object &target_go, 
	vector_ge *gens, strong_generators *&Strong_gens, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "generators_to_strong_generators" << endl;
		if (f_target_go) {
			cout << "trying to create a group of order " << target_go << endl;
			}
		}

	sims *S;
	
	if (f_v) {
		cout << "generators_to_strong_generators "
				"before create_sims_from_generators_randomized" << endl;
		}

	S = create_sims_from_generators_randomized(A, 
		gens, f_target_go, 
		target_go, verbose_level - 2);

	if (f_v) {
		cout << "generators_to_strong_generators "
				"after create_sims_from_generators_randomized" << endl;
		}

	Strong_gens = NEW_OBJECT(strong_generators);
	Strong_gens->init_from_sims(S, 0);

	FREE_OBJECT(S);

	if (f_v) {
		cout << "generators_to_strong_generators done" << endl;
		}
}

void compute_generators_GL_n_q(int *&Gens,
		int &nb_gens, int &elt_size, int n, finite_field *F,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	action *A;
	vector_ge *gens;
	int *Elt;
	int h, i, l, alpha;

	if (f_v) {
		cout << "compute_generators_GL_n_q" << endl;
		}
	A = NEW_OBJECT(action);

	A->init_projective_group(n, F,
			FALSE /* f_semilinear */,
			TRUE /* f_basis */, verbose_level - 2);

	gens = A->Strong_gens->gens;

	l = gens->len;
	nb_gens = l + 1;
	elt_size = n * n;
	Gens = NEW_int(nb_gens * elt_size);
	for (h = 0; h < nb_gens; h++) {
		if (h < l) {
			Elt = gens->ith(h);
			for (i = 0; i < n * n; i++) {
				Gens[h * elt_size + i] = Elt[i];
				}
			}
		else {
			for (i = 0; i < n * n; i++) {
				Gens[h * elt_size + i] = 0;
				}
			alpha = F->primitive_root();
			for (i = 0; i < n; i++) {
				Gens[h * elt_size + i * n + i] = alpha;
				}
			}
		}
	if (f_vv) {
		for (h = 0; h < nb_gens; h++) {
			cout << "Generator " << h << ":" << endl;
			int_matrix_print(Gens + h * elt_size, n, n);
			}
		
		}
	FREE_OBJECT(A);
	if (f_v) {
		cout << "compute_generators_GL_n_q done" << endl;
		}
}

void order_of_PGGL_n_q(longinteger_object &go,
		int n, int q, int f_semilinear)
{
	int verbose_level = 0;
	action *A;
	finite_field *F;

	F = NEW_OBJECT(finite_field);
	A = NEW_OBJECT(action);

	F->init(q, 0);
	A->init_projective_group(n, F, 
		f_semilinear, 
		TRUE /* f_basis */, verbose_level - 2);
	A->group_order(go);
	
	FREE_OBJECT(F);
	FREE_OBJECT(A);
}


// callbacks for Schreier Sims:


	int f_generator_orthogonal_siegel = TRUE;
	int f_generator_orthogonal_reflection = TRUE;
	int f_generator_orthogonal_similarity = TRUE;
	int f_generator_orthogonal_semisimilarity = TRUE;


void set_orthogonal_group_type(int f_siegel,
		int f_reflection,
		int f_similarity,
		int f_semisimilarity)
{
	f_generator_orthogonal_siegel = f_siegel;
	f_generator_orthogonal_reflection = f_reflection;
	f_generator_orthogonal_similarity = f_similarity;
	f_generator_orthogonal_semisimilarity = f_semisimilarity;
}

int get_orthogonal_group_type_f_reflection()
{
	return f_generator_orthogonal_reflection;
}

void callback_choose_random_generator_orthogonal(int iteration, 
	int *Elt, void *data, int verbose_level)
{
	//verbose_level += 5;
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "callback_choose_random_generator_orthogonal "
				"iteration=" << iteration << endl;
		}

	schreier_sims *ss = (schreier_sims *) data;
	action *A = ss->GA;
	action *subaction = ss->KA;
	matrix_group *M;
#if 0
	int f_siegel = TRUE;
	int f_reflection = TRUE;
	int f_similarity = TRUE;
	int f_semisimilarity = TRUE;
#endif

	action_on_orthogonal *AO;
	orthogonal *O;
	
	AO = A->G.AO;
	O = AO->O;
	
	M = subaction->G.matrix_grp;
	if (f_v) {
		cout << "callback_choose_random_generator_orthogonal "
				"iteration=" << iteration
				<< " before M->orthogonal_group_random_generator"
				<< endl;
		}
	M->orthogonal_group_random_generator(ss->GA, O, 
		f_generator_orthogonal_siegel, 
		f_generator_orthogonal_reflection, 
		f_generator_orthogonal_similarity, 
		f_generator_orthogonal_semisimilarity, 
		Elt, verbose_level - 2);
	//M->GL_invert_internal(Elt, Elt + M->elt_size_int_half, 0);
	if (f_v) {
		cout << "callback_choose_random_generator_orthogonal "
				"iteration=" << iteration
				<< " after M->orthogonal_group_random_generator"
				<< endl;
		}

	if (f_v) {
		cout << "callback_choose_random_generator_orthogonal "
				"iteration=" << iteration << " done" << endl;
		}
}



void test_matrix_group(int k, int q, int f_semilinear, int verbose_level)
{
	action A;
	finite_field *F;
	int f_basis = TRUE;
	
	F = NEW_OBJECT(finite_field);
	F->init(q, 0);
	A.init_projective_group(k, F, f_semilinear, f_basis, verbose_level);
	FREE_OBJECT(F);
}

void lift_generators(vector_ge *gens_in, vector_ge *&gens_out, 
	action *Aq, subfield_structure *S, int n, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int *EltQ;
	int *Eltq;
	int *Mtx;
	int nb_gens, m, t;


	if (f_v) {
		cout << "lift_generators" << endl;
		}

	nb_gens = gens_in->len;

	m = n / S->s;

	gens_out = NEW_OBJECT(vector_ge);

	Eltq = NEW_int(Aq->elt_size_in_int);
	Mtx = NEW_int(n * n);

	if (f_v) {
		cout << "lift_generators lifting generators" << endl;
		}
	gens_out->init(Aq);
	gens_out->allocate(nb_gens);
	for (t = 0; t < nb_gens; t++) {
		if (f_vv) {
			cout << "lift_generators " << t << " / " << nb_gens << endl;
			}
		EltQ = gens_in->ith(t);
		S->lift_matrix(EltQ, m, Mtx, 0 /* verbose_level */);
		if (f_vv) {
			cout << "lift_generators lifted matrix:" << endl;
			int_matrix_print(Mtx, n, n);
			}
		Aq->make_element(Eltq, Mtx, 0 /*verbose_level - 4 */);
		if (f_vv) {
			cout << "lift_generators after make_element:" << endl;
			Aq->element_print_quick(Eltq, cout);
			}
		Aq->element_move(Eltq, gens_out->ith(t), 0);
		if (f_vv) {
			cout << "lift_generators " << t << " / "
					<< nb_gens << " done" << endl;
			}
		}
	FREE_int(Eltq);
	FREE_int(Mtx);
	if (f_v) {
		cout << "lift_generators done" << endl;
		}

}

void retract_generators(vector_ge *gens_in,
	vector_ge *&gens_out,
	action *AQ, subfield_structure *S, int n, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int *EltQ;
	int *Eltq;
	int *Mtx;
	int nb_gens, m, t;


	if (f_v) {
		cout << "retract_generators" << endl;
		}

	nb_gens = gens_in->len;

	m = n / S->s;

	gens_out = NEW_OBJECT(vector_ge);

	EltQ = NEW_int(AQ->elt_size_in_int);
	Mtx = NEW_int(m * m);

	if (f_v) {
		cout << "retract_generators retracting generators" << endl;
		}
	gens_out->init(AQ);
	gens_out->allocate(nb_gens);
	for (t = 0; t < nb_gens; t++) {
		if (f_vv) {
			cout << "retract_generators " << t
					<< " / " << nb_gens << endl;
			}
		Eltq = gens_in->ith(t);
		S->retract_matrix(Eltq, n, Mtx, m, 0 /* verbose_level */);
		if (f_vv) {
			cout << "retract_generators retracted matrix:" << endl;
			int_matrix_print(Mtx, m, m);
			}
		AQ->make_element(EltQ, Mtx, 0 /*verbose_level - 4*/);
		if (f_vv) {
			cout << "retract_generators after make_element:" << endl;
			AQ->element_print_quick(EltQ, cout);
			}
		AQ->element_move(EltQ, gens_out->ith(t), 0);
		if (f_vv) {
			cout << "retract_generators " << t
					<< " / " << nb_gens << " done" << endl;
			}
		}
	FREE_int(EltQ);
	FREE_int(Mtx);
	if (f_v) {
		cout << "retract_generators done" << endl;
		}

}

void lift_generators_to_subfield_structure(
	int n, int s, 
	subfield_structure *S, 
	action *Aq, action *AQ, 
	strong_generators *&Strong_gens, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int q, Q, m;
	finite_field *Fq;
	//finite_field *FQ;
	sims *Sims;

	if (f_v) {
		cout << "lift_generators_to_subfield_structure" << endl;
		}
	Fq = S->Fq;
	//FQ = S->FQ;
	q = Fq->q;
	Q = i_power_j(q, s);
	m = n / s;
	if (m * s != n) {
		cout << "lift_generators_to_subfield_structure "
				"s must divide n" << endl;
		exit(1);
		}
	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"creating subfield structure" << endl;
		}
	if (f_v) {
		cout << "n=" << n << endl;
		cout << "s=" << s << endl;
		cout << "m=" << m << endl;
		cout << "q=" << q << endl;
		cout << "Q=" << Q << endl;
		}

	longinteger_object order_GLmQ;
	longinteger_object target_go;
	longinteger_domain D;
	int r;

	AQ->group_order(order_GLmQ);
	

	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"order of GL(m,Q) = " << order_GLmQ << endl;
		}
	D.integral_division_by_int(order_GLmQ, 
		q - 1, target_go, r);
	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"target_go = " << target_go << endl;
		}



	vector_ge *gens;
	vector_ge *gens1;


	gens = AQ->Strong_gens->gens;


	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"before lift_generators" << endl;
		}
	lift_generators(gens, gens1, Aq, S, n, verbose_level);
		// ACTION/action_global.C
	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"after lift_generators" << endl;
		}


	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"creating lifted group:" << endl;
		}
	//Aq->group_order(target_go);
	Sims = create_sims_from_generators_with_target_group_order(Aq, 
		gens1, 
		target_go, 
		0 /* verbose_level */);

#if 0
	Sims = create_sims_from_generators_without_target_group_order(Aq, 
		gens1, MINIMUM(2, verbose_level - 3));
#endif

	if (f_v) {
		cout << "lift_generators_to_subfield_structure "
				"creating lifted group done" << endl;
		}

	longinteger_object go;

	Sims->group_order(go);

	if (f_v) {
		cout << "go=" << go << endl;
		}


	Strong_gens = NEW_OBJECT(strong_generators);

	Strong_gens->init_from_sims(Sims, 0 /* verbose_level */);
	if (f_vv) {
		cout << "lift_generators_to_subfield_structure "
				"strong generators are:" << endl;
		Strong_gens->print_generators();
		}


	FREE_OBJECT(gens1);
	FREE_OBJECT(Sims);
	if (f_v) {
		cout << "lift_generators_to_subfield_structure done" << endl;
		}

}




#if 0
action *create_automorphism_group_of_graph(
	int n, int *Adj, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int parts[1];
	action *A;
	int *labeling;

	parts[0] = n;
	labeling = NEW_int(n);

	if (f_v) {
		cout << "create_automorphism_group_of_graph" << endl;
		}
	A = create_automorphism_group_of_graph_with_partition_and_labeling(
			n, FALSE, NULL, Adj, 1, parts, labeling, verbose_level);
	if (f_v) {
		cout << "create_automorphism_group_of_graph done" << endl;
		}
	FREE_int(labeling);
	return A;
}
#endif
action *create_automorphism_group_of_colored_graph_object(
		colored_graph *CG, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	action *A;

	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph" << endl;
		}

	A = create_automorphism_group_of_colored_graph(
		CG->nb_points, TRUE /* f_bitvec */,
		CG->bitvector_adjacency, NULL /* int  *Adj */,
		CG->point_color, 
		verbose_level);

	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph done" << endl;
		}
	return A;
}

action *create_automorphism_group_of_colored_graph(
	int n, int f_bitvec, uchar *Adj_bitvec, int *Adj, 
	int *vertex_colors, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	action *A;
	uchar *Adj1;
	int *labeling;
	int *parts;
	int nb_parts;
	int i, j, k, n1, N, len, f_on = 0, c, nb_edges;

	labeling = NEW_int(n);

	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph" << endl;
		}

	classify C;

	C.init(vertex_colors, n, FALSE, 0);


	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph "
				"nb_types = " << C.nb_types << endl;
		}


	n1 = n + C.nb_types;

	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph "
				"n1 = " << n1 << endl;
		}

	N = (n1 * (n1 - 1)) >> 1;
	len = (N + 7) >> 3;
	Adj1 = NEW_uchar(len);
	for (i = 0; i < len; i++) {
		Adj1[i] = 0;
		}

	nb_edges = 0;
	for (i = 0; i < n; i++) {
		for (j = i + 1; j < n; j++) {
			k = ij2k(i, j, n);
			if (f_bitvec) {
				if (bitvector_s_i(Adj_bitvec, k)) {
					f_on = TRUE;
					}
				}
			else {
				f_on = Adj[i * n + j];
				}
			if (f_on) {
				k = ij2k(i, j, n1);
				bitvector_m_ii(Adj1, k, 1);
				nb_edges++;
				}
			}
		}
	for (i = 0; i < n; i++) {
		c = C.class_of(i);
		j = n + c;
		k = ij2k(i, j, n1);
		bitvector_m_ii(Adj1, k, 1);
		}


	nb_parts = 1 + C.nb_types;
	parts = NEW_int(nb_parts);
	parts[0] = n;
	for (i = 0; i < C.nb_types; i++) {
		parts[1 + i] = 1;
		}
	
	

	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph "
				"before create_automorphism_group_of_graph_with_"
				"partition_and_labeling" << endl;
		cout << "nb_edges=" << nb_edges << endl;
		}
	A = create_automorphism_group_of_graph_with_partition_and_labeling(
			n1, TRUE, Adj1, NULL,
			nb_parts, parts, labeling, verbose_level);
	if (f_v) {
		cout << "create_automorphism_group_of_colored_graph done" << endl;
		}

	FREE_int(parts);
	FREE_int(labeling);
	FREE_uchar(Adj1);
	return A;
}

action *create_automorphism_group_of_graph_bitvec(
	int n, uchar *Adj_bitvec, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int parts[1];
	action *A;
	int *labeling;

	parts[0] = n;
	labeling = NEW_int(n);

	if (f_v) {
		cout << "create_automorphism_group_of_graph_bitvec" << endl;
		}
	A = create_automorphism_group_of_graph_with_partition_and_labeling(
			n, TRUE, Adj_bitvec, NULL,
			1, parts, labeling, verbose_level);
	if (f_v) {
		cout << "create_automorphism_group_of_graph_bitvec done" << endl;
		}
	FREE_int(labeling);
	return A;
}

action *create_automorphism_group_of_graph_with_partition_and_labeling(
	int n, 
	int f_bitvector, uchar *Adj_bitvec, int *Adj, 
	int nb_parts, int *parts, 
	int *labeling, 
	int verbose_level)
// labeling[n]
{
	int f_v = (verbose_level >= 1);
	int f_v10 = (verbose_level >= 10);
	//int *labeling; //, *labeling_inv;
	int *Aut;
	int *Base, *Transversal_length, *partitions;
	int Aut_counter = 0, Base_length = 0, Ago = 0;
	int i, u, a;
	longinteger_object ago;
	
	
	//m = # rows
	//n = # cols
	
	Aut = NEW_int(n * n);
	Base = NEW_int(n);
	Transversal_length = NEW_int(n);
	partitions = NEW_int(n);

	if (f_v) {
		cout << "create_automorphism_group_of_graph_with_"
				"partition_and_labeling" << endl;
		}
	for (i = 0; i < n; i++) {
		partitions[i] = 1;
		}
	u = 0;
	for (i = 0; i < nb_parts; i++) {
		a = parts[i];
		u += a;
		partitions[u - 1] = 0;
		}
	if (u != n) {
		cout << "create_automorphism_group_of_graph_with_"
				"partition_and_labeling "
				"partition does not add up" << endl;
		exit(1);
		}

	//partitions[n - 1] = 0;

	//labeling = NEW_int(n);
	//labeling_inv = NEW_int(n);
	
	if (f_bitvector) {
		if (f_v) {
			cout << "create_automorphism_group_of_graph_with_"
					"partition_and_labeling "
					"before nauty_interface_graph_bitvec" << endl;
			}
		nauty_interface_graph_bitvec(n, Adj_bitvec, 
			labeling, partitions, 
			Aut, Aut_counter, 
			Base, Base_length, 
			Transversal_length, Ago, verbose_level);
		}
	else {
		nauty_interface_graph_int(n, Adj, 
			labeling, partitions, 
			Aut, Aut_counter, 
			Base, Base_length, 
			Transversal_length, Ago, verbose_level);
		}

	if (f_v) {
		if (TRUE /*(input_no % 500) == 0*/) {
			cout << "create_automorphism_group_of_graph_with_"
					"partition_and_labeling: "
					"The group order is = " << Ago << endl;
			cout << "transversal length: ";
			int_vec_print(cout, Transversal_length, Base_length);
			cout << endl;
			}
		}

#if 0
	for (i = 0; i < n; i++) {
		j = labeling[i];
		labeling_inv[j] = i;
		}
#endif

	if (f_v10) {
		cout << "create_automorphism_group_of_graph_with_"
				"partition_and_labeling: "
				"labeling:" << endl;
		int_vec_print(cout, labeling, n);
		cout << endl;
		//cout << "labeling_inv:" << endl;
		//int_vec_print(cout, labeling_inv, n);
		//cout << endl;

		cout << "create_automorphism_group_of_graph_with_"
				"partition_and_labeling: "
				"Base:" << endl;
		int_vec_print(cout, Base, Base_length);
		cout << endl;

		cout << "create_automorphism_group_of_graph_with_"
				"partition_and_labeling: "
				"generators:" << endl;
		print_integer_matrix_width(cout, Aut, Aut_counter, n, n, 2);
		}



	action *A;


	A = NEW_OBJECT(action);

	ago.create(Ago);

	A->init_permutation_group_from_generators(n, 
		FALSE, ago, 
		Aut_counter, Aut, 
		Base_length, Base,
		verbose_level - 2);

	if (f_v) {
		cout << "create_automorphism_group_of_graph_with_"
				"partition_and_labeling: "
				"created action ";
		A->print_info();
		cout << endl;
		}

	FREE_int(Aut);
	FREE_int(Base);
	FREE_int(Transversal_length);
	FREE_int(partitions);
	//FREE_int(labeling);

	return A;
}

void create_incidence_matrix_of_graph(int *Adj, int n,
		int *&M, int &nb_rows, int &nb_cols,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int i, j, u;
	
	if (f_v) {
		cout << "create_incidence_matrix_of_graph" << endl;
		}
	nb_rows = n;
	nb_cols = 0;
	for (i = 0; i < n; i++) {
		for (j = i + 1; j < n; j++) {
			if (Adj[i * n + j]) {
				nb_cols++;
				}
			}
		}
	M = NEW_int(n * nb_cols);
	int_vec_zero(M, n * nb_cols);
	u = 0;
	for (i = 0; i < n; i++) {
		for (j = i + 1; j < n; j++) {
			if (Adj[i * n + j]) {
				M[i * nb_cols + u] = 1;
				M[j * nb_cols + u] = 1;
				u++;
				}
			}
		}
	if (f_v) {
		cout << "create_incidence_matrix_of_graph done" << endl;
		}

}


action *create_automorphism_group_of_graph(
		int *Adj, int n, int verbose_level)
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "create_automorphism_group_of_graph n=" << n << endl;
		}

#if 0
	action *A;
	int *M;
	int nb_rows, nb_cols;

	create_incidence_matrix_of_graph(Adj, n,
			M, nb_rows, nb_cols, verbose_level);
	if (f_v) {
		cout << "create_automorphism_group_of_graph nb_rows="
				<< nb_rows << endl;
		cout << "create_automorphism_group_of_graph nb_cols="
				<< nb_cols << endl;
		}
	A = create_automorphism_group_of_incidence_matrix(
		nb_rows, nb_cols, M, verbose_level);
	
	FREE_int(M);
#else
	int *labeling;
	int *Aut;
	int *Base, *Transversal_length, *partition;
	int Aut_counter = 0, Base_length = 0, Ago = 0;
	int i;
	
		
	Aut = NEW_int(n * n);
	Base = NEW_int(n);
	Transversal_length = NEW_int(n);
	partition = NEW_int(n);
	labeling = NEW_int(n);

	if (f_v) {
		cout << "create_automorphism_group_of_graph" << endl;
		}
	for (i = 0; i < n; i++) {
		partition[i] = 1;
		}
	partition[n - 1] = 0;

	if (f_v) {
		cout << "create_automorphism_group_of_graph "
				"before nauty_interface_graph_int" << endl;
		}
	nauty_interface_graph_int(n, Adj, 
		labeling, partition, 
		Aut, Aut_counter, 
		Base, Base_length, 
		Transversal_length, Ago, verbose_level);
	if (f_v) {
		cout << "create_automorphism_group_of_graph "
				"after nauty_interface_graph_int Ago=" << Ago << endl;
		}
	action *A;
	longinteger_object ago;


	ago.create(Ago);
	A = NEW_OBJECT(action);

	if (f_v) {
		cout << "create_automorphism_group_of_graph "
				"before A->init_permutation_group_from_generators" << endl;
		}
	A->init_permutation_group_from_generators(n, 
		TRUE, ago, 
		Aut_counter, Aut, 
		Base_length, Base,
		0 /*verbose_level - 2*/);
	if (f_v) {
		cout << "create_automorphism_group_of_graph "
				"after A->init_permutation_group_from_generators" << endl;
		}

	if (f_v) {
		cout << "create_automorphism_group_of_graph: "
				"created action ";
		A->print_info();
		cout << endl;
		}

	FREE_int(Aut);
	FREE_int(Base);
	FREE_int(Transversal_length);
	FREE_int(partition);
	FREE_int(labeling);
#endif
	if (f_v) {
		cout << "create_automorphism_group_of_graph done" << endl;
		}
	return A;
}


action *create_automorphism_group_and_canonical_labeling_of_graph(
		int *Adj, int n, int *labeling,
		int verbose_level)
// labeling[n]
{
	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "create_automorphism_group_and_canonical_labeling_of_graph "
				"n=" << n << endl;
		}

	//int *labeling;
	int *Aut;
	int *Base, *Transversal_length, *partition;
	int Aut_counter = 0, Base_length = 0, Ago = 0;
	int i;
	
		
	Aut = NEW_int(n * n);
	Base = NEW_int(n);
	Transversal_length = NEW_int(n);
	partition = NEW_int(n);
	//labeling = NEW_int(n);

	if (f_v) {
		cout << "create_automorphism_group_and_canonical_labeling_of_graph"
				<< endl;
		}
	for (i = 0; i < n; i++) {
		partition[i] = 1;
		}
	partition[n - 1] = 0;

	if (f_v) {
		cout << "create_automorphism_group_and_canonical_labeling_of_graph "
				"before nauty_interface_graph_int" << endl;
		}
	nauty_interface_graph_int(n, Adj, 
		labeling, partition, 
		Aut, Aut_counter, 
		Base, Base_length, 
		Transversal_length, Ago, verbose_level);
	if (f_v) {
		cout << "create_automorphism_group_and_canonical_labeling_of_graph "
				"after nauty_interface_graph_int" << endl;
		}
	action *A;
	longinteger_object ago;

	A = NEW_OBJECT(action);

	ago.create(Ago);
	A->init_permutation_group_from_generators(n, 
		TRUE, ago, 
		Aut_counter, Aut, 
		Base_length, Base,
		0 /*verbose_level - 2*/);

	if (f_v) {
		cout << "create_automorphism_group_and_canonical_labeling_of_graph: "
				"created action ";
		A->print_info();
		cout << endl;
		}

	FREE_int(Aut);
	FREE_int(Base);
	FREE_int(Transversal_length);
	FREE_int(partition);
	//FREE_int(labeling);
	if (f_v) {
		cout << "create_automorphism_group_and_canonical_labeling_of_graph "
				"done" << endl;
		}
	return A;
}


action *create_automorphism_group_of_block_system(
	int nb_points, int nb_blocks, int block_size, int *Blocks, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int *M;
	action *A;
	int i, j, h;	
	
	if (f_v) {
		cout << "create_automorphism_group_of_block_system" << endl;
		}
	M = NEW_int(nb_points * nb_blocks);
	int_vec_zero(M, nb_points * nb_blocks);
	for (j = 0; j < nb_blocks; j++) {
		for (h = 0; h < block_size; h++) {
			i = Blocks[j * block_size + h];
			M[i * nb_blocks + j] = 1;
			}
		}
	A = create_automorphism_group_of_incidence_matrix(
		nb_points, nb_blocks, M, verbose_level);

	FREE_int(M);
	if (f_v) {
		cout << "create_automorphism_group_of_block_system done" << endl;
		}
	return A;
}

action *create_automorphism_group_of_collection_of_two_block_systems(
	int nb_points,
	int nb_blocks1, int block_size1, int *Blocks1,
	int nb_blocks2, int block_size2, int *Blocks2,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int *M;
	action *A;
	int i, j, h;
	int nb_cols;
	int nb_rows;

	if (f_v) {
		cout << "create_automorphism_group_of_collection_of_two_block_systems" << endl;
		}
	nb_cols = nb_blocks1 + nb_blocks2 + 1;
	nb_rows = nb_points + 2;

	M = NEW_int(nb_rows * nb_cols);
	int_vec_zero(M, nb_rows * nb_cols);

	// first system:
	for (j = 0; j < nb_blocks1; j++) {
		for (h = 0; h < block_size1; h++) {
			i = Blocks1[j * block_size1 + h];
			M[i * nb_cols + j] = 1;
			}
		i = nb_points + 0;
		M[i * nb_cols + j] = 1;
		}
	// second system:
	for (j = 0; j < nb_blocks2; j++) {
		for (h = 0; h < block_size2; h++) {
			i = Blocks2[j * block_size2 + h];
			M[i * nb_cols + nb_blocks1 + j] = 1;
			}
		i = nb_points + 1;
		M[i * nb_cols + nb_blocks1 + j] = 1;
		}
	// the extra column:
	for (i = 0; i < 2; i++) {
		M[(nb_points + i) * nb_cols + nb_blocks1 + nb_blocks2] = 1;
	}

	A = create_automorphism_group_of_incidence_matrix(
		nb_rows, nb_cols, M, verbose_level);

	FREE_int(M);
	if (f_v) {
		cout << "create_automorphism_group_of_collection_of_two_block_systems done" << endl;
		}
	return A;
}

action *create_automorphism_group_of_incidence_matrix(
	int m, int n, int *Mtx, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int nb_inc;
	int *X;
	action *A;
	int i, j, h;	
	
	if (f_v) {
		cout << "create_automorphism_group_of_incidence_matrix" << endl;
		}
	nb_inc = 0;
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			if (Mtx[i * n + j]) {
				nb_inc++;
				}
			}
		}
	X = NEW_int(nb_inc);
	h = 0;
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			if (Mtx[i * n + j]) {
				X[h++] = i * n + j;
				}
			}
		}
	A = create_automorphism_group_of_incidence_structure_low_level(
		m, n, nb_inc, X, verbose_level);

	FREE_int(X);
	if (f_v) {
		cout << "create_automorphism_group_of_incidence_matrix done" << endl;
		}
	return A;
}

action *create_automorphism_group_of_incidence_structure(
	incidence_structure *Inc, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	action *A;
	int m, n, nb_inc;
	int *X;
	int *data;
	int nb;
	int i, j, h, a;
	
	if (f_v) {
		cout << "create_automorphism_group_of_incidence_structure" << endl;
		}
	m = Inc->nb_points();
	n = Inc->nb_lines();
	nb_inc = Inc->get_nb_inc();
	X = NEW_int(nb_inc);
	data = NEW_int(n);
	h = 0;
	for (i = 0; i < m; i++) {
		nb = Inc->get_lines_on_point(data, i);
		for (j = 0; j < nb; j++) {
			a = data[j];
			X[h++] = i * m + a;
			}
		}
	if (h != nb_inc) {
		cout << "create_automorphism_group_of_incidence_structure "
				"h != nb_inc" << endl;
		exit(1);
		}

	A = create_automorphism_group_of_incidence_structure_low_level(
		m, n, nb_inc, X, 
		verbose_level - 1);

	FREE_int(X);
	FREE_int(data);
	return A;
}

action *create_automorphism_group_of_incidence_structure_low_level(
	int m, int n, int nb_inc, int *X, 
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int *partition;
	int i;
	action *A;

	if (f_v) {
		cout << "create_automorphism_group_"
				"of_incidence_structure_low_level" << endl;
		}

	partition = NEW_int(m + n);
	for (i = 0; i < m + n; i++) {
		partition[i] = 1;
		}

	partition[m - 1] = 0;

	A = create_automorphism_group_of_incidence_structure_with_partition(
			m, n, nb_inc, X, partition,
			verbose_level);

	FREE_int(partition);
	if (f_v) {
		cout << "create_automorphism_group_"
				"of_incidence_structure_low_level done" << endl;
		}
	return A;
}

action *create_automorphism_group_of_incidence_structure_with_partition(
	int m, int n, int nb_inc, int *X, int *partition,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_v10 = (verbose_level >= 10);
	int *labeling; //, *labeling_inv;
	int *Aut;
	int *Base, *Transversal_length;
	int Aut_counter = 0, Base_length = 0, Ago = 0;
	
	
	//m = # rows
	//n = # cols
	
	Aut = NEW_int((m+n) * (m+n));
	Base = NEW_int(m+n);
	Transversal_length = NEW_int(m + n);

	if (f_v) {
		cout << "create_automorphism_group_of_"
				"incidence_structure_with_partition" << endl;
		}

	labeling = NEW_int(m + n);
	//labeling_inv = NEW_int(m + n);

	nauty_interface_int(m, n, X, nb_inc, 
		labeling, partition,
		Aut, Aut_counter, 
		Base, Base_length, 
		Transversal_length, Ago);

	if (f_v) {
		if (TRUE /*(input_no % 500) == 0*/) {
			cout << "create_automorphism_group_of_"
					"incidence_structure_with_partition: "
					"The group order is = " << Ago << endl;
			}
		}

#if 0
	for (i = 0; i < m + n; i++) {
		j = labeling[i];
		labeling_inv[j] = i;
		}
#endif

	if (f_v10) {
		cout << "create_automorphism_group_of_"
				"incidence_structure_with_partition: "
				"labeling:" << endl;
		int_vec_print(cout, labeling, m + n);
		cout << endl;
		//cout << "labeling_inv:" << endl;
		//int_vec_print(cout, labeling_inv, m + n);
		//cout << endl;

		cout << "create_automorphism_group_of_"
				"incidence_structure_with_partition: "
				"Base:" << endl;
		int_vec_print(cout, Base, Base_length);
		cout << endl;

		cout << "create_automorphism_group_of_"
				"incidence_structure_with_partition: "
				"generators:" << endl;
		print_integer_matrix_width(cout,
				Aut, Aut_counter, m + n, m + n, 2);
		}



	action *A;
	longinteger_object ago;


	A = NEW_OBJECT(action);

	ago.create(Ago);
	A->init_permutation_group_from_generators(m + n, 
		TRUE, ago, 
		Aut_counter, Aut, 
		Base_length, Base,
		verbose_level - 2);

	if (f_v) {
		cout << "create_automorphism_group_of_"
				"incidence_structure_with_partition: "
				"created action ";
		A->print_info();
		cout << endl;
		}

	FREE_int(Aut);
	FREE_int(Base);
	FREE_int(Transversal_length);
	FREE_int(labeling);

	return A;
}

void test_self_dual_self_polar(int input_no,
	int m, int n, int nb_inc, int *X,
	int &f_self_dual, int &f_self_polar,
	int verbose_level)
{
	int M, N, i, j, h, Nb_inc, a;
	int *Mtx, *Y;
	
	if (m != n) {
		f_self_dual = FALSE;
		f_self_polar = FALSE;
		return;
		}
	M = 2 * m;
	N = 2 + nb_inc;
	Mtx = NEW_int(M * N);
	Y = NEW_int(M * N);
	for (i = 0; i < M * N; i++) {
		Mtx[i] = 0;
		}
	for (i = 0; i < m; i++) {
		Mtx[i * N + 0] = 1;
		}
	for (i = 0; i < m; i++) {
		Mtx[(m + i) * N + 1] = 1;
		}
	for (h = 0; h < nb_inc; h++) {
		a = X[h];
		i = a / n;
		j = a % n;
		Mtx[i * N + 2 + h] = 1;
		Mtx[(m + j) * N + 2 + h] = 1;
		}
	Nb_inc = 0;
	for (i = 0; i < M * N; i++) {
		if (Mtx[i]) {
			Y[Nb_inc++] = i;
			}
		}
	
	do_self_dual_self_polar(input_no,
			M, N, Nb_inc, Y, f_self_dual, f_self_polar,
			verbose_level - 1);

	FREE_int(Mtx);
	FREE_int(Y);
}


void do_self_dual_self_polar(int input_no,
	int m, int n, int nb_inc, int *X,
	int &f_self_dual, int &f_self_polar,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int *labeling; //, *labeling_inv;
	int *Aut;
	int *Base, *Transversal_length, *partitions;
	int Aut_counter = 0, Base_length = 0, Ago = 0;
	int i; //, j;
	
	//m = # rows
	//n = # cols
	
	if (ODD(m)) {
		f_self_dual = f_self_polar = FALSE;
		return;
		}
	Aut = NEW_int((m+n) * (m+n));
	Base = NEW_int(m+n);
	Transversal_length = NEW_int(m + n);
	partitions = NEW_int(m + n);

	if (f_v) {
		if ((input_no % 500) == 0) {
			cout << "do_self_dual_self_polar input_no=" << input_no << endl;
			}
		}
	for (i = 0; i < m + n; i++) {
		partitions[i] = 1;
		}

#if 0
	for (i = 0; i < PB.P.ht; i++) {
		j = PB.P.startCell[i] + PB.P.cellSize[i] - 1;
		partitions[j] = 0;
		}
#endif

#if 0
	j = 0;
	for (i = 0; i < nb_row_parts; i++) {
		l = row_parts[i];
		partitions[j + l - 1] = 0;
		j +=l;
		}
	for (i = 0; i < nb_col_parts; i++) {
		l = col_parts[i];
		partitions[j + l - 1] = 0;
		j +=l;
		}				
#endif

	labeling = NEW_int(m + n);
	//labeling_inv = NEW_int(m + n);

	nauty_interface_int(m, n, X, nb_inc,
			labeling, partitions, Aut, Aut_counter,
			Base, Base_length, Transversal_length, Ago);

	if (f_vv) {
		if ((input_no % 500) == 0) {
			cout << "The group order is = " << Ago << endl;
			}
		}
	
#if 0
	for (i = 0; i < m + n; i++) {
		j = labeling[i];
		labeling_inv[j] = i;
		}
#endif

	int *aut;
	int *p_aut;
	int h, a, b, c, m_half;

	m_half = m >> 1;
	aut = NEW_int(Aut_counter * m);
	for (h = 0; h < Aut_counter; h++) {
		for (i = 0; i < m; i++) {
			aut[h * m + i] = Aut[h * (m + n) + i];
			}
		}
	f_self_dual = FALSE;
	f_self_polar = FALSE;
	for (h = 0; h < Aut_counter; h++) {
		p_aut = aut + h * m;

		a = p_aut[0];
		if (a >= m_half ) {
			f_self_dual = TRUE;
			if (f_v) {
				cout << "no " << input_no << " is self dual" << endl;
				}
			break;
			}
		}

#if 0

	int *AUT;
	int *BASE;

	AUT = NEW_int(Aut_counter * (m + n));
	BASE = NEW_int(Base_length);
	for (h = 0; h < Aut_counter; h++) {
		for (i = 0; i < m + n; i++) {
			j = labeling_inv[i];
			j = Aut[h * (m + n) + j];
			j = labeling[j];
			AUT[h * (m + 1) + i] = j;
			}
		}
	for (i = 0; i < Base_length; i++) {
		j = Base[i];
		j = labeling[j];
		BASE[i] = j;
		}
#endif

	action A;
	longinteger_object ago;



	ago.create(Ago);
	A.init_permutation_group_from_generators(m + n, 
		TRUE, ago, 
		Aut_counter, Aut, 
		Base_length, Base,
		verbose_level);

	cout << "created action ";
	A.print_info();
	cout << endl;


	if (f_self_dual) {


		sims *S;
		longinteger_object go;
		int goi;
		int *Elt;
	
		S = A.Sims;
		S->group_order(go);
		goi = go.as_int();
		Elt = NEW_int(A.elt_size_in_int);
		
		cout << "the group order is: " << goi << endl;
		for (i = 0; i < goi; i++) {
			S->element_unrank_int(i, Elt);
			if (Elt[0] < m_half) {
				continue; // not a duality
				}
			
			for (a = 0; a < m_half; a++) {
				b = Elt[a];
				c = Elt[b];
				if (c != a)
					break;
				}
			if (a == m_half) {
				cout << "found a polarity:" << endl;
				A.element_print(Elt, cout);
				cout << endl;
				f_self_polar = TRUE;
				break;
				}
			}
		

		FREE_int(Elt);
		}



		
	FREE_int(aut);
	FREE_int(Aut);
	FREE_int(Base);
	FREE_int(Transversal_length);
	FREE_int(partitions);
	FREE_int(labeling);
	//FREE_int(labeling_inv);
	//FREE_int(AUT);
	//FREE_int(BASE);
}

void add_configuration_graph(ofstream &g,
		int m, int n, int nb_inc, int *X, int f_first,
		int verbose_level)
{
	incidence_structure Inc;
	int *joining_table;
	int *M1;
	int i, j, h, nb_joined_pairs, nb_missing_pairs;
	int n1, nb_inc1;
	action *A;
	longinteger_object ago;

	A = create_automorphism_group_of_incidence_structure_low_level(
			m, n, nb_inc, X, 
			verbose_level - 2);
	A->group_order(ago);

	Inc.init_by_incidences(m, n, nb_inc, X, verbose_level);
	joining_table = NEW_int(m * m);
	for (i = 0; i < m * m; i++) {
		joining_table[i] = FALSE;
		}
	nb_joined_pairs = 0;
	for (i = 0; i < m; i++) {
		for (j = i + 1; j < m; j++) {
			for (h = 0; h < n; h++) {
				if (Inc.get_ij(i, h) && Inc.get_ij(j, h)) {
					joining_table[i * m + j] = TRUE;
					joining_table[j * m + i] = TRUE;
					nb_joined_pairs++;
					}
				}
			}
		}
	nb_missing_pairs = int_n_choose_k(m, 2) - nb_joined_pairs;
	n1 = n + nb_missing_pairs;
	M1 = NEW_int(m * n1);
	for (i = 0; i < m * n1; i++) {
		M1[i] = 0;
		}
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			M1[i * n1 + j] = Inc.get_ij(i, j);
			}
		}
	h = 0;
	for (i = 0; i < m; i++) {
		for (j = i + 1; j < m; j++) {
			if (joining_table[i * m + j] == FALSE) {
				M1[i * n1 + n + h] = 1;
				M1[j * n1 + n + h] = 1;
				h++;
				}
			}
		}
	if (f_first) {
		nb_inc1 = 0;
		for (i = 0; i < m; i++) {
			for (j = 0; j < n1; j++) {
				if (M1[i * n1 + j]) {
					nb_inc1++;
					}
				}
			}
		g << m << " " << n1 << " " << nb_inc1 << endl;
		}
	for (i = 0; i < m; i++) {
		for (j = 0; j < n1; j++) {
			if (M1[i * n1 + j]) {
				g << i * n1 + j << " ";
				}
			}
		}
	g << ago << endl;
	
	FREE_int(joining_table);
	FREE_int(M1);
	FREE_OBJECT(A);
}

// O4_model:

void O4_isomorphism_2to4_embedded(action *A4, action *A5, finite_field *Fq, 
	int f_switch, int *mtx2x2_T, int *mtx2x2_S, int *Elt,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int mtx4x4[16];
	int mtx5x5[25];
	int *E1;
	
	if (f_v) {
		cout << "O4_isomorphism_2to4_embedded" << endl;
		}
	E1 = NEW_int(A4->elt_size_in_int);
	if (f_v) {
		cout << "input in 2x2, 2x2:" << endl;
		cout << "f_switch=" << f_switch << endl;
		print_integer_matrix_width(cout, mtx2x2_T, 2, 2, 2, 3);
		cout << "," << endl;
		print_integer_matrix_width(cout, mtx2x2_S, 2, 2, 2, 3);
		}
	
	O4_isomorphism_2to4(Fq, mtx2x2_T, mtx2x2_S, f_switch, mtx4x4);
	
	A4->make_element(E1, mtx4x4, 0);
	if (f_v) {
		cout << "in 4x4:" << endl;
		A4->element_print_quick(E1, cout);
		}
	
	O4_to_O5(A4, A5, Fq, E1, mtx5x5, verbose_level - 2);
	if (f_v) {
		cout << "in 5x5:" << endl;
		print_integer_matrix_width(cout, mtx5x5, 5, 5, 5, 3);
		}
	A5->make_element(Elt, mtx5x5, 0);
	if (f_v) {
		cout << "as group element:" << endl;
		A5->element_print_quick(Elt, cout);
		}
	FREE_int(E1);
}

void O5_to_O4(action *A4, action *A5, finite_field *Fq, 
	int *mtx4x4, int *mtx5x5, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int Data[25];
	int h, u, v;

	for (h = 0; h < 25; h++) {
		Data[h] = mtx5x5[h];
		}
	Fq->PG_element_normalize_from_front(Data, 1, 25);
	if (f_v) {
		cout << "as 5 x 5:" << endl;
		print_integer_matrix_width(cout, Data, 5, 5, 5, 3);
		}

	for (u = 0; u < 4; u++) {
		for (v = 0; v < 4; v++) {
			mtx4x4[u * 4 + v] = Data[(u + 1) * 5 + v + 1];
			}
		}
	if (f_v) {
		cout << "as 4 x 4:" << endl;
		print_integer_matrix_width(cout, mtx4x4, 4, 4, 4, 3);
		}
}

void O4_to_O5(action *A4, action *A5, finite_field *Fq, 
	int *mtx4x4, int *mtx5x5, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int ord;
	int i, j;
	int value;
	int sqrt_value;
	int discrete_log;
	int *A4_Elt1;
	int *A5_Elt1;
	int gram[16];	
	int mtx_tr[16];
	int mtx_tmp1[16];
	int mtx_tmp2[16];
	int mtx5[25];
	
	A4_Elt1 = NEW_int(A4->elt_size_in_int);
	A5_Elt1 = NEW_int(A5->elt_size_in_int);
	
	A4->make_element(A4_Elt1, mtx4x4, 0);
	if (f_v) {
		cout << "A4_Elt1:" << endl;
		A4->element_print_quick(A4_Elt1, cout);
		}
	ord = A4->element_order(A4_Elt1);
	if (f_v) {
		cout << "A4_Elt1 has order " << ord << endl;
		}


	for (i = 0; i < 16; i++) {
		gram[i] = 0;
		}
	gram[0 * 4 + 1] = 1;
	gram[1 * 4 + 0] = 1;
	gram[2 * 4 + 3] = 1;
	gram[3 * 4 + 2] = 1;
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			mtx_tr[i * 4 + j] = mtx4x4[j * 4 + i];
			}
		}
	if (f_v) {
		cout << "Gram matrix:" << endl;
		print_integer_matrix_width(cout, gram, 4, 4, 4, 3);
		cout << "mtx4x4:" << endl;
		print_integer_matrix_width(cout, mtx4x4, 4, 4, 4, 3);
		cout << "mtx_tr:" << endl;
		print_integer_matrix_width(cout, mtx_tr, 4, 4, 4, 3);
		}
	Fq->mult_matrix_matrix(mtx4x4, gram, mtx_tmp1, 4, 4, 4,
			0 /* verbose_level */);
	Fq->mult_matrix_matrix(mtx_tmp1, mtx_tr, mtx_tmp2, 4, 4, 4,
			0 /* verbose_level */);
	if (f_v) {
		cout << "transformed Gram matrix:" << endl;
		print_integer_matrix_width(cout, mtx_tmp2, 4, 4, 4, 3);
		}
	
	value = 0;
	for (i = 0; i < 16; i++) {
		if (!mtx_tmp2[i]) {
			continue;
			}
		if (value == 0) {
			value = mtx_tmp2[i];
			continue;
			}
		if (value != mtx_tmp2[i]) {
			cout << "the transformed gram matrix has several values" << endl;
			exit(1);
			}
		value = mtx_tmp2[i];
		}

	if (f_v) {
		cout << "value=" << value << endl;
		}
	discrete_log = Fq->log_alpha(value);

	if (f_v) {
		cout << "discrete_log=" << discrete_log << endl;
		}
	if (ODD(discrete_log)) {
		cout << "value is not a square" << endl;
		exit(1);
		}
	sqrt_value = Fq->alpha_power(discrete_log >> 1);
	
	
	for (i = 0 ; i < 25; i++) {
		mtx5[i] = 0;
		}
	mtx5[0] = sqrt_value;
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			mtx5[(i + 1) * 5 + j + 1] = mtx4x4[i * 4 + j];
			}
		}

	
	A5->make_element(A5_Elt1, mtx5, 0);
	if (f_v) {
		cout << "A5_Elt1:" << endl;
		A5->element_print_quick(A5_Elt1, cout);
		}
	ord = A5->element_order_verbose(A5_Elt1, 0);
	if (f_v) {
		cout << "A5_Elt1 has order " << ord << endl;
		}
	for (i = 0; i < 25; i++) {
		mtx5x5[i] = A5_Elt1[i];
		}

	FREE_int(A4_Elt1);
	FREE_int(A5_Elt1);
}

void print_4x4_as_2x2(action *A2, finite_field *Fq, int *mtx4x4)
{
	int small[8], f_switch, r, order;
	int *elt1;
		
	elt1 = NEW_int(A2->elt_size_in_int);	
	O4_isomorphism_4to2(Fq, small, small + 4,
			f_switch, mtx4x4, 0/*verbose_level*/);
	cout << "after isomorphism:" << endl;
	cout << "f_switch=" << f_switch << endl;
	for (r = 0; r < 2; r++) {
		cout << "component " << r << ":" << endl;
		Fq->PG_element_normalize_from_front(small + r * 4, 1, 4);
		print_integer_matrix_width(cout, small + r * 4, 2, 2, 2, 3);
		A2->make_element(elt1, small + r * 4, 0);
		order = A2->element_order(elt1);
		cout << "has order " << order << endl;
		A2->element_print_as_permutation(elt1, cout);
		cout << endl;
		A2->element_print_quick(elt1, cout);
		cout << endl;
		
		}
	FREE_int(elt1);
}

int reverse_engineer_semilinear_map(action *A,
	projective_space *P,
	int *Elt, int *Mtx, int &frobenius, 
	int verbose_level)
// uses the function A->element_image_of
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	finite_field *F;
	int d = P->n + 1;
	int *v1, *v2, *v1_save;
	int *w1, *w2, *w1_save;
	int /*q,*/ h, hh, i, j, l, e, frobenius_inv, lambda, rk, c, cv;
	int *system;
	int *base_cols;
	

	if (f_v) {
		cout << "reverse_engineer_semilinear_map" << endl;
		cout << "verbose_level=" << verbose_level << endl;
		cout << "d=" << d << endl;
		}
	F = P->F;
	//q = F->q;
	
	v1 = NEW_int(d);
	v2 = NEW_int(d);
	v1_save = NEW_int(d);
	w1 = NEW_int(d);
	w2 = NEW_int(d);
	w1_save = NEW_int(d);
	


	if (f_v) {
		cout << "reverse_engineer_semilinear_map "
				"maping unit vectors" << endl;
		}
	for (e = 0; e < d; e++) {
		// map the unit vector e_e
		// (with a one in position e and zeros elsewhere):
		for (h = 0; h < d; h++) {
			if (h == e) {
				v1[h] = 1;
				}
			else {
				v1[h] = 0;
				}				
			}
		int_vec_copy(v1, v1_save, d);
		i = P->rank_point(v1);
			// Now, the value of i should be equal to e.
		j = A->element_image_of(i, Elt, 0);
		P->unrank_point(v2, j);
		if (f_vv) {
			print_from_to(d, i, j, v1_save, v2);
			}


		int_vec_copy(v2, Mtx + e * d, d);
		}

	if (f_vv) {
		cout << "Mtx (before scaling):" << endl;
		print_integer_matrix_width(cout, Mtx, d, d, d, F->log10_of_q);
		cout << endl;
		}

	// map the vector (1,1,...,1):
	if (f_v) {
		cout << "reverse_engineer_semilinear_map "
				"mapping the all-one vector"
				<< endl;
		}
	for (h = 0; h < d; h++) {
		v1[h] = 1;
		}
	int_vec_copy(v1, v1_save, d);
	i = P->rank_point(v1);
	j = A->element_image_of(i, Elt, 0);
	P->unrank_point(v2, j);
	if (f_vv) {
		print_from_to(d, i, j, v1_save, v2);
		}

	system = NEW_int(d * (d + 1));
	base_cols = NEW_int(d + 1);
	// coefficient matrix:
	for (i = 0; i < d; i++) {
		for (j = 0; j < d; j++) {
			system[i * (d + 1) + j] = Mtx[j * d + i];
			}
		}
	// RHS:
	for (i = 0; i < d; i++) {
		system[i * (d + 1) + d] = v2[i];
		}
	rk = F->Gauss_simple(system, d, d + 1, base_cols, verbose_level - 4);
	if (rk != d) {
		cout << "rk != d, fatal" << endl;
		exit(1);
		}
	if (f_vv) {
		cout << "after Gauss_simple:" << endl;
		print_integer_matrix_width(cout, system,
				d, d + 1, d + 1, F->log10_of_q);
		cout << endl;
		}
	for (i = 0; i < d; i++) {
		c = system[i * (d + 1) + d];
		for (j = 0; j < d; j++) {
			Mtx[i * d + j] = F->mult(c, Mtx[i * d + j]);
			}
		}

	if (f_vv) {
		cout << "Mtx (after scaling):" << endl;
		print_integer_matrix_width(cout, Mtx, d, d, d, F->log10_of_q);
		cout << endl;
		}


	// figure out the frobenius:
	if (f_v) {
		cout << "reverse_engineer_semilinear_map "
				"figuring out the frobenius" << endl;
		}

	frobenius = 0;
	if (F->q != F->p) {

		// create the vector (1,p,0,...,0)

		for (h = 0; h < d; h++) {
			if (h == 0) {
				v1[h] = 1;
				}
			else if (h == 1) {
				v1[h] = F->p;
				}
			else {
				v1[h] = 0;
				}				
			}
		int_vec_copy(v1, v1_save, d);
		i = P->rank_point(v1);
		j = A->element_image_of(i, Elt, 0);
		P->unrank_point(v2, j);


		if (f_vv) {
			print_from_to(d, i, j, v1_save, v2);
			}


		// coefficient matrix:
		for (i = 0; i < d; i++) {
			for (j = 0; j < 2; j++) {
				system[i * 3 + j] = Mtx[j * d + i];
				}
			}
		// RHS:
		for (i = 0; i < d; i++) {
			system[i * 3 + 2] = v2[i];
			}
		rk = F->Gauss_simple(system,
				d, 3, base_cols, verbose_level - 4);
		if (rk != 2) {
			cout << "rk != 2, fatal" << endl;
			exit(1);
			}
		if (f_vv) {
			cout << "after Gauss_simple:" << endl;
			print_integer_matrix_width(cout,
					system, 2, 3, 3, F->log10_of_q);
			cout << endl;
			}

		c = system[0 * 3 + 2];
		if (c != 1) {
			cv = F->inverse(c);
			for (hh = 0; hh < 2; hh++) {
				system[hh * 3 + 2] = F->mult(cv, system[hh * 3 + 2]);
				}
			}
		if (f_vv) {
			cout << "after scaling the last column:" << endl;
			print_integer_matrix_width(cout,
					system, 2, 3, 3, F->log10_of_q);
			cout << endl;
			}
		lambda = system[1 * 3 + 2];
		if (f_vv) {
			cout << "lambda=" << lambda << endl;
			}
			

		l = F->log_alpha(lambda);
		if (f_vv) {
			cout << "l=" << l << endl;
			}
		for (i = 0; i < F->e; i++) {
			if (i_power_j(F->p, i) == l) {
				frobenius = i;
				break;
				}
			}
		if (i == F->e) {
			cout << "reverse_engineer_semilinear_map "
					"problem figuring out the Frobenius" << endl;
			exit(1);
			}

		}
	else {
		frobenius = 0;
		}

	frobenius_inv = (F->e - frobenius) % F->e;
	if (f_vv) {
		cout << "frobenius = " << frobenius << endl;
		cout << "frobenius_inv = " << frobenius_inv << endl;
		}


	for (hh = 0; hh < d * d; hh++) {
		Mtx[hh] = F->frobenius_power(Mtx[hh], frobenius_inv);
		}
	if (f_v) {
		cout << "reverse_engineer_semilinear_map "
				"done, we found the following map" << endl;
		cout << "Mtx:" << endl;
		print_integer_matrix_width(cout,
				Mtx, d, d, d, F->log10_of_q);
		cout << endl;
		cout << "frobenius = " << frobenius << endl;
		}



	FREE_int(v1);
	FREE_int(v2);
	FREE_int(v1_save);
	FREE_int(w1);
	FREE_int(w2);
	FREE_int(w1_save);
	FREE_int(system);
	FREE_int(base_cols);


	return TRUE;
}

static void print_from_to(int d, int i, int j, int *v1, int *v2)
{
	cout << i << "=";
	int_vec_print(cout, v1, d);
	cout << " -> " << j << " = ";
	int_vec_print(cout, v2, d);
	cout << endl;
}




sims *set_stabilizer_in_projective_space(
	action *A_linear, projective_space *P, 
	int *set, int set_size, int &canonical_pt, 
	int *canonical_set_or_NULL, 
	int f_save_incma_in_and_out, const char *save_incma_in_and_out_prefix, 
	int verbose_level)
// added 2/28/2011, called from analyze.C
// November 17, 2014 moved here from TOP_LEVEL/extra.C
// December 31, 2014, moved here from projective_space.C
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int f_vvv = (verbose_level >= 3);
	int *Incma;
	int *partition;
	int *labeling;
	int nb_rows, nb_cols;
	int *Aut, Aut_counter;
	int *Base, Base_length;
	int *Transversal_length, Ago;
	int N, i, j, h;

	if (f_v) {
		cout << "set_stabilizer_in_projective_space" << endl;
		cout << "verbose_level = " << verbose_level << endl;
		cout << "set_size = " << set_size << endl;
		}
	if (P->incidence_bitvec == NULL) {
		cout << "set_stabilizer_in_projective_space "
				"P->incidence_bitvec == NULL" << endl;
		exit(1);
		}

	if (f_vv) {
		cout << "computing the type of the set" << endl;
		}

	classify C;

	C.init(set, set_size, TRUE, 0);
	if (C.second_nb_types > 1) {
		cout << "set_stabilizer_in_projective_space: "
				"The set is a multiset:" << endl;
		C.print(FALSE /*f_backwards*/);
		}

	if (f_vv) {
		cout << "The type of the set is:" << endl;
		C.print(FALSE /*f_backwards*/);
		cout << "C.second_nb_types = " << C.second_nb_types << endl;
		}
	if (f_vv) {
		cout << "allocating data" << endl;
		}
	nb_rows = P->N_points + 1;
	nb_cols = P->N_lines + C.second_nb_types;
	Incma = NEW_int(nb_rows * nb_cols);
	partition = NEW_int(nb_rows + nb_cols);
	labeling = NEW_int(nb_rows + nb_cols);

	if (f_vv) {
		cout << "Initializing Incma" << endl;
		}

	for (i = 0; i < P->N_points; i++) {
		for (j = 0; j < P->N_lines; j++) {
			Incma[i * nb_cols + j] = P->is_incident(i, j);
			}
		}
	// last columns, make zero:
	for (j = 0; j < C.second_nb_types; j++) {
		for (i = 0; i < P->N_points; i++) {
			Incma[i * nb_cols + P->N_lines + j] = 0;
			}
		}
	
	// last row, make zero:
	for (j = 0; j < nb_cols; j++) {
		Incma[P->N_points * nb_cols + j] = 0;
		}

	// last columns:
	for (j = 0; j < C.second_nb_types; j++) {
		int f2, l2, m, idx, f, l;

		f2 = C.second_type_first[j];
		l2 = C.second_type_len[j];
		m = C.second_data_sorted[f2 + 0];
		if (f_vvv) {
			cout << "j=" << j << " f2=" << f2 << " l2=" << l2
					<< " multiplicity=" << m << endl;
			}
		for (h = 0; h < l2; h++) {
			idx = C.second_sorting_perm_inv[f2 + h];
			f = C.type_first[idx];
			l = C.type_len[idx];
			i = C.data_sorted[f + 0];
			if (f_vvv) {
				cout << "h=" << h << " idx=" << idx << " f=" << f
						<< " l=" << l << " i=" << i << endl;
				}
			Incma[i * nb_cols + P->N_lines + j] = 1;
			}	
#if 0
		for (h = 0; h < set_size; h++) {
			i = set[h];
			Incma[i * nb_cols + N_lines + j] = 1;
			}
#endif
		}
	// bottom right entries:
	for (j = 0; j < C.second_nb_types; j++) {
		Incma[P->N_points * nb_cols + P->N_lines + j] = 1;
		}

	if (f_vvv) {
		cout << "set_stabilizer_in_projective_space Incma:" << endl;
		int_matrix_print(Incma, nb_rows, nb_cols);
	}

	if (f_save_incma_in_and_out) {
		if (f_vv) {
			cout << "Incma in:" << endl;
			if (nb_rows < 10) {
				print_integer_matrix_width(cout,
						Incma, nb_rows, nb_cols, nb_cols, 1);
				}
			else {
				cout << "too large to print" << endl;
				}
			}
		char fname_csv[1000];
		char fname_bin[1000];

		sprintf(fname_csv, "%sIncma_in_%d_%d.csv",
				save_incma_in_and_out_prefix, nb_rows, nb_cols);
		sprintf(fname_bin, "%sIncma_in_%d_%d.bin",
				save_incma_in_and_out_prefix, nb_rows, nb_cols);
		int_matrix_write_csv(fname_csv, Incma, nb_rows, nb_cols);

		for (i = 0; i < nb_rows + nb_cols; i++) {
			labeling[i] = i;
			}

		colored_graph *CG;
		create_Levi_graph_from_incidence_matrix(CG,
				Incma, nb_rows, nb_cols, TRUE, labeling, verbose_level);
		CG->save(fname_bin, verbose_level);
		//FREE_int(Incma);
		FREE_OBJECT(CG);
		}

	if (f_vv) {
		cout << "initializing partition" << endl;
		}
	N = nb_rows + nb_cols;
	for (i = 0; i < N; i++) {
		partition[i] = 1;
		}
	partition[P->N_points - 1] = 0;
	partition[P->N_points] = 0;
	partition[nb_rows + P->N_lines - 1] = 0;
	for (j = 0; j < C.second_nb_types; j++) {
		partition[nb_rows + P->N_lines + j] = 0;
		}
	if (f_vvv) {
		cout << "partition:" << endl;
		for (i = 0; i < N; i++) {
			//cout << i << " : " << partition[i] << endl;
			cout << partition[i];
			}
		cout << endl;
		}

	if (f_vv) {
		cout << "initializing Aut, Base, Transversal_length" << endl;
		}
	Aut = NEW_int(N * N);
	Base = NEW_int(N);
	Transversal_length = NEW_int(N);
	
	if (f_v) {
		cout << "set_stabilizer_in_projective_space, "
				"calling nauty_interface_matrix_int" << endl;
		}
	nauty_interface_matrix_int(Incma, nb_rows, nb_cols, 
		labeling, partition, 
		Aut, Aut_counter, 
		Base, Base_length, 
		Transversal_length, Ago, verbose_level - 3);
	if (f_v) {
		cout << "set_stabilizer_in_projective_space, "
				"done with nauty_interface_matrix_int, Ago=" << Ago << endl;
		}

	int *Incma_out;
	int ii, jj;
	if (f_vvv) {
		cout << "labeling:" << endl;
		int_vec_print(cout, labeling, nb_rows + nb_cols);
		cout << endl;
		}

	Incma_out = NEW_int(nb_rows * nb_cols);
	for (i = 0; i < nb_rows; i++) {
		ii = labeling[i];
		for (j = 0; j < nb_cols; j++) {
			jj = labeling[nb_rows + j] - nb_rows;
			//cout << "i=" << i << " j=" << j
			//<< " ii=" << ii << " jj=" << jj << endl;
			Incma_out[i * nb_cols + j] = Incma[ii * nb_cols + jj];
			}
		}


	if (f_vvv) {
		cout << "set_stabilizer_in_projective_space Incma_out:" << endl;
		int_matrix_print(Incma_out, nb_rows, nb_cols);
	}

	if (f_save_incma_in_and_out) {
		if (f_vv) {
			cout << "Incma Out:" << endl;
			if (nb_rows < 20) {
				print_integer_matrix_width(cout,
						Incma_out, nb_rows, nb_cols, nb_cols, 1);
				}
			else {
				cout << "too large to print" << endl;
				}
			}
		char fname_csv[1000];
		char fname_bin[1000];

		sprintf(fname_csv, "%sIncma_out_%d_%d.csv",
				save_incma_in_and_out_prefix, nb_rows, nb_cols);
		sprintf(fname_bin, "%sIncma_out_%d_%d.bin",
				save_incma_in_and_out_prefix, nb_rows, nb_cols);
		int_matrix_write_csv(fname_csv, Incma_out, nb_rows, nb_cols);

		
		colored_graph *CG;
		create_Levi_graph_from_incidence_matrix(CG,
				Incma_out, nb_rows, nb_cols, TRUE, labeling,
				verbose_level);
		CG->save(fname_bin, verbose_level);
		FREE_OBJECT(CG);
		}

	canonical_pt = -1;
	if (set_size) {
		if (C.second_nb_types == 1) {
			for (i = 0; i < P->N_points; i++) {
				if (Incma[i * nb_cols + P->N_lines + 0] == 1) {
					ii = labeling[i];
					canonical_pt = ii;
					break;
				}
			}
		}
		else {
			// cannot compute the canonical point
		}
		if (canonical_set_or_NULL) {
			h = 0;
			for (i = 0; i < P->N_points; i++) {
				if (Incma_out[i * nb_cols + P->N_lines + 0] == 1) {
					canonical_set_or_NULL[h++] = labeling[i];
				}
			}
			if (h != set_size) {
				cout << "set_stabilizer_in_projective_space h != set_size" << endl;
				cout << "h=" << h << endl;
				cout << "set_size=" << set_size << endl;
				exit(1);
			}
		}
	}


	FREE_int(Incma_out);

	action *A_perm;
	longinteger_object ago;


	A_perm = NEW_OBJECT(action);

	if (f_v) {
		cout << "set_stabilizer_in_projective_space "
				"before init_permutation_group_from_generators" << endl;
		}
	ago.create(Ago);
	A_perm->init_permutation_group_from_generators(N, 
		TRUE, ago, 
		Aut_counter, Aut, 
		Base_length, Base,
		0 /*verbose_level - 2 */);

	if (f_vv) {
		cout << "set_stabilizer_in_projective_space: "
				"create_automorphism_group_of_incidence_structure: "
				"created action ";
		A_perm->print_info();
		cout << endl;
		}

	//action *A_linear;

	//A_linear = A;

	if (A_linear == NULL) {
		cout << "set_stabilizer_in_projective_space: "
				"A_linear == NULL" << endl;
		exit(1);
		}

	vector_ge *gens; // permutations from nauty
	vector_ge *gens1; // matrices
	int d, g, frobenius, pos;
	int *Mtx;
	int *Elt1;

	Elt1 = NEW_int(A_linear->elt_size_in_int);

	d = P->n + 1;
	
	gens = A_perm->Strong_gens->gens;
	//gens = A->strong_generators;

	gens1 = NEW_OBJECT(vector_ge);
	gens1->init(A_linear);
	gens1->allocate(gens->len);
	
	Mtx = NEW_int(d * d + 1); // leave space for frobenius
	
	pos = 0;
	for (g = 0; g < gens->len; g++) {
		if (f_vv) {
			cout << "set_stabilizer_in_projective_space: "
					"strong generator " << g << ":" << endl;
			A_perm->element_print(gens->ith(g), cout);
			cout << endl;
			}
		
		if (reverse_engineer_semilinear_map(A_perm, P, 
			gens->ith(g), Mtx, frobenius, 
			0 /*verbose_level - 2*/)) {

			Mtx[d * d] = frobenius;
			A_linear->make_element(Elt1, Mtx, 0 /*verbose_level - 2*/);
			if (f_vv) {
				cout << "semi-linear group element:" << endl;
				A_linear->element_print(Elt1, cout);
				}
			A_linear->element_move(Elt1, gens1->ith(pos), 0);
		

			pos++;
			}
		else {
			if (f_vv) {
				cout << "set_stabilizer_in_projective_space: "
						"generator " << g
						<< " does not correspond to a semilinear mapping"
						<< endl;
				}
			}
		}
	gens1->reallocate(pos);
	if (f_vv) {
		cout << "we found " << gens1->len << " generators" << endl;
		}

	if (f_vvv) {
		gens1->print(cout);
		}
	

	if (f_vv) {
		cout << "set_stabilizer_in_projective_space: "
				"we are now testing the generators:" << endl;
		}
	int j1, j2;
	
	for (g = 0; g < gens1->len; g++) {
		if (f_vv) {
			cout << "generator " << g << ":" << endl;
			}
		//A_linear->element_print(gens1->ith(g), cout);
		for (i = 0; i < P->N_points; i++) {
			j1 = A_linear->element_image_of(i, gens1->ith(g), 0);
			j2 = A_perm->element_image_of(i, gens->ith(g), 0);
			if (j1 != j2) {
				cout << "set_stabilizer_in_projective_space "
						"problem with generator: j1 != j2" << endl;
				cout << "i=" << i << endl;
				cout << "j1=" << j1 << endl;
				cout << "j2=" << j2 << endl;
				cout << endl;
				exit(1);
				}
			}
		}
	if (f_vv) {
		cout << "set_stabilizer_in_projective_space: "
				"the generators are OK" << endl;
		}



	sims *S;
	longinteger_object go;

	if (f_vv) {
		cout << "set_stabilizer_in_projective_space: "
				"we are now creating the group" << endl;
		}

	S = create_sims_from_generators_with_target_group_order(A_linear, 
		gens1, ago, 0 /*verbose_level*/);
#if 0
	S = create_sims_from_generators_without_target_group_order(A_linear, 
		gens1, 0 /*verbose_level - 4*/);
#endif
	
	S->group_order(go);

	
	if (f_vv) {
		cout << "set_stabilizer_in_projective_space: "
				"Found a group of order " << go << endl;
		}
	if (f_vvv) {
		cout << "set_stabilizer_in_projective_space: "
				"strong generators are:" << endl;
		S->print_generators();
		cout << "set_stabilizer_in_projective_space: "
				"strong generators are (in tex):" << endl;
		S->print_generators_tex(cout);
		}


	longinteger_domain D;
	
	if (D.compare_unsigned(ago, go)) {
		cout << "set_stabilizer_in_projective_space: "
				"the group order does not match" << endl;
		cout << "ago = " << ago << endl;
		cout << "go = " << go << endl;
		exit(1);
		}

	FREE_int(Aut);
	FREE_int(Base);
	FREE_int(Transversal_length);
	FREE_int(Incma);
	FREE_int(partition);
	FREE_int(labeling);
	FREE_OBJECT(A_perm);
	FREE_OBJECT(gens1);
	FREE_int(Mtx);
	FREE_int(Elt1);

	if (f_v) {
		cout << "set_stabilizer_in_projective_space done" << endl;
		}
	return S;
}


void projective_space_init_line_action(projective_space *P,
		action *A_points, action *&A_on_lines, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	action_on_grassmannian *AoL;

	if (f_v) {
		cout << "projective_space_init_line_action" << endl;
		}
	A_on_lines = NEW_OBJECT(action);

	AoL = NEW_OBJECT(action_on_grassmannian);

	AoL->init(*A_points, P->Grass_lines, verbose_level - 5);
	
	
	if (f_v) {
		cout << "projective_space_init_line_action "
				"action on grassmannian established" << endl;
		}

	if (f_v) {
		cout << "projective_space_init_line_action "
				"initializing A_on_lines" << endl;
		}
	int f_induce_action = TRUE;
	sims S;
	longinteger_object go1;

	S.init(A_points);
	S.init_generators(*A_points->Strong_gens->gens,
			0/*verbose_level*/);
	S.compute_base_orbits_known_length(A_points->transversal_length,
			0/*verbose_level - 1*/);
	S.group_order(go1);
	if (f_v) {
		cout << "projective_space_init_line_action "
				"group order " << go1 << endl;
		}
	
	if (f_v) {
		cout << "projective_space_init_line_action "
				"initializing action on grassmannian" << endl;
		}
	A_on_lines->induced_action_on_grassmannian(A_points, AoL, 
		f_induce_action, &S, verbose_level);
	if (f_v) {
		cout << "projective_space_init_line_action "
				"initializing A_on_lines done" << endl;
		A_on_lines->print_info();
		}

	if (f_v) {
		cout << "projective_space_init_line_action "
				"computing strong generators" << endl;
		}
	if (!A_on_lines->f_has_strong_generators) {
		cout << "projective_space_init_line_action "
				"induced action does not have strong generators" << endl;
		}
	if (f_v) {
		cout << "projective_space_init_line_action done" << endl;
		}
}

void color_distribution_matrix(action *A,
	int *Elt, int n, uchar *Adj, int *colors, classify *C,
	int *&Mtx, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int i, j, ci, cj;

	if (f_v) {
		cout << "color_distribution_matrix" << endl;
		}
	
	Mtx = NEW_int(C->nb_types * C->nb_types);
	int_vec_zero(Mtx, C->nb_types * C->nb_types);
	
	for (i = 0; i < n; i++) {
		ci = C->class_of(i);
		j = A->element_image_of(i, Elt,
				0 /* verbose_level */);
		cj = C->class_of(j);
		Mtx[ci * C->nb_types + cj]++;
		}
	
	if (f_v) {
		cout << "color_distribution_matrix done" << endl;
		}
}

void test_color_distribution(action *A,
	vector_ge *gens, int n,
	uchar *Adj, int *colors, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = FALSE; //(verbose_level >= 1);
	int *Elt;
	int *Mtx;
	int l, h;

	if (f_v) {
		cout << "test_color_distribution" << endl;
		}

	classify C;

	C.init(colors, n, FALSE, 0);
	
	l = gens->len;
	for (h = 0; h < l; h++) {
		Elt = gens->ith(h);
		color_distribution_matrix(A, Elt, n, Adj, colors, &C, 
			Mtx, verbose_level - 2);
		if (f_vv) {
			cout << "generator " << h
					<< " has the following color distribution matrix:"
					<< endl;
			int_matrix_print(Mtx, C.nb_types, C.nb_types);
			}
		
		FREE_int(Mtx);
		}

	if (f_v) {
		cout << "test_color_distribution done" << endl;
		}
}

void color_preserving_subgroup(action *A,
	int n, uchar *Adj, int *colors, sims *&Subgroup,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = FALSE; //(verbose_level >= 2);
	sims *S;
	int *Elt;
	int *Subgrp;
	sims *K;
	int sz;
	int h, go;
	longinteger_object Go;
	vector_ge *gens;

	if (f_v) {
		cout << "color_preserving_subgroup" << endl;
		}

	classify C;

	C.init(colors, n, FALSE, 0);
	
	S = A->Sims;
	Elt = NEW_int(A->elt_size_in_int);
	
	go = S->group_order_int();
	Subgrp = NEW_int(go);
	sz = 0;

	for (h = 0; h < go; h++) {
		int *Mtx;
		
		S->element_unrank_int(h, Elt);
		color_distribution_matrix(A, Elt, n, Adj, colors, &C, 
			Mtx, verbose_level - 2);

		if (f_vv) {
			cout << "element " << h << " / " << go
					<< " has the following color distribution matrix:" << endl;
			int_matrix_print(Mtx, C.nb_types, C.nb_types);
			}
		if (is_diagonal_matrix(Mtx, C.nb_types)) {
			Subgrp[sz++] = h;
			}
		FREE_int(Mtx);
		}


	if (f_v) {
		cout << "The subgroup has order " << sz << endl;
		cout << "and consists of the elements: ";
		int_vec_print(cout, Subgrp, sz);
		cout << endl;
		}
	
	gens = NEW_OBJECT(vector_ge);
	gens->init(A);
	gens->allocate(sz);
	for (h = 0; h < sz; h++) {
		S->element_unrank_int(Subgrp[h], gens->ith(h));
		}
	
	Subgroup = NEW_OBJECT(sims);
	K = NEW_OBJECT(sims);
	Go.create(sz);
	Subgroup->init(A);
	K->init(A);
	Subgroup->init_trivial_group(verbose_level);
	K->init_trivial_group(verbose_level);
	Subgroup->build_up_group_from_generators(K, gens, 
		TRUE /* f_target_go */, &Go, 
		FALSE /* f_override_choose_next_base_point */,
		NULL, 
		verbose_level);
	

	FREE_int(Elt);
	FREE_int(Subgrp);
	FREE_OBJECT(gens);
	FREE_OBJECT(K);

	if (f_v) {
		cout << "color_preserving_subgroup done" << endl;
		}
}

int test_automorphism_group_of_graph_bitvec(action *A,
	int n, uchar *Adj, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	strong_generators *SG;
	int *Elt;
	int h, i, j, ii, jj, iii, jjj, k, kk, l, a, b;

	if (f_v) {
		cout << "test_automorphism_group_of_graph_bitvec" << endl;
		}

	SG = A->Strong_gens;
	l = SG->gens->len;
	for (h = 0; h < l; h++) {
		Elt = SG->gens->ith(h);
		for (i = 0; i < n; i++) {
			ii = A->element_image_of(i, Elt, 0 /* verbose_level */);
			for (j = i + 1; j < n; j++) {
				jj = A->element_image_of(j, Elt, 0 /* verbose_level */);
				if (ii < jj) {
					iii = ii;
					jjj = jj;
					}
				else {
					iii = jj;
					jjj = ii;
					}
				k = ij2k(i, j, n);
				kk = ij2k(iii, jjj, n);
				a = bitvector_s_i(Adj, k);
				b = bitvector_s_i(Adj, kk);
				if (a && !b) {
					cout << "automorphism does not preserve adjacency"
							<< endl;
					return FALSE;
					}
				if (!a && b) {
					cout << "automorphism does not preserve adjacency"
							<< endl;
					return FALSE;
					}
				}
			}
		}
	if (f_v) {
		cout << "test_automorphism_group_of_graph_bitvec done" << endl;
		}
	return TRUE;
}

void compute_conjugacy_classes(sims *S,
	action *&Aconj, action_by_conjugation *&ABC, schreier *&Sch,
	strong_generators *&SG, int &nb_classes,
	int *&class_size, int *&class_rep,
	int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int i, f;

	if (f_v) {
		cout << "compute_conjugacy_classes" << endl;
		}
	Aconj = NEW_OBJECT(action);

	if (f_v) {
		cout << "Creating action by conjugation" << endl;
		}
	
	Aconj->induced_action_by_conjugation(S, 
		S, FALSE /* f_ownership */, FALSE /* f_basis */, verbose_level - 1);

	if (f_v) {
		cout << "Creating action by conjugation done" << endl;
		}	

	ABC = Aconj->G.ABC;


	Sch = NEW_OBJECT(schreier);

	Sch->init(Aconj);


	SG = NEW_OBJECT(strong_generators);

	SG->init_from_sims(S, 0);
	

	Sch->init_generators(*SG->gens);

	if (f_v) {
		cout << "Computing conjugacy classes:" << endl;
		}
	Sch->compute_all_point_orbits(verbose_level);
	

	nb_classes = Sch->nb_orbits;

	class_size = NEW_int(nb_classes);
	class_rep = NEW_int(nb_classes);
	
	for (i = 0; i < nb_classes; i++) {
		class_size[i] = Sch->orbit_len[i];
		f = Sch->orbit_first[i];
		class_rep[i] = Sch->orbit[f];
		}

	if (f_v) {
		cout << "class size : ";
		int_vec_print(cout, class_size, nb_classes);
		cout << endl;
		cout << "class rep : ";
		int_vec_print(cout, class_rep, nb_classes);
		cout << endl;
		}


	if (f_v) {
		cout << "compute_conjugacy_classes done" << endl;
		}

}

int group_ring_element_size(action *A, sims *S)
{
	int goi;

	goi = S->group_order_int();
	return goi;
}

void group_ring_element_create(action *A, sims *S, int *&elt)
{
	int goi;

	goi = S->group_order_int();
	elt = NEW_int(goi);
	group_ring_element_zero(A, S, elt);
}

void group_ring_element_free(action *A, sims *S, int *elt)
{
	FREE_int(elt);
}

void group_ring_element_print(action *A, sims *S, int *elt)
{
	int goi;

	goi = S->group_order_int();
	int_vec_print(cout, elt, goi);
}

void group_ring_element_copy(action *A, sims *S,
		int *elt_from, int *elt_to)
{
	int goi;

	goi = S->group_order_int();
	int_vec_copy(elt_from, elt_to, goi);
}

void group_ring_element_zero(action *A, sims *S, int *elt)
{
	int goi;

	goi = S->group_order_int();
	int_vec_zero(elt, goi);
}

void group_ring_element_mult(action *A,
		sims *S, int *elt1, int *elt2, int *elt3)
{
	int goi;
	int i, j, k;
	int a, b, c;

	goi = S->group_order_int();
	int_vec_zero(elt3, goi);
	for (i = 0; i < goi; i++) {
		a = elt1[i];
		for (j = 0; j < goi; j++) {
			b = elt2[j];
			c = a * b;
			k = S->mult_by_rank(i, j, 0 /* verbose_level */);
			elt3[k] += c;
			}
		}
}


void perm_print_cycles_sorted_by_length(ostream &ost,
		int degree, int *perm, int verbose_level)
{
	perm_print_cycles_sorted_by_length_offset(ost,
			degree, perm, 0, FALSE, TRUE, verbose_level);
}

void perm_print_cycles_sorted_by_length_offset(ostream &ost, 
	int degree, int *perm, int offset,
	int f_do_it_anyway_even_for_big_degree,
	int f_print_cycles_of_length_one, int verbose_level)
{
	int nb_gens = 1;
	int i;
	vector_ge Gens;
	action *A;
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int f_big = FALSE;
	int f_doit = TRUE;
	
	if (f_v) {
		cout << "perm_print_cycles_sorted_by_length, "
				"degree=" << degree << endl;
		}
	
	if (degree > 500) {
		f_big = TRUE;
		}
	A = NEW_OBJECT(action);
	
	A->init_permutation_group(degree, 0/*verbose_level*/);
	Gens.init(A);
	Gens.allocate(nb_gens);
	for (i = 0; i < nb_gens; i++) {
		Gens.copy_in(i, perm + i * degree);
		}
	if (f_vv) {
		Gens.print(cout);
		}
	
	schreier S;
	
	S.init(A);
	S.init_generators(Gens);
	S.compute_all_point_orbits(verbose_level);
	if (f_v) {
		cout << "after S.compute_all_point_orbits, "
				"nb_orbits=" << S.nb_orbits << endl;
		}
	//S.print_orbit_lengths(cout);
	//S.print_orbit_length_distribution(ost);

	int j, f, l, length, F, L, h, a, b, m, orbit_idx;
	int *orbit_len_sorted;
	int *sorting_perm;
	int *sorting_perm_inv;
	int nb_types;
	int *type_first;
	int *type_len;
	
	int_vec_classify(S.nb_orbits, S.orbit_len, orbit_len_sorted, 
		sorting_perm, sorting_perm_inv, 
		nb_types, type_first, type_len);

#if 0
	ost << "permutation of degree " << degree << " with "
			<< S.nb_orbits << " orbits: " << endl;
	for (i = 0; i < nb_types; i++) {
		f = type_first[i];
		l = type_len[i];
		length = orbit_len_sorted[f];
		if (l > 1) {
			ost << l << " \\times ";
			}
		ost << length;
		if (i < nb_types - 1)
			ost << ", ";
		}
	ost << endl;
	ost << "cycles in increasing length:" << endl;
#endif
	if (f_big) {
		for (i = 0; i < nb_types; i++) {
			f = type_first[i];
			l = type_len[i];
			length = orbit_len_sorted[f];
			ost << l << " cycles of length " << length << endl;
			}
		}
	if (f_big && !f_do_it_anyway_even_for_big_degree) {
		f_doit = FALSE;
		}
	if (f_doit) {
		for (i = 0; i < nb_types; i++) {
			f = type_first[i];
			l = type_len[i];
			length = orbit_len_sorted[f];
			if (length == 1 && !f_print_cycles_of_length_one) {
				continue;
				}
			for (j = 0; j < l; j++) {
				orbit_idx = sorting_perm_inv[f + j];
				//ost << "orbit " << orbit_idx << ": ";
				F = S.orbit_first[orbit_idx];
				L = S.orbit_len[orbit_idx];
				m = S.orbit[F];
				for (h = 1; h < L; h++) {
					if (S.orbit[F + h] < m)
						m = S.orbit[F + h];
					}
				// now m is the least lement in the orbit
				ost << "(";
				a = m;
				ost << (a + offset);
				while (TRUE) {
					b = perm[a];
					if (b == m)
						break;
					ost << ", " << (b + offset);
					a = b;
					}
				ost << ")";
				if (length > 20) {
					//ost << endl;
					}
				} // next j
			//ost << endl;
			} // next i
		} // if
	//ost << "done" << endl;

#if 0
	classify C;

	C.init(S.orbit_len, S.nb_orbits, FALSE, 0);
	ost << " cycle type: ";
	C.print_file(ost, TRUE /* f_backwards */);
#endif

	FREE_int(orbit_len_sorted);
	FREE_int(sorting_perm);
	FREE_int(sorting_perm_inv);
	FREE_int(type_first);
	FREE_int(type_len);
	
	FREE_OBJECT(A);
}


void do_canonical_form(int n, finite_field *F, 
	int *set, int set_size, int f_semilinear, 
	const char *fname_base, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	//int f_vv = (verbose_level >= 2);
	projective_space *P;
	int canonical_pt;
	
	if (f_v) {
		cout << "do_canonical_form" << endl;
		}

	P = NEW_OBJECT(projective_space);
	
	if (f_v) {
		cout << "do_canonical_form before P->init" << endl;
		}
	
	P->init(n, F, 
		TRUE /* f_init_incidence_structure */, 
		verbose_level);

	if (f_v) {
		cout << "do_canonical_form after P->init" << endl;
		}

	sims *Stab;
	action *A_linear;

	A_linear = NEW_OBJECT(action);
	A_linear->init_projective_group(n + 1, F, f_semilinear, 
			TRUE /* f_basis */, verbose_level);

	if (f_v) {
		cout << "do_canonical_form before "
				"set_stabilizer_in_projective_space" << endl;
		}
	Stab = set_stabilizer_in_projective_space(
		A_linear, P, 
		set, set_size, canonical_pt, NULL /* canonical_set_or_NULL */, 
		FALSE, NULL, 
		verbose_level);
	//P->draw_point_set_in_plane(fname_base, set, set_size,
	// TRUE /*f_with_points*/, 0 /* verbose_level */);
	FREE_OBJECT(Stab);
	FREE_OBJECT(A_linear);
	FREE_OBJECT(P);

	if (f_v) {
		cout << "do_canonical_form done" << endl;
		}

}

void create_action_and_compute_orbits_on_equations(
	action *A, homogeneous_polynomial_domain *HPD,
	int *The_equations, int nb_equations, strong_generators *gens, 
	action *&A_on_equations, schreier *&Orb, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	
	if (f_v) {
		cout << "create_action_and_compute_orbits_on_equations" << endl;
		}

	A_on_equations = NEW_OBJECT(action);

	if (f_v) {
		cout << "creating the induced action on the equations:" << endl;
		}
	A_on_equations->induced_action_on_homogeneous_polynomials_given_by_equations(A, 
		HPD, 
		The_equations, nb_equations, 
		FALSE /* f_induce_action */, NULL /* sims *old_G */, 
		0 /*verbose_level */);
	if (f_v) {
		cout << "The induced action on the equations has been created, "
				"degree = " << A_on_equations->degree << endl;
		}
	
	if (f_v) {
		cout << "computing orbits on the equations:" << endl;
		}
	Orb = gens->orbits_on_points_schreier(A_on_equations,
			0 /* verbose_level + 10 */);

	if (f_v) {
		cout << "We found " << Orb->nb_orbits
				<< " orbits on the equations:" << endl;
		Orb->print_and_list_orbits_tex(cout);
		}

	if (f_v) {
		cout << "create_action_and_compute_orbits_on_equations done" << endl;
		}
}


}
