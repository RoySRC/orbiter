// ovoid.C
// 
// Anton Betten
// May 16, 2011
//
//
// 
//
//

#include "orbiter.h"

#include "ovoid.h"

using namespace orbiter;


// global data:

int t0; // the system time when the program started


int main(int argc, const char **argv)
{
	t0 = os_ticks();
	
	if (argc <= 3) {
		usage(argc, argv);
		exit(1);
		}

	{
	ovoid_generator Gen;
	int schreier_depth = 10000;
	int f_use_invariant_subset_if_available = TRUE;
	//int f_implicit_fusion = FALSE;
	int f_debug = FALSE;
	int verbose_level = 0;
	
	Gen.init(argc, argv, verbose_level);

	int f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "before generator_main" << endl;
		}
	
	if (Gen.f_read) {
		orbiter_data_file *ODF;
		char fname[1000];
		int i, j;
		int level = Gen.read_level;

		sprintf(fname, "%s_lvl_%d", Gen.prefix_with_directory, level);

		ODF = NEW_OBJECT(orbiter_data_file);
		ODF->load(fname, verbose_level);
		cout << "found " << ODF->nb_cases
				<< " orbits at level " << level << endl;


		int f_split = FALSE;
		int split_r = 0;
		int split_m = 1;
		char fname_graph_mask[1000];
		int f_lexorder = TRUE;

		sprintf(fname_graph_mask,
				"graph_ovoid_Q%d_%d_%d_level%d_case%%d.bin",
				Gen.epsilon, Gen.d - 1, Gen.q, level);

		cout << "creating graphs:" << endl;

#if 0
		Gen.make_graphs(ODF,
			f_split, split_r, split_m,
			f_lexorder,
			//candidates_fname,
			fname_graph_mask,
			verbose_level);
#else
		int orbit_idx;

		for (orbit_idx = 0; orbit_idx < ODF->nb_cases; orbit_idx++) {

			if (f_split) {
				if ((orbit_idx % split_m) == split_r) {
					continue;
				}
			}
			cout << orbit_idx << " / " << ODF->nb_cases << " : ";
			int_vec_print(cout, ODF->sets[orbit_idx],
					ODF->set_sizes[orbit_idx]);
			cout << " : " << ODF->Ago_ascii[orbit_idx] << " : "
					<< ODF->Aut_ascii[orbit_idx] << endl;

			char fname_graph[1000];
			colored_graph *CG;

			sprintf(fname_graph, fname_graph_mask, orbit_idx);

			Gen.make_one_graph(ODF,
				orbit_idx,
				f_lexorder,
				CG,
				verbose_level);

			CG->save(fname_graph, 0);

			delete CG;
		} // for orbit_idx
#endif
		cout << "creating graphs done" << endl;


		for (i = 0; i < ODF->nb_cases; i++) {
			cout << i << " / " << ODF->nb_cases << " : ";
			int_vec_print(cout, ODF->sets[i], ODF->set_sizes[i]);
			cout << " : " << ODF->Ago_ascii[i] << " : "
					<< ODF->Aut_ascii[i] << endl;


			if (strcmp(ODF->Ago_ascii[i], "1") != 0) {
				strong_generators *SG;
				longinteger_object go;

				SG = NEW_OBJECT(strong_generators);
				SG->init(Gen.A);
				SG->decode_ascii_coding(ODF->Aut_ascii[i],
						0 /* verbose_level */);
				SG->group_order(go);
				cout << "The stabilizer has order " << go
						<< " and is generated by " << endl;
				for (j = 0; j < SG->gens->len; j++) {
					cout << j << " / " << SG->gens->len << ":" << endl;
					Gen.A->element_print_quick(SG->gens->ith(j), cout);
					cout << endl;
					}
				cout << "G := Group([" << endl;
				for (j = 0; j < SG->gens->len; j++) {
					Gen.A->element_print_as_permutation_with_offset(
						SG->gens->ith(j), cout,
						1 /* offset */,
						TRUE /*  f_do_it_anyway_even_for_big_degree */,
						FALSE /* f_print_cycles_of_length_one */,
						0 /* verbose_level*/);
					if (j < SG->gens->len - 1) {
						cout << ", ";
						}
					cout << endl;
					}
				cout << "]);" << endl;
				cout << "group order " << go << endl;
				FREE_OBJECT(SG);
			}

#if 0
			int *candidates;
			int nb_candidates;

			if (f_has_candidates) {
				generator_read_candidates_of_orbit(candidates_fname,
						i /* orbit_at_level */,
						candidates, nb_candidates, 0 /* verbose_level */);
				cout << "With " << nb_candidates << " live points: ";
				int_vec_print(cout, candidates, nb_candidates);
				cout << endl;

			}
			else {
				read_candidates_for_one_orbit_from_file(Gen.prefix,
						level, i /* orbit_at_level */,
						level - 1 /* level_of_candidates_file */,
						ODF->sets[i],
						ovoid_generator_early_test_func_callback,
						&Gen,
						candidates,
						nb_candidates,
						verbose_level);
			}
#endif
			} // end for i
		FREE_OBJECT(ODF);
		}
	else {
		Gen.gen->main(t0, 
			schreier_depth, 
			f_use_invariant_subset_if_available, 
			f_debug, 
			verbose_level);
	
		if (Gen.f_draw_poset) {
			Gen.gen->draw_poset(Gen.prefix_with_directory, 
			Gen.gen->depth, 0 /* data1 */, 
			Gen.f_embedded, 
			Gen.f_sideways, 
			Gen.gen->verbose_level);
			}
		if (Gen.f_list) {
			Gen.gen->list_all_orbits_at_level(Gen.gen->depth, 
				FALSE, NULL, NULL, 
				FALSE, FALSE, FALSE, FALSE);
			}
		}

	} // clean up ovoid_generator
	
	the_end_quietly(t0);
}

void usage(int argc, const char **argv)
{
	cout << "usage: " << argv[0]
			<< " -epsilon <epsilon> -n <n> -q <q>" << endl;
	cout << "Searches for partial ovoids in Q^\epsilon(n,q) "
			"(n is projective dimension)" << endl;
	cout << "where options can be:" << endl;

	cout << "-v <k>" << endl;
	cout << "   verbose level k" << endl;
	cout << "-list" << endl;
	cout << "   list all orbits" << endl;
	cout << "-poly <m>" << endl;
	cout << "   Use the polynomial m to create the field GF(q) "
			"(m is a number)" << endl;

	poset_classification gen;
	
	gen.usage();

}


void callback_print_set(ostream &ost, int len, int *S, void *data)
{
	ovoid_generator *Gen = (ovoid_generator *) data;
	
	//print_vector(ost, S, len);
	Gen->print(ost, S, len);
}

#if 0
int callback_check_conditions(int len, int *S,
		void *data, int verbose_level)
{
	ovoid_generator *Gen = (ovoid_generator *) data;
	return Gen->check_conditions(len, S, verbose_level);
}
#endif



