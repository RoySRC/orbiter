// analyze_q_designs.cpp
// 
// Anton Betten
// Jul 23, 2016
//
 

#include "orbiter.h"

using namespace std;


using namespace orbiter;



void analyze(int n, int k, int t, int q,
	const char *fname, int verbose_level);
void analyze_design(int n, int k, int t, int q,
	finite_field *F,
	grassmann *Gr_t, grassmann *Gr_k, grassmann *Gr_tk,
	int *design, int len, int verbose_level);
void test_group(int n, int k, int t, int q,
		const char *fname, linear_group_description *Descr,
		int verbose_level);
void group_of_design(int n, int k, int t, int q,
	finite_field *F,
	grassmann *Gr_t, grassmann *Gr_k, grassmann *Gr_tk, 
	action *A, action *A2, 
	int *design, int len, int verbose_level);


int main(int argc, const char **argv)
{
	int i;
	int verbose_level = 0;
	int f_n = FALSE;
	int n = 0;
	int f_k = FALSE;
	int k = 0;
	int f_t = FALSE;
	int t = 0;
	int f_q = FALSE;
	int q = 0;
	int f_file = FALSE;
	const char *fname = NULL;
	int f_linear = FALSE;
	linear_group_description *Descr = NULL;
	
	for (i = 1; i < argc; i++) {
		if (strcmp(argv[i], "-v") == 0) {
			verbose_level = atoi(argv[++i]);
			cout << "-v " << verbose_level << endl;
			}
		else if (strcmp(argv[i], "-q") == 0) {
			f_q = TRUE;
			q = atoi(argv[++i]);
			cout << "-q " << q << endl;
			}
		else if (strcmp(argv[i], "-k") == 0) {
			f_k = TRUE;
			k = atoi(argv[++i]);
			cout << "-k " << k << endl;
			}
		else if (strcmp(argv[i], "-t") == 0) {
			f_t = TRUE;
			t = atoi(argv[++i]);
			cout << "-t " << t << endl;
			}
		else if (strcmp(argv[i], "-n") == 0) {
			f_n = TRUE;
			n = atoi(argv[++i]);
			cout << "-n " << n << endl;
			}
		else if (strcmp(argv[i], "-file") == 0) {
			f_file = TRUE;
			fname = argv[++i];
			cout << "-file " << fname << endl;
			}
		else if (strcmp(argv[i], "-linear") == 0) {
			f_linear = TRUE;
			Descr = NEW_OBJECT(linear_group_description);
			i += Descr->read_arguments(argc - (i - 1), argv + i, verbose_level);

			cout << "after Descr->read_arguments" << endl;
			}
		}
	if (!f_n) {
		cout << "please use option -n <n>" << endl;
		exit(1);
		}
	if (!f_k) {
		cout << "please use option -k <k>" << endl;
		exit(1);
		}
	if (!f_t) {
		cout << "please use option -t <t>" << endl;
		exit(1);
		}
	if (!f_q) {
		cout << "please use option -q <q>" << endl;
		exit(1);
		}
	if (!f_file) {
		cout << "please use option -file <fname>" << endl;
		exit(1);
		}
	analyze(n, k, t, q, fname, verbose_level);

	if (f_linear) {
		test_group(n, k, t, q, fname, Descr, verbose_level);
		}
}

void analyze(int n, int k, int t, int q,
		const char *fname, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int *Designs;
	int nb_designs, len;
	finite_field *F;
	grassmann *Gr_t;
	grassmann *Gr_k;
	grassmann *Gr_tk;
	int i;
	file_io Fio;


	if (f_v) {
		cout << "analyze" << endl;
		}
	Fio.int_matrix_read_csv(fname,
			Designs, nb_designs, len, 0 /* verbose_level */);

	cout << "read " << nb_designs << " from file " << fname << endl;

	F = NEW_OBJECT(finite_field);
	F->init(q, 0);
	Gr_t = NEW_OBJECT(grassmann);
	Gr_t->init(n, t, F, 0/*verbose_level - 10*/);
	Gr_k = NEW_OBJECT(grassmann);
	Gr_k->init(n, k, F, 0/*verbose_level - 10*/);
	Gr_tk = NEW_OBJECT(grassmann);
	Gr_tk->init(k, t, F, 0/*verbose_level - 10*/);
	


	for (i = 0; i < nb_designs; i++) {
		cout << "analyzing design " << i << " / "
			<< nb_designs << ":" << endl;
		analyze_design(n, k, t, q, F, Gr_t, Gr_k, Gr_tk,
				Designs + i * len, len, verbose_level);
		}

	FREE_OBJECT(Gr_t);
	FREE_OBJECT(Gr_k);
	FREE_OBJECT(Gr_tk);
	FREE_OBJECT(F);
}

void analyze_design(int n, int k, int t, int q,
	finite_field *F,
	grassmann *Gr_t, grassmann *Gr_k, grassmann *Gr_tk,
	int *design, int len, int verbose_level)
{
	int Nt;
	int *c;
	int j, a, h, kCt, rk;
	int *Mtx;
	int *subspace_basis_with_embedding;

	Mtx = NEW_int(k * n);
	subspace_basis_with_embedding = NEW_int(k * n);
	Nt = Gr_t->nCkq.as_int();
	c = NEW_int(Nt);
	Nt = Gr_t->nCkq.as_int();
	int_vec_zero(c, Nt);
	kCt = Gr_tk->nCkq.as_int();
	for (j = 0; j < len; j++) {
		a = design[j];
		Gr_k->unrank_int_here(Mtx, a, 0 /* verbose_level */);
#if 0
		cout << "subspace " << j << " / " << len
				<< " is generated by:" << endl;
		int_matrix_print(Mtx, k, n);
#endif

		grassmann_embedded *GE;

		GE = new grassmann_embedded;
		GE->init(n /* big_n */, k /* n */, Gr_tk, Mtx, verbose_level);
		// M is n x big_n
		// G is for k-dimensional subspaces of an n-space.

#if 0
		cout << "looping over the " << kCt << " subspaces of dimension "
				<< t << " of it:" << endl;
#endif

		for (h = 0; h < kCt; h++) {
			GE->unrank_embedded_int(subspace_basis_with_embedding,
					h, 0 /* verbose_level */);
				// subspace_basis_with_embedding is n x big_n (i.e., k x n here)
			rk = Gr_t->rank_int_here(subspace_basis_with_embedding,
					0 /* verbose_level */);
#if 0
			cout << "subspace " << h << " / " << kCt << ":" << endl;
			int_matrix_print(subspace_basis_with_embedding, t, n);
			cout << "has rank " << rk << endl;
#endif
			c[rk]++;
			}

		delete GE;
		}
	cout << "the covering vector of " << t << "-subspaces is: ";
	{
	classify C;
	C.init(c, Nt, FALSE, 0);
	C.print_naked(TRUE);
	cout << endl;
	} 

	FREE_int(Mtx);
	FREE_int(subspace_basis_with_embedding);
	FREE_int(c);
	
}

void test_group(int n, int k, int t, int q,
		const char *fname, linear_group_description *Descr,
		int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int *Designs;
	int nb_designs, len;
	finite_field *F;
	grassmann *Gr_t;
	grassmann *Gr_k;
	grassmann *Gr_tk;
	linear_group *LG;
	action *A;
	action *A2;
	sims *S;
	int i;
	file_io Fio;


	if (f_v) {
		cout << "test_group" << endl;
		}
	Fio.int_matrix_read_csv(fname, Designs,
			nb_designs, len, 0 /* verbose_level */);

	cout << "read " << nb_designs << " from file " << fname << endl;


	F = NEW_OBJECT(finite_field);

	F->init(Descr->input_q, 0);
	//F->init_override_polynomial(Descr->input_q, override_poly, 0);
	Descr->F = F;
	q = Descr->input_q;

	LG = NEW_OBJECT(linear_group);

	cout << "test_group before LG->init, creating the group" << endl;

	LG->init(Descr, verbose_level);
	
	cout << "test_group after LG->init, strong generators "
			"for the group have been created" << endl;

	A = LG->A_linear;
	A2 = LG->A2;
	S = LG->Strong_gens->create_sims(0 /*verbose_level */);
		
	Gr_t = NEW_OBJECT(grassmann);
	Gr_t->init(n, t, F, 0/*verbose_level - 10*/);
	Gr_k = NEW_OBJECT(grassmann);
	Gr_k->init(n, k, F, 0/*verbose_level - 10*/);
	Gr_tk = NEW_OBJECT(grassmann);
	Gr_tk->init(k, t, F, 0/*verbose_level - 10*/);

	if (f_v) {
		cout << "test_group after create_linear_group" << endl;
		}

	for (i = 0; i < nb_designs; i++) {
		cout << "analyzing design " << i << " / " << nb_designs << ":" << endl;
		group_of_design(n, k, t, q, F, Gr_t, Gr_k, Gr_tk, A, A2,
				Designs + i * len, len, verbose_level);
		}

}


void group_of_design(int n, int k, int t, int q,
	finite_field *F,
	grassmann *Gr_t, grassmann *Gr_k, grassmann *Gr_tk, 
	action *A, action *A2, 
	int *design, int len, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	os_interface Os;
	int t0 = Os.os_ticks();
	poset *Poset;
	set_stabilizer_compute *S;
	sims *Stab;

	if (f_v) {
		cout << "group_of_design" << endl;
		}
	S = NEW_OBJECT(set_stabilizer_compute);
	
	strong_generators *Aut_gens;
	int nb_backtrack_nodes;

	if (f_v) {
		cout << "group_of_design initializing "
				"set_stabilizer_compute:" << endl;
		cout << "A=";
		A->print_info();
		cout << "A2=";
		A2->print_info();
		}

	Poset = NEW_OBJECT(poset);
	Poset->init_subset_lattice(A2, A,
			A->Strong_gens,
			verbose_level);

	S->init_with_strong_generators(Poset,
		design /* the_set */, len /*set_size*/,
		verbose_level);

	//S->init(A2, design /* the_set */, len /*set_size*/, verbose_level);
	
	if (f_v) {
		cout << "group_of_design computing set stabilizer:" << endl;
		}
	S->compute_set_stabilizer(t0,
			nb_backtrack_nodes, Aut_gens, verbose_level + 3);
	
	Stab = Aut_gens->create_sims(verbose_level - 1);

	if (f_v) {
		cout << "group_of_design stabilizer has been computed" << endl;
		cout << "nb_backtrack_nodes=" << nb_backtrack_nodes << endl;
		}
	longinteger_object go;
	Stab->group_order(go);
	cout << "group order = " << go << endl;
	cout << "Generators are:" << endl;
	Aut_gens->print_generators();
	cout << "group order = " << go << endl;

	FREE_OBJECT(Aut_gens);
	
}

