// BN_pair.cpp
// 
// Anton Betten
// July 20, 2010
//
//
// Computes a BN pair in the orthogonal group 
// O^\epsilon(n,q) with Witt index \ell
// Then computes the Weyl group W = N / (B \cap N) of type D_\ell
//
// To do:
// Right now, we get a group that is twice the order of D_\ell
// That's because we start with the orthogonal group. 
// We should start with the simple group \Omega.



#include "orbiter.h"

using namespace std;


using namespace orbiter;
using namespace orbiter::top_level;

// global data:

int t0; // the system time when the program started

int main(int argc, char **argv);
void init_orthogonal(action *A, int epsilon, int n,
		finite_field *F, int verbose_level);
void compute_B(action *A, int epsilon, int n,
		finite_field *F, int verbose_level);
void compute_N(action *A, int epsilon, int n,
		finite_field *F, int verbose_level);



int main(int argc, char **argv)
{
	int verbose_level = 0;
	int i;
	int f_epsilon = FALSE;
	int epsilon = 0;
	int f_n = FALSE;
	int n = 0;
	int f_q = FALSE;
	int q;
	
 	t0 = os_ticks();
	
	for (i = 1; i < argc; i++) {
		if (strcmp(argv[i], "-v") == 0) {
			verbose_level = atoi(argv[++i]);
			cout << "-v " << verbose_level << endl;
			}
		else if (strcmp(argv[i], "-epsilon") == 0) {
			f_epsilon = TRUE;
			epsilon = atoi(argv[++i]);
			cout << "-epsilon " << epsilon << endl;
			}
		else if (strcmp(argv[i], "-n") == 0) {
			f_n = TRUE;
			n = atoi(argv[++i]);
			cout << "-n " << n << endl;
			}
		else if (strcmp(argv[i], "-q") == 0) {
			f_q = TRUE;
			q = atoi(argv[++i]);
			cout << "-q " << q << endl;
			}
		}
	if (!f_epsilon) {
		cout << "please use -epsilon option" << endl;
		exit(1);
		}
	if (!f_n) {
		cout << "please use -n option" << endl;
		exit(1);
		}
	if (!f_q) {
		cout << "please use -q option" << endl;
		exit(1);
		}

	action *A;
	finite_field *F;

	A = NEW_OBJECT(action);
	F = NEW_OBJECT(finite_field);
	
	cout << "epsilon=" << epsilon << endl;
	cout << "n=" << n << endl;
	cout << "q=" << q << endl;

	F->init(q, 0);
	init_orthogonal(A, epsilon, n, F, verbose_level);
	
	cout << "after init_orthogonal" << endl;


	//action_on_orthogonal *AO;
	//orthogonal *O;

	//AO = A->G.AO;
	//O = AO->O;


	cout << "computing the group B:" << endl;
	compute_B(A, epsilon, n, F, verbose_level);


	cout << "computing the group N:" << endl;
	compute_N(A, epsilon, n, F, verbose_level);


	the_end(t0);
}



void init_orthogonal(action *A, int epsilon, int n,
		finite_field *F, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int f_vv = (verbose_level >= 2);
	int p, hh, f_semilinear;
	int f_basis = TRUE;
	number_theory_domain NT;

	if (f_v) {
		cout << "init_orthogonal epsilon=" << epsilon
				<< " n=" << n << " q=" << F->q << endl;
		}

	NT.is_prime_power(F->q, p, hh);
	if (hh > 1) {
		f_semilinear = TRUE;
		}
	else {
		f_semilinear = FALSE;
		}

	if (f_v) {
		cout << "f_semilinear=" << f_semilinear << endl;
		}

	A->init_orthogonal_group(epsilon, 
		n, F, 
		TRUE /* f_on_points */,
		FALSE /* f_on_lines */,
		FALSE /* f_on_points_and_lines */,
		f_semilinear, f_basis, 
		0/*verbose_level*/);


	if (f_vv) {
		A->print_base();
		}
	
	
	if (f_v) {
		cout << "init_orthogonal finished, created action:" << endl;
		A->print_info();
		}
}


void compute_B(action *A, int epsilon, int n,
		finite_field *F, int verbose_level)
{
	polar P;
	int depth;
	action_on_orthogonal *AO;
	orthogonal *O;
	geometry_global Gg;
	

	AO = A->G.AO;
	O = AO->O;

	depth = Gg.Witt_index(epsilon, n - 1);
	
	P.init(0, NULL, A, O, epsilon, n,
			depth, F, depth, verbose_level);

	P.Gen->f_do_group_extension_in_upstep = FALSE;
		// since we want to stabilize the flag
	P.init2(verbose_level);

	
	P.compute_orbits(t0, verbose_level);
	
	cout << "we found " << P.nb_orbits
			<< " orbits at depth " << depth << endl;
	
	strong_generators *Strong_gens;
	longinteger_object go;

	P.Gen->get_stabilizer_generators(Strong_gens,  
		depth, 0 /* orbit_at_level */, 0 /* verbose_level */);

	cout << "The stabilizer is generated by:" << endl;
	Strong_gens->print_generators();
	
	Strong_gens->group_order(go);
	
	cout << "The order of the stabilizer is: " << go << endl;
	FREE_OBJECT(Strong_gens);
}

void compute_N(action *A, int epsilon, int n,
		finite_field *F, int verbose_level)
{
	int f_v = (verbose_level >= 1);
	int *the_set;
	int *v;
	int the_set_size;
	set_stabilizer_compute *S;
	longinteger_object go;
	int i, h;
	action_on_orthogonal *AO;
	orthogonal *O;
	




	if (f_v) {
		cout << "compute_N" << endl;
		}
	AO = A->G.AO;
	O = AO->O;
	
	S = NEW_OBJECT(set_stabilizer_compute);
	the_set = NEW_int(n);
	v = NEW_int(n); // n = algebraic dimension
	the_set_size = 0;
	for (h = 0; h < n; h++) {
		for (i = 0; i < n; i++) {
			v[i] = 0;
			}
		if (epsilon == 0 && h == 0) {
			continue;
			}
		v[h] = 1;
		the_set[the_set_size++] = O->rank_point(v, 1, 0);
		}
	if (f_v) {
		cout << "the_set=";
		int_vec_print(cout, the_set, the_set_size);
		cout << endl;
		}


	int f_vv = (verbose_level >= 2);
	sims *Stab;
	int nb_backtrack_nodes;


	poset *Poset;
	strong_generators *Aut_gens;
	
	Poset = NEW_OBJECT(poset);
	Poset = NEW_OBJECT(poset);
	Poset->init_subset_lattice(A, A,
			A->Strong_gens,
			verbose_level);

	if (f_vv) {
		cout << "initializing set_stabilizer_compute:" << endl;
		}
	S->init(Poset, the_set, the_set_size, verbose_level - 3);
	
	if (f_vv) {
		cout << "computing set stabilizer:" << endl;
		}
	S->compute_set_stabilizer(t0, nb_backtrack_nodes,
			Aut_gens, verbose_level - 3);
	
	Stab = Aut_gens->create_sims(verbose_level - 1);
	FREE_OBJECT(Aut_gens);
	
	if (f_vv) {
		cout << "stabilizer has been computed" << endl;
		cout << "nb_backtrack_nodes=" << nb_backtrack_nodes << endl;
		}


	if (f_v) {
		cout << "######################################" << endl;
		Stab->group_order(go);
		cout << "generators for N:" << endl;
		Stab->gens.print(cout);
		cout << "the group N has order " << go << endl;
		cout << endl;
		Stab->print_transversal_lengths();
		cout << endl;
		cout << "######################################" << endl;
		}


	action *A2;
	longinteger_object go_induced;
	int f_induce_action = TRUE;

	//A2 = NEW_OBJECT(action);
	
	A2 = A->create_induced_action_by_restriction(
		Stab,
		the_set_size, the_set,
		f_induce_action,
		verbose_level);

	if (f_v) {
		cout << "created induced action: " << endl;
		A2->print_info();
		}
	A2->group_order(go_induced);


	FREE_OBJECT(Stab);
	if (f_v) {
		cout << "the induced action has order " << go_induced << endl;
		}

}



