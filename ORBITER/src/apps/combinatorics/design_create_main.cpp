/*
 * design_create_main.cpp
 *
 *  Created on: Sep 19, 2019
 *      Author: betten
 */


#include "orbiter.h"

using namespace std;


using namespace orbiter;
using namespace orbiter::top_level;

// global data:

int t0; // the system time when the program started

int main(int argc, const char **argv);

int main(int argc, const char **argv)
{
	int verbose_level = 0;
	int i;
	int f_design = FALSE;
	design_create_description *Descr;
	int f_depth = FALSE;
	int depth = 0;
	int f_output_prefix = FALSE;
	const char *output_prefix = "";
	int f_read_classification = FALSE;
	int read_classification_level = 0;
	int f_lift_this = FALSE;
	const char *lift_this_set = NULL;
	int f_lift_case = FALSE;
	int lift_case_level = 0;
	int lift_case = 0;

	t0 = os_ticks();


	for (i = 1; i < argc; i++) {
		if (strcmp(argv[i], "-v") == 0) {
			verbose_level = atoi(argv[++i]);
			cout << "-v " << verbose_level << endl;
		}
		else if (strcmp(argv[i], "-design") == 0) {
			f_design = TRUE;
			Descr = NEW_OBJECT(design_create_description);
			i += Descr->read_arguments(argc - (i - 1),
					argv + i, verbose_level) - 1;

			cout << "-design" << endl;
		}
		else if (strcmp(argv[i], "-depth") == 0) {
			f_depth = TRUE;
			depth = atoi(argv[++i]);
			cout << "-depth " << depth << endl;
		}
		else if (strcmp(argv[i], "-output_prefix") == 0) {
			f_output_prefix = TRUE;
			output_prefix = argv[++i];
			cout << "-output_prefix " << output_prefix << endl;
		}
		else if (strcmp(argv[i], "-read_classification") == 0) {
			f_read_classification = TRUE;
			read_classification_level = atoi(argv[++i]);
			cout << "-read_classification " << read_classification_level << endl;
		}
		else if (strcmp(argv[i], "-lift_this") == 0) {
			f_lift_this = TRUE;
			lift_this_set = argv[++i];
			cout << "-lift_this " << lift_this_set << endl;
		}
		else if (strcmp(argv[i], "-lift_case") == 0) {
			f_lift_case = TRUE;
			lift_case_level = atoi(argv[++i]);
			lift_case = atoi(argv[++i]);
			cout << "-lift_case " << lift_case_level << " " << lift_case << endl;
		}
	}
	if (!f_design) {
		cout << "please use option -design ... "
				"to enter a description of the design" << endl;
		exit(1);
	}

	design_create *DC;
	//int j;

	DC = NEW_OBJECT(design_create);

	cout << "before DC->init" << endl;
	DC->init(Descr, verbose_level);
	cout << "after DC->init" << endl;



	action *A;
	//int *Elt1;
	int *Elt2;

	A = DC->A;

	Elt2 = NEW_int(A->elt_size_in_int);



#if 0
	if (DC->f_has_group) {
		for (i = 0; i < BC->Sg->gens->len; i++) {
			cout << "Testing generator " << i << " / "
					<< BC->Sg->gens->len << endl;
			A->element_invert(BC->Sg->gens->ith(i),
					Elt2, 0 /*verbose_level*/);


			cout << "Generator " << i << " / " << SC->Sg->gens->len
					<< " is good" << endl;
			}
		}
	else {
		cout << "We do not have information about the "
				"automorphism group" << endl;
		}
#endif


	cout << "We have created the following design:" << endl;
	cout << "$$" << endl;
	int_set_print_tex(cout, DC->set, DC->sz);
	cout << endl;
	cout << "$$" << endl;

	if (DC->f_has_group) {
		cout << "The stabilizer is generated by:" << endl;
		DC->Sg->print_generators_tex(cout);
		}


	orbit_of_sets *SetOrb;

	SetOrb = NEW_OBJECT(orbit_of_sets);

	cout << "computing orbit:" << endl;
	SetOrb->init(DC->A, DC->A2,
			DC->set, DC->sz, DC->A->Strong_gens->gens,
			verbose_level);
	cout << "computing orbit done" << endl;


	large_set_classify *LS;

	LS = NEW_OBJECT(large_set_classify);

	int f_lexorder_test = TRUE;
	char base_fname[1000];
	const char *design_tables_prefix = "";

	sprintf(base_fname, "LS_%s", DC->prefix);
	LS->init(DC,
			output_prefix, base_fname,
			depth,
			f_lexorder_test,
			design_tables_prefix,
			verbose_level);

	LS->init_designs(SetOrb, verbose_level);

	if (f_read_classification) {
		cout << "reading classification at level " << read_classification_level << endl;

		orbit_transversal *T;

		LS->read_classification(T,
				read_classification_level, verbose_level);

		cout << "computing and reporting ago distribution:" << endl;

		T->report_ago_distribution(cout);

		FREE_OBJECT(T);
	}
	else if (f_lift_this) {
		cout << "lifting a given set" << endl;
		int *lift_starter;
		int lift_starter_sz;


		int_vec_scan(lift_this_set, lift_starter, lift_starter_sz);
		cout << "lift_starter = ";
		int_vec_print(cout, lift_starter, lift_starter_sz);
		cout << endl;


	}
	else if (f_lift_case) {
		cout << "lifting a single case" << endl;

		set_and_stabilizer *Rep;

		LS->read_classification_single_case(Rep,
				lift_case_level, lift_case, verbose_level);

		cout << "the set in case " << lift_case << " is:" << endl;
		Rep->print_set_tex(cout);
		cout << endl;

		cout << "The designs are:" << endl;
		for (i = 0; i < Rep->sz; i++) {
			int a;

			a = Rep->data[i];
			cout << i << " & " << a << " & ";
			int_vec_print(cout, LS->Design_table + a * LS->design_size, LS->design_size);
			cout << endl;
		}

		cout << "The blocks of the designs are:" << endl;
		int *block;

		block = NEW_int(LS->DC->k);

		for (i = 0; i < Rep->sz; i++) {
			int a, b, j;

			a = Rep->data[i];
			cout << "design " << i << " is " << a << " has the following blocks:" << endl;
			for (j = 0; j < LS->design_size; j++) {
				b = LS->Design_table[a * LS->design_size + j];
				LS->DC->unrank_block_in_PG_2_q(block,
						b, 0 /*verbose_level*/);
				cout << "block " << j << " is " << b << " : ";
				int_vec_print(cout, block, LS->DC->k);
				cout << endl;
			}
		}

		FREE_int(block);


		cout << "strong generators are:" << endl;
		Rep->Strong_gens->print_generators_tex();

		int *Design_table_out;
		int *Design_table_out_idx;
		int nb_out;

		LS->make_reduced_design_table(
				Rep->data, Rep->sz,
				Design_table_out, Design_table_out_idx, nb_out,
				verbose_level);
		cout << "The reduced design table has length " << nb_out << endl;
		action *A_reduced;

		cout << "creating A_reduced:" << endl;
		A_reduced = LS->A_on_designs->restricted_action(
				Design_table_out_idx, nb_out,
				verbose_level);


		cout << "computing orbits on reduced set of designs:" << endl;

		schreier *Orbits_on_reduced;

		A_reduced->compute_orbits_on_points(Orbits_on_reduced,
				Rep->Strong_gens->gens, verbose_level);

		cout << "The orbits on the reduced set of designs are:" << endl;

		Orbits_on_reduced->print_and_list_orbits_sorted_by_length(
			cout, TRUE /* f_tex */);

		FREE_OBJECT(Orbits_on_reduced);
		FREE_OBJECT(A_reduced);
		FREE_OBJECT(Rep);

	}
	else {
		if (f_depth) {
			cout << "classification of starter" << endl;
			cout << "depth = " << depth << endl;
			LS->gen->depth = depth;

			LS->compute(verbose_level);
		}
	}

	FREE_int(Elt2);

	FREE_OBJECT(DC);

	the_end(t0);
	//the_end_quietly(t0);
}




