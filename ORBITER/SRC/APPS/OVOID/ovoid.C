// ovoid.C
// 
// Anton Betten
// May 16, 2011
//
//
// 
//
//

#include "orbiter.h"

#include "ovoid.h"

// global data:

INT t0; // the system time when the program started


int main(int argc, const char **argv)
{
	t0 = os_ticks();
	
	if (argc <= 3) {
		usage(argc, argv);
		exit(1);
		}

	{
	ovoid_generator Gen;
	INT schreier_depth = 10000;
	INT f_use_invariant_subset_if_available = TRUE;
	//INT f_implicit_fusion = FALSE;
	INT f_debug = FALSE;
	INT verbose_level = 0;
	
	Gen.init(argc, argv, verbose_level);

	INT f_v = (verbose_level >= 1);

	if (f_v) {
		cout << "before generator_main" << endl;
		}
	
	if (Gen.f_read) {
		orbiter_data_file *ODF;
		BYTE fname[1000];
		INT i, j;

		sprintf(fname, "%s_lvl_%ld", Gen.prefix_with_directory, Gen.read_level);
		ODF = new orbiter_data_file;
		ODF->load(fname, verbose_level);
		cout << "found " << ODF->nb_cases << " orbits at level " << Gen.read_level << endl;
		for (i = 0; i < ODF->nb_cases; i++) {
			cout << i << " / " << ODF->nb_cases << " : ";
			INT_vec_print(cout, ODF->sets[i], ODF->set_sizes[i]);
			cout << " : " << ODF->Ago_ascii[i] << " : " << ODF->Aut_ascii[i] << endl;

			strong_generators *SG;
			longinteger_object go;

			SG = new strong_generators;
			SG->init(Gen.A);
			SG->decode_ascii_coding(ODF->Aut_ascii[i], 0 /* verbose_level */);
			SG->group_order(go);
			cout << "The stabilizer has order " << go << " and is generated by " << endl;
			for (j = 0; j < SG->gens->len; j++) {
				cout << j << " / " << SG->gens->len << ":" << endl;
				Gen.A->element_print_quick(SG->gens->ith(j), cout);
				cout << endl;
				}
			cout << "G := Group([" << endl;
			for (j = 0; j < SG->gens->len; j++) {
				Gen.A->element_print_as_permutation_with_offset(
					SG->gens->ith(j), cout, 
					1 /* offset */, 
					TRUE /*  f_do_it_anyway_even_for_big_degree */, 
					FALSE /* f_print_cycles_of_length_one */, 
					0 /* verbose_level*/);
				if (j < SG->gens->len - 1) {
					cout << ", ";
					}
				cout << endl;
				}
			cout << "]);" << endl;
			cout << "group order " << go << endl;
			delete SG;
			}
		delete ODF;
		}
	else {
		Gen.gen->main(t0, 
			schreier_depth, 
			f_use_invariant_subset_if_available, 
			f_debug, 
			verbose_level);
	
		if (Gen.f_draw_poset) {
			Gen.gen->draw_poset(Gen.prefix_with_directory, 
			Gen.gen->depth, 0 /* data1 */, 
			Gen.f_embedded, 
			Gen.f_sideways, 
			Gen.gen->verbose_level);
			}
		if (Gen.f_list) {
			Gen.gen->list_all_orbits_at_level(Gen.gen->depth, 
				FALSE, NULL, NULL, 
				FALSE, FALSE, FALSE, FALSE);
			}
		}

#if 0
	if (Gen.f_surface) {

		Gen.process_surfaces(verbose_level);

		cout << "nb_lines=" << Gen.O->nb_points << " nb_pts=" << Gen.SC->nb_pts << " nb_orbits=" << Gen.gen->nb_orbits_at_level(5) << endl;
		}
#endif

	} // clean up ovoid_generator
	
	the_end_quietly(t0);
}

void usage(int argc, const char **argv)
{
	cout << "usage: " << argv[0] << " -epsilon <epsilon> -n <n> -q <q>" << endl;
	cout << "Searches for partial ovoids in Q^\epsilon(n,q) (n is projective dimension)" << endl;
	cout << "where options can be:" << endl;

	cout << "-v <k>" << endl;
	cout << "   verbose level k" << endl;
	cout << "-list" << endl;
	cout << "   list all orbits" << endl;
	cout << "-poly <m>" << endl;
	cout << "   Use the polynomial m to create the field GF(q) (m is a number)" << endl;

	generator gen;
	
	gen.usage();

}


void callback_print_set(INT len, INT *S, void *data)
{
	ovoid_generator *Gen = (ovoid_generator *) data;
	
	//print_vector(ost, S, len);
	Gen->print(S, len);
}

INT callback_check_conditions(INT len, INT *S, void *data, INT verbose_level)
{
	ovoid_generator *Gen = (ovoid_generator *) data;
	return Gen->check_conditions(len, S, verbose_level);
}

#if 0
INT callback_check_surface(INT len, INT *S, void *data, INT verbose_level)
{
	ovoid_generator *Gen = (ovoid_generator *) data;
	return Gen->check_surface(len, S, verbose_level);
}
#endif


